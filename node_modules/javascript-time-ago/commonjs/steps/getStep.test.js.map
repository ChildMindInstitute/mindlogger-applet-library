{"version":3,"sources":["../../source/steps/getStep.test.js"],"names":["describe","it","expect","round","units","to","be","undefined","steps","slice","formatAs","should","equal","granularity","now","firstStep","splice","unshift","unit","minTime","default","id","seconds","threshold"],"mappings":"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","sourcesContent":["import getStep from './getStep'\r\nimport round from './round'\r\n\r\ndescribe('getStep', () => {\r\n\tit('should return nothing if no time units are supported', () => {\r\n\t\texpect(getStep(round, 0, { units: ['femtosecond'] })).to.be.undefined\r\n\t})\r\n\r\n\t// it('should throw if a non-first step does not have a `minTime` or `test()`', () => {\r\n\t// \texpect(getStep([{ unit: 'second' }], 2, { units: ['second'] })).to.deep.equal({ unit: 'second' })\r\n\t//\r\n\t// \texpect(() => {\r\n\t// \t\tgetStep([{ unit: 'second' }, { unit: 'minute' }], 2, { units: ['second', 'minute'] })\r\n\t// \t}).to.throw(\r\n\t// \t\t'Each step must define either `minTime` or `test()`, except for the first one. Got \"undefined\", undefined. Step: {\"unit\":\"minute\"}'\r\n\t// \t)\r\n\t// })\r\n\r\n\tit('should fall back to previous step if granularity is too high for the next step', () => {\r\n\t\tconst steps = round.slice()\r\n\r\n\t\tsteps[1].formatAs.should.equal('second')\r\n\t\tsteps[1].granularity = 3\r\n\r\n\t\tgetStep(steps, 1.49, { now: 0, units: ['now', 'second'] }).formatAs.should.equal('now')\r\n\r\n\t\t// And if there's no previous step, then use the current one.\r\n\r\n\t\tconst firstStep = steps[0]\r\n\t\tsteps.splice(0, 1)\r\n\r\n\t\tgetStep(steps, 1.49, { now: 0, units: ['now', 'second'] }).formatAs.should.equal('second')\r\n\r\n\t\tsteps.unshift(firstStep)\r\n\r\n\t\tdelete steps[1].granularity\r\n\t})\r\n\r\n\tit('should support `minTime` object', () => {\r\n\t\texpect(getStep(\r\n\t\t\t[\r\n\t\t\t\t{ unit: 'second' },\r\n\t\t\t\t{\r\n\t\t\t\t\tminTime: { default: 10 },\r\n\t\t\t\t\tunit: 'minute'\r\n\t\t\t\t}\r\n\t\t\t],\r\n\t\t\t5,\r\n\t\t\t{ now: 0, units: ['second', 'minute'] }\r\n\t\t).unit).to.equal('second')\r\n\r\n\t\texpect(getStep(\r\n\t\t\t[\r\n\t\t\t\t{ unit: 'second' },\r\n\t\t\t\t{\r\n\t\t\t\t\tminTime: { default: 10 },\r\n\t\t\t\t\tunit: 'minute'\r\n\t\t\t\t}\r\n\t\t\t],\r\n\t\t\t10,\r\n\t\t\t{ now: 0, units: ['second', 'minute'] }\r\n\t\t).unit).to.equal('minute')\r\n\r\n\t\texpect(getStep(\r\n\t\t\t[\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 'seconds',\r\n\t\t\t\t\tunit: 'second'\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\tminTime: {\r\n\t\t\t\t\t\tseconds: 20,\r\n\t\t\t\t\t\tdefault: 10\r\n\t\t\t\t\t},\r\n\t\t\t\t\tunit: 'minute'\r\n\t\t\t\t}\r\n\t\t\t],\r\n\t\t\t10,\r\n\t\t\t{ now: 0, units: ['second', 'minute'] }\r\n\t\t).unit).to.equal('second')\r\n\t})\r\n\r\n\tit('should support legacy `threshold()` function', () => {\r\n\t\texpect(getStep(\r\n\t\t\t[\r\n\t\t\t\t{ unit: 'second' },\r\n\t\t\t\t{\r\n\t\t\t\t\tthreshold: () => 10,\r\n\t\t\t\t\tunit: 'minute'\r\n\t\t\t\t}\r\n\t\t\t],\r\n\t\t\t5,\r\n\t\t\t{ now: 0, units: ['second', 'minute'] }\r\n\t\t).unit).to.equal('second')\r\n\r\n\t\texpect(getStep(\r\n\t\t\t[\r\n\t\t\t\t{ unit: 'second' },\r\n\t\t\t\t{\r\n\t\t\t\t\tthreshold: () => 10,\r\n\t\t\t\t\tunit: 'minute'\r\n\t\t\t\t}\r\n\t\t\t],\r\n\t\t\t10,\r\n\t\t\t{ now: 0, units: ['second', 'minute'] }\r\n\t\t).unit).to.equal('minute')\r\n\t})\r\n\r\n\tit('should stop when reaching a step that has no \"minTime\" and for which \"minTime\" could not be deduced', () => {\r\n\t\texpect(getStep(\r\n\t\t\t[\r\n\t\t\t\t{ formatAs: 'second' },\r\n\t\t\t\t{ formatAs: 'unsupported-time-unit' }\r\n\t\t\t],\r\n\t\t\t10,\r\n\t\t\t{ now: 0, units: ['second', 'unsupported-time-unit'] }\r\n\t\t).formatAs).to.equal('second')\r\n\t})\r\n})"],"file":"getStep.test.js"}