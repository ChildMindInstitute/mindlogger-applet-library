{"version":3,"sources":["../../src/ts/filter/floating/provided/simpleFloatingFilter.ts"],"names":[],"mappings":"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","file":"simpleFloatingFilter.js","sourcesContent":["import {Component} from \"../../../widgets/component\";\nimport {IFloatingFilterComp, IFloatingFilterParams} from \"../floatingFilter\";\nimport {ProvidedFilterModel} from \"../../../interfaces/iFilter\";\nimport {ICombinedSimpleModel, ISimpleFilterModel, SimpleFilter} from \"../../provided/simpleFilter\";\nimport {OptionsFactory} from \"../../provided/optionsFactory\";\nimport {IScalarFilterParams} from \"../../provided/scalerFilter\";\nimport {FilterChangedEvent} from \"../../../events\";\n\nexport abstract class SimpleFloatingFilter extends Component implements IFloatingFilterComp {\n\n    // this method is on IFloatingFilterComp. because it's not implemented at this level, we have to\n    // define it as an abstract method. it gets implemented in sub classes.\n    public abstract onParentModelChanged(model: ProvidedFilterModel, event: FilterChangedEvent): void;\n\n    // creates text equivalent of FilterModel. if it's a combined model, this takes just one condition.\n    protected abstract conditionToString(condition: ProvidedFilterModel): string;\n    protected abstract getDefaultFilterOptions(): string[];\n    protected abstract setEditable(editable: boolean): void;\n\n    private lastType: string;\n\n    private optionsFactory: OptionsFactory;\n\n    protected getDefaultDebounceMs(): number {\n        return 0;\n    }\n\n    // used by:\n    // 1) NumberFloatingFilter & TextFloatingFilter: Always, for both when editable and read only.\n    // 2) DateFloatingFilter: Only when read only (as we show text rather than a date picker when read only)\n    protected getTextFromModel(model: ProvidedFilterModel): string {\n        if (!model) {\n            return null;\n        }\n\n        const isCombined = (model as any).operator;\n\n        if (isCombined) {\n            const combinedModel = model as ICombinedSimpleModel<ISimpleFilterModel>;\n\n            const con1Str = this.conditionToString(combinedModel.condition1);\n            const con2Str = this.conditionToString(combinedModel.condition2);\n\n            return `${con1Str} ${combinedModel.operator} ${con2Str}`;\n        } else {\n            const condition = model as ISimpleFilterModel;\n            return this.conditionToString(condition);\n        }\n    }\n\n    protected isEventFromFloatingFilter(event: FilterChangedEvent): boolean {\n        return (event && (event as any).afterFloatingFilter);\n    }\n\n    protected getLastType(): string {\n        return this.lastType;\n    }\n\n    protected setLastTypeFromModel(model: ProvidedFilterModel): void {\n        // if no model provided by the parent filter use default\n        if (!model) {\n            this.lastType = this.optionsFactory.getDefaultOption();\n            return;\n        }\n\n        const isCombined = (model as any).operator;\n\n        let condition: ISimpleFilterModel;\n\n        if (isCombined) {\n            const combinedModel = model as ICombinedSimpleModel<ISimpleFilterModel>;\n            condition = combinedModel.condition1;\n        } else {\n            condition = model as ISimpleFilterModel;\n        }\n\n        this.lastType = condition.type;\n    }\n\n    protected canWeEditAfterModelFromParentFilter(model: ProvidedFilterModel): boolean {\n\n        if (!model) {\n            // if no model, then we can edit as long as the lastType is something we can edit, as this\n            // is the type we will provide to the parent filter if the user decides to use the floating filter.\n            return this.isTypeEditable(this.lastType);\n        }\n\n        // never allow editing if the filter is combined (ie has two parts)\n        const isCombined = (model as any).operator;\n        if (isCombined) {\n            return false;\n        }\n\n        const simpleModel = model as ISimpleFilterModel;\n\n        const typeIsEditable = this.isTypeEditable(simpleModel.type);\n        return typeIsEditable;\n    }\n\n    public init(params: IFloatingFilterParams): void {\n        this.optionsFactory = new OptionsFactory();\n        this.optionsFactory.init(params.filterParams as IScalarFilterParams, this.getDefaultFilterOptions());\n        this.lastType = this.optionsFactory.getDefaultOption();\n\n        // we are editable if:\n        // 1) there is a type (user has configured filter wrong if not type)\n        //  AND\n        // 2) the default type is not 'in range'\n        const editable = this.isTypeEditable(this.lastType);\n        this.setEditable(editable);\n    }\n\n    private doesFilterHaveHiddenInput(filterType: string) {\n        const customFilterOption = this.optionsFactory.getCustomOption(filterType);\n        return customFilterOption && customFilterOption.hideFilterInput;\n    }\n\n    private isTypeEditable(type: string): boolean {\n\n        if (this.doesFilterHaveHiddenInput(type)) {\n            return false;\n        }\n\n        return type\n            && (type != SimpleFilter.IN_RANGE)\n            && (type != SimpleFilter.EMPTY);\n    }\n}\n"]}