{"version":3,"sources":["../../src/ts/valueService/changeDetectionService.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,8CAAoE;AAEpE,oDAAmD;AAInD,0CAAyC;AACzC,gDAA+C;AAC/C,oCAA0D;AAI1D;IAA4C,0CAAQ;IAApD;;IA6CA,CAAC;IAnCW,qCAAI,GAAZ;QACI,IAAI,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE,KAAK,qBAAS,CAAC,0BAA0B,EAAE;YAClE,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC,QAA+B,CAAC;SAClE;QAED,IAAI,CAAC,2BAA2B,CAAC,IAAI,CAAC,YAAY,EAAE,eAAM,CAAC,wBAAwB,EAAE,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;IAC7H,CAAC;IAEO,mDAAkB,GAA1B,UAA2B,KAA4B;QAEnD,gFAAgF;QAChF,mFAAmF;QACnF,4FAA4F;QAC5F,4FAA4F;QAC5F,wFAAwF;QACxF,8BAA8B;QAC9B,IAAI,KAAK,CAAC,MAAM,KAAK,qBAAS,CAAC,YAAY,EAAE;YAAE,OAAO;SAAE;QAExD,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,IAAI,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC;IACrD,CAAC;IAEO,kDAAiB,GAAzB,UAA0B,OAAgB,EAAE,MAAc;QACtD,IAAI,IAAI,CAAC,kBAAkB,CAAC,yBAAyB,EAAE,EAAE;YAAE,OAAO;SAAE;QAEpE,gEAAgE;QAChE,IAAI,IAAI,CAAC,kBAAkB,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE,EAAE;YACnD,IAAM,kBAAkB,GAAG,IAAI,CAAC,kBAAkB,CAAC,6BAA6B,EAAE,CAAC;YACnF,IAAM,WAAW,GAAG,IAAI,yBAAW,CAAC,kBAAkB,EAAE,IAAI,CAAC,kBAAkB,CAAC,WAAW,EAAE,CAAC,CAAC;YAC/F,WAAW,CAAC,aAAa,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC;YACpD,IAAI,CAAC,kBAAkB,CAAC,WAAW,CAAC,WAAW,CAAC,CAAC;SACpD;QAED,qDAAqD;QACrD,IAAI,CAAC,WAAW,CAAC,YAAY,EAAE,CAAC;IACpC,CAAC;IA1CgC;QAAhC,mBAAS,CAAC,oBAAoB,CAAC;sEAAgD;IACzD;QAAtB,mBAAS,CAAC,UAAU,CAAC;4DAA6B;IACzB;QAAzB,mBAAS,CAAC,aAAa,CAAC;+DAAkC;IAChC;QAA1B,mBAAS,CAAC,cAAc,CAAC;gEAAoC;IAK9D;QADC,uBAAa;sDAOb;IAhBQ,sBAAsB;QADlC,cAAI,CAAC,wBAAwB,CAAC;OAClB,sBAAsB,CA6ClC;IAAD,6BAAC;CA7CD,AA6CC,CA7C2C,mBAAQ,GA6CnD;AA7CY,wDAAsB","file":"changeDetectionService.js","sourcesContent":["import { Column } from \"../entities/column\";\nimport { RowNode } from \"../entities/rowNode\";\nimport { Autowired, Bean, PostConstruct } from \"../context/context\";\nimport { GridOptionsWrapper } from \"../gridOptionsWrapper\";\nimport { ChangedPath } from \"../utils/changedPath\";\nimport { IRowModel } from \"../interfaces/iRowModel\";\nimport { RowRenderer } from \"../rendering/rowRenderer\";\nimport { EventService } from \"../eventService\";\nimport { Constants } from \"../constants\";\nimport { BeanStub } from \"../context/beanStub\";\nimport { CellValueChangedEvent, Events } from \"../events\";\nimport { IClientSideRowModel } from \"../interfaces/iClientSideRowModel\";\n\n@Bean('changeDetectionService')\nexport class ChangeDetectionService extends BeanStub {\n\n    @Autowired('gridOptionsWrapper') private gridOptionsWrapper: GridOptionsWrapper;\n    @Autowired('rowModel') private rowModel: IRowModel;\n    @Autowired('rowRenderer') private rowRenderer: RowRenderer;\n    @Autowired('eventService') private eventService: EventService;\n\n    private clientSideRowModel: IClientSideRowModel;\n\n    @PostConstruct\n    private init(): void {\n        if (this.rowModel.getType() === Constants.ROW_MODEL_TYPE_CLIENT_SIDE) {\n            this.clientSideRowModel = this.rowModel as IClientSideRowModel;\n        }\n\n        this.addDestroyableEventListener(this.eventService, Events.EVENT_CELL_VALUE_CHANGED, this.onCellValueChanged.bind(this));\n    }\n\n    private onCellValueChanged(event: CellValueChangedEvent): void {\n\n        // Clipboard service manages its own change detection, so no need to do it here.\n        // The clipboard manages its own as otherwise this would happen once for every cell\n        // that got updated as part of a paste operation, so e.g. if 100 cells in a paste operation,\n        // this doChangeDetection would get called 100 times (once for each cell), instead clipboard\n        // service executes the logic we have here once (in essence batching up all cell changes\n        // into one change detection).\n        if (event.source === Constants.SOURCE_PASTE) { return; }\n\n        this.doChangeDetection(event.node, event.column);\n    }\n\n    private doChangeDetection(rowNode: RowNode, column: Column): void {\n        if (this.gridOptionsWrapper.isSuppressChangeDetection()) { return; }\n\n        // step 1 of change detection is to update the aggregated values\n        if (this.clientSideRowModel && !rowNode.isRowPinned()) {\n            const onlyChangedColumns = this.gridOptionsWrapper.isAggregateOnlyChangedColumns();\n            const changedPath = new ChangedPath(onlyChangedColumns, this.clientSideRowModel.getRootNode());\n            changedPath.addParentNode(rowNode.parent, [column]);\n            this.clientSideRowModel.doAggregate(changedPath);\n        }\n\n        // step 2 of change detection is to refresh the cells\n        this.rowRenderer.refreshCells();\n    }\n}"]}