{"version":3,"sources":["../../src/ts/gridPanel/rowDragFeature.ts"],"names":[],"mappings":"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","file":"rowDragFeature.js","sourcesContent":["import {\n    DragAndDropService, DraggingEvent, DragSourceType, DropTarget,\n    VerticalDirection\n} from \"../dragAndDrop/dragAndDropService\";\nimport { Autowired, Optional, PostConstruct } from \"../context/context\";\nimport { FocusedCellController } from \"../focusedCellController\";\nimport { IRangeController } from \"../interfaces/iRangeController\";\nimport { GridPanel } from \"./gridPanel\";\nimport { GridOptionsWrapper } from \"../gridOptionsWrapper\";\nimport { EventService } from \"../eventService\";\nimport { RowDragEvent } from \"../events\";\nimport { Events } from \"../eventKeys\";\nimport { IRowModel } from \"../interfaces/iRowModel\";\nimport { Constants } from \"../constants\";\nimport { IClientSideRowModel } from \"../interfaces/iClientSideRowModel\";\n\nexport class RowDragFeature implements DropTarget {\n\n    @Autowired('dragAndDropService') private dragAndDropService: DragAndDropService;\n    // this feature is only created when row model is ClientSide, so we can type it as ClientSide\n    @Autowired('rowModel') private rowModel: IRowModel;\n    @Autowired('focusedCellController') private focusedCellController: FocusedCellController;\n    @Autowired('gridOptionsWrapper') private gridOptionsWrapper: GridOptionsWrapper;\n    @Optional('rangeController') private rangeController: IRangeController;\n    @Autowired('eventService') private eventService: EventService;\n\n    private gridPanel: GridPanel;\n\n    private clientSideRowModel: IClientSideRowModel;\n\n    private eContainer: HTMLElement;\n\n    private needToMoveUp: boolean;\n    private needToMoveDown: boolean;\n\n    private movingIntervalId: number;\n    private intervalCount: number;\n\n    private lastDraggingEvent: DraggingEvent;\n\n    constructor(eContainer: HTMLElement, gridPanel: GridPanel) {\n        this.eContainer = eContainer;\n        this.gridPanel = gridPanel;\n    }\n\n    @PostConstruct\n    private postConstruct(): void {\n        if (this.gridOptionsWrapper.isRowModelDefault()) {\n            this.clientSideRowModel = this.rowModel as IClientSideRowModel;\n        }\n    }\n\n    public getContainer(): HTMLElement {\n        return this.eContainer;\n    }\n\n    public isInterestedIn(type: DragSourceType): boolean {\n        return type === DragSourceType.RowDrag;\n    }\n\n    public getIconName(): string {\n        return DragAndDropService.ICON_MOVE;\n    }\n\n    public onDragEnter(draggingEvent: DraggingEvent): void {\n        // when entering, we fire the enter event, then in onEnterOrDragging,\n        // we also fire the move event. so we get both events when entering.\n        this.dispatchEvent(Events.EVENT_ROW_DRAG_ENTER, draggingEvent);\n        this.dragAndDropService.setGhostIcon(DragAndDropService.ICON_MOVE);\n        draggingEvent.dragItem.rowNode.setDragging(true);\n        this.onEnterOrDragging(draggingEvent);\n    }\n\n    public onDragging(draggingEvent: DraggingEvent): void {\n        this.onEnterOrDragging(draggingEvent);\n    }\n\n    private onEnterOrDragging(draggingEvent: DraggingEvent): void {\n        // this event is fired for enter and move\n        this.dispatchEvent(Events.EVENT_ROW_DRAG_MOVE, draggingEvent);\n\n        this.lastDraggingEvent = draggingEvent;\n        const pixel = this.normaliseForScroll(draggingEvent.y);\n\n        const managedDrag = this.gridOptionsWrapper.isRowDragManaged();\n        if (managedDrag) {\n            this.doManagedDrag(draggingEvent, pixel);\n        }\n\n        this.checkCenterForScrolling(pixel);\n    }\n\n    private doManagedDrag(draggingEvent: DraggingEvent, pixel: number): void {\n        const rowNode = draggingEvent.dragItem.rowNode;\n        const rowWasMoved = this.clientSideRowModel.ensureRowAtPixel(rowNode, pixel);\n\n        if (rowWasMoved) {\n            this.focusedCellController.clearFocusedCell();\n            if (this.rangeController) {\n                this.rangeController.removeAllCellRanges();\n            }\n        }\n    }\n\n    private normaliseForScroll(pixel: number): number {\n        const gridPanelHasScrolls = this.gridOptionsWrapper.getDomLayout() === Constants.DOM_LAYOUT_NORMAL;\n        if (gridPanelHasScrolls) {\n            const pixelRange = this.gridPanel.getVScrollPosition();\n            return pixel + pixelRange.top;\n        } else {\n            return pixel;\n        }\n    }\n\n    private checkCenterForScrolling(pixel: number): void {\n\n        // scroll if the mouse is within 50px of the grid edge\n        const pixelRange = this.gridPanel.getVScrollPosition();\n\n        // console.log(`pixelRange = (${pixelRange.top}, ${pixelRange.bottom})`);\n\n        this.needToMoveUp = pixel < (pixelRange.top + 50);\n        this.needToMoveDown = pixel > (pixelRange.bottom - 50);\n\n        // console.log(`needToMoveUp = ${this.needToMoveUp} = pixel < (pixelRange.top + 50) = ${pixel} < (${pixelRange.top} + 50)`);\n        // console.log(`needToMoveDown = ${this.needToMoveDown} = pixel < (pixelRange.top + 50) = ${pixel} < (${pixelRange.top} + 50)`);\n\n        if (this.needToMoveUp || this.needToMoveDown) {\n            this.ensureIntervalStarted();\n        } else {\n            this.ensureIntervalCleared();\n        }\n    }\n\n    private ensureIntervalStarted(): void {\n        if (!this.movingIntervalId) {\n            this.intervalCount = 0;\n            this.movingIntervalId = window.setInterval(this.moveInterval.bind(this), 100);\n        }\n    }\n\n    private ensureIntervalCleared(): void {\n        if (this.moveInterval) {\n            window.clearInterval(this.movingIntervalId);\n            this.movingIntervalId = null;\n        }\n    }\n\n    private moveInterval(): void {\n        // the amounts we move get bigger at each interval, so the speed accelerates, starting a bit slow\n        // and getting faster. this is to give smoother user experience. we max at 100px to limit the speed.\n        let pixelsToMove: number;\n        this.intervalCount++;\n        pixelsToMove = 10 + (this.intervalCount * 5);\n        if (pixelsToMove > 100) {\n            pixelsToMove = 100;\n        }\n\n        let pixelsMoved: number;\n        if (this.needToMoveDown) {\n            pixelsMoved = this.gridPanel.scrollVertically(pixelsToMove);\n        } else if (this.needToMoveUp) {\n            pixelsMoved = this.gridPanel.scrollVertically(-pixelsToMove);\n        }\n\n        if (pixelsMoved !== 0) {\n            this.onDragging(this.lastDraggingEvent);\n        }\n    }\n\n    // i tried using generics here with this:\n    //     public createEvent<T extends RowDragEvent>(type: string, clazz: {new(): T; }, draggingEvent: DraggingEvent) {\n    // but it didn't work - i think it's because it only works with classes, and not interfaces, (the events are interfaces)\n    public dispatchEvent(type: string, draggingEvent: DraggingEvent): void {\n\n        const yNormalised = this.normaliseForScroll(draggingEvent.y);\n\n        let overIndex = -1;\n        let overNode = null;\n        const mouseIsPastLastRow = yNormalised > this.rowModel.getCurrentPageHeight();\n\n        if (!mouseIsPastLastRow) {\n            overIndex = this.rowModel.getRowIndexAtPixel(yNormalised);\n            overNode = this.rowModel.getRow(overIndex);\n        }\n\n        let vDirectionString: string;\n        switch (draggingEvent.vDirection) {\n            case VerticalDirection.Down:\n                vDirectionString = 'down';\n                break;\n            case VerticalDirection.Up:\n                vDirectionString = 'up';\n                break;\n            default:\n                vDirectionString = null;\n                break;\n        }\n\n        const event: RowDragEvent = {\n            type: type,\n            api: this.gridOptionsWrapper.getApi(),\n            columnApi: this.gridOptionsWrapper.getColumnApi(),\n            event: draggingEvent.event,\n            node: draggingEvent.dragItem.rowNode,\n            overIndex: overIndex,\n            overNode: overNode,\n            y: yNormalised,\n            vDirection: vDirectionString\n        };\n\n        this.eventService.dispatchEvent(event);\n    }\n\n    public onDragLeave(draggingEvent: DraggingEvent): void {\n        this.dispatchEvent(Events.EVENT_ROW_DRAG_LEAVE, draggingEvent);\n        this.stopDragging(draggingEvent);\n    }\n\n    public onDragStop(draggingEvent: DraggingEvent): void {\n        this.dispatchEvent(Events.EVENT_ROW_DRAG_END, draggingEvent);\n        this.stopDragging(draggingEvent);\n    }\n\n    private stopDragging(draggingEvent: DraggingEvent): void {\n        this.ensureIntervalCleared();\n        draggingEvent.dragItem.rowNode.setDragging(false);\n    }\n}"]}