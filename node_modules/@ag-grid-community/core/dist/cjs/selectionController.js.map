{"version":3,"sources":["../../src/ts/selectionController.ts"],"names":[],"mappings":"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","file":"selectionController.js","sourcesContent":["import { RowNode } from \"./entities/rowNode\";\nimport { Bean } from \"./context/context\";\nimport { Qualifier } from \"./context/context\";\nimport { Logger } from \"./logger\";\nimport { LoggerFactory } from \"./logger\";\nimport { EventService } from \"./eventService\";\nimport { Events, SelectionChangedEvent } from \"./events\";\nimport { Autowired } from \"./context/context\";\nimport { IRowModel } from \"./interfaces/iRowModel\";\nimport { GridOptionsWrapper } from \"./gridOptionsWrapper\";\nimport { PostConstruct } from \"./context/context\";\nimport { Constants } from \"./constants\";\nimport { ColumnApi } from \"./columnController/columnApi\";\nimport { GridApi } from \"./gridApi\";\nimport { _ } from './utils';\nimport { ChangedPath } from \"./utils/changedPath\";\nimport {IClientSideRowModel} from \"./interfaces/iClientSideRowModel\";\n\n@Bean('selectionController')\nexport class SelectionController {\n\n    @Autowired('eventService') private eventService: EventService;\n    @Autowired('rowModel') private rowModel: IRowModel;\n    @Autowired('gridOptionsWrapper') private gridOptionsWrapper: GridOptionsWrapper;\n    @Autowired('columnApi') private columnApi: ColumnApi;\n    @Autowired('gridApi') private gridApi: GridApi;\n\n    private selectedNodes: { [key: string]: RowNode | undefined };\n    private logger: Logger;\n\n    // used for shift selection, so we know where to start the range selection from\n    private lastSelectedNode: RowNode | null;\n\n    private groupSelectsChildren: boolean;\n\n    private setBeans(@Qualifier('loggerFactory') loggerFactory: LoggerFactory) {\n        this.logger = loggerFactory.create('SelectionController');\n        this.reset();\n\n        if (this.gridOptionsWrapper.isRowModelDefault()) {\n            this.eventService.addEventListener(Events.EVENT_ROW_DATA_CHANGED, this.reset.bind(this));\n        } else {\n            this.logger.log('dont know what to do here');\n        }\n    }\n\n    @PostConstruct\n    public init(): void {\n        this.groupSelectsChildren = this.gridOptionsWrapper.isGroupSelectsChildren();\n        this.eventService.addEventListener(Events.EVENT_ROW_SELECTED, this.onRowSelected.bind(this));\n    }\n\n    public setLastSelectedNode(rowNode: RowNode): void {\n        this.lastSelectedNode = rowNode;\n    }\n\n    public getLastSelectedNode(): RowNode | null {\n        return this.lastSelectedNode;\n    }\n\n    public getSelectedNodes() {\n        const selectedNodes: RowNode[] = [];\n        _.iterateObject(this.selectedNodes, (key: string, rowNode: RowNode) => {\n            if (rowNode) {\n                selectedNodes.push(rowNode);\n            }\n        });\n        return selectedNodes;\n    }\n\n    public getSelectedRows() {\n        const selectedRows: any[] = [];\n        _.iterateObject(this.selectedNodes, (key: string, rowNode: RowNode) => {\n            if (rowNode && rowNode.data) {\n                selectedRows.push(rowNode.data);\n            }\n        });\n        return selectedRows;\n    }\n\n    public removeGroupsFromSelection(): void {\n        _.iterateObject(this.selectedNodes, (key: string, rowNode: RowNode) => {\n            if (rowNode && rowNode.group) {\n                this.selectedNodes[rowNode.id] = undefined;\n            }\n        });\n    }\n\n    // should only be called if groupSelectsChildren=true\n    public updateGroupsFromChildrenSelections(changedPath?: ChangedPath): void {\n        // we only do this when group selection state depends on selected children\n        if (!this.gridOptionsWrapper.isGroupSelectsChildren()) {\n            return;\n        }\n        // also only do it if CSRM (code should never allow this anyway)\n        if (this.rowModel.getType() !== Constants.ROW_MODEL_TYPE_CLIENT_SIDE) {\n            return;\n        }\n\n        const clientSideRowModel = this.rowModel as IClientSideRowModel;\n        const rootNode = clientSideRowModel.getRootNode();\n\n        if (!changedPath) {\n            changedPath = new ChangedPath(true, rootNode);\n            changedPath.setInactive();\n        }\n\n        changedPath.forEachChangedNodeDepthFirst(rowNode => {\n            if (rowNode !== rootNode) {\n                rowNode.calculateSelectedFromChildren();\n            }\n        });\n\n        // clientSideRowModel.getTopLevelNodes()!.forEach((rowNode: RowNode) => {\n        //     rowNode.depthFirstSearch((node) => {\n        //         if (node.group) {\n        //         }\n        //     });\n        // });\n\n    }\n\n    public getNodeForIdIfSelected(id: number): RowNode | undefined {\n        return this.selectedNodes[id];\n    }\n\n    public clearOtherNodes(rowNodeToKeepSelected: RowNode): number {\n        const groupsToRefresh: any = {};\n        let updatedCount = 0;\n        _.iterateObject(this.selectedNodes, (key: string, otherRowNode: RowNode) => {\n            if (otherRowNode && otherRowNode.id !== rowNodeToKeepSelected.id) {\n                const rowNode = this.selectedNodes[otherRowNode.id];\n                updatedCount += rowNode!.setSelectedParams({\n                    newValue: false,\n                    clearSelection: false,\n                    suppressFinishActions: true\n                });\n                if (this.groupSelectsChildren && otherRowNode.parent) {\n                    groupsToRefresh[otherRowNode.parent.id] = otherRowNode.parent;\n                }\n            }\n        });\n        _.iterateObject(groupsToRefresh, (key: string, group: RowNode) => {\n            group.calculateSelectedFromChildren();\n        });\n        return updatedCount;\n    }\n\n    private onRowSelected(event: any): void {\n        const rowNode = event.node;\n\n        // we do not store the group rows when the groups select children\n        if (this.groupSelectsChildren && rowNode.group) {\n            return;\n        }\n\n        if (rowNode.isSelected()) {\n            this.selectedNodes[rowNode.id] = rowNode;\n        } else {\n            this.selectedNodes[rowNode.id] = undefined;\n        }\n    }\n\n    public syncInRowNode(rowNode: RowNode, oldNode: RowNode): void {\n        this.syncInOldRowNode(rowNode, oldNode);\n        this.syncInNewRowNode(rowNode);\n    }\n\n    // if the id has changed for the node, then this means the rowNode\n    // is getting used for a different data item, which breaks\n    // our selectedNodes, as the node now is mapped by the old id\n    // which is inconsistent. so to keep the old node as selected,\n    // we swap in the clone (with the old id and old data). this means\n    // the oldNode is effectively a daemon we keep a reference to,\n    // so if client calls api.getSelectedNodes(), it gets the daemon\n    // in the result. when the client un-selects, the reference to the\n    // daemon is removed. the daemon, because it's an oldNode, is not\n    // used by the grid for rendering, it's a copy of what the node used\n    // to be like before the id was changed.\n    private syncInOldRowNode(rowNode: RowNode, oldNode: RowNode): void {\n        const oldNodeHasDifferentId = _.exists(oldNode) && (rowNode.id !== oldNode.id);\n        if (oldNodeHasDifferentId) {\n            const oldNodeSelected = _.exists(this.selectedNodes[oldNode.id]);\n            if (oldNodeSelected) {\n                this.selectedNodes[oldNode.id] = oldNode;\n            }\n        }\n    }\n\n    private syncInNewRowNode(rowNode: RowNode): void {\n        if (_.exists(this.selectedNodes[rowNode.id])) {\n            rowNode.setSelectedInitialValue(true);\n            this.selectedNodes[rowNode.id] = rowNode;\n        } else {\n            rowNode.setSelectedInitialValue(false);\n        }\n    }\n\n    public reset(): void {\n        this.logger.log('reset');\n        this.selectedNodes = {};\n        this.lastSelectedNode = null;\n    }\n\n    // returns a list of all nodes at 'best cost' - a feature to be used\n    // with groups / trees. if a group has all it's children selected,\n    // then the group appears in the result, but not the children.\n    // Designed for use with 'children' as the group selection type,\n    // where groups don't actually appear in the selection normally.\n    public getBestCostNodeSelection() {\n\n        if (this.rowModel.getType() !== Constants.ROW_MODEL_TYPE_CLIENT_SIDE) {\n            console.warn('getBestCostNodeSelection is only available when using normal row model');\n            return;\n        }\n\n        const clientSideRowModel = this.rowModel as IClientSideRowModel;\n\n        const topLevelNodes = clientSideRowModel.getTopLevelNodes();\n\n        if (topLevelNodes === null) {\n            console.warn('selectAll not available doing rowModel=virtual');\n            return;\n        }\n\n        const result: any = [];\n\n        // recursive function, to find the selected nodes\n        function traverse(nodes: any) {\n            for (let i = 0, l = nodes.length; i < l; i++) {\n                const node = nodes[i];\n                if (node.isSelected()) {\n                    result.push(node);\n                } else {\n                    // if not selected, then if it's a group, and the group\n                    // has children, continue to search for selections\n                    if (node.group && node.children) {\n                        traverse(node.children);\n                    }\n                }\n            }\n        }\n\n        traverse(topLevelNodes);\n\n        return result;\n    }\n\n    public setRowModel(rowModel: any) {\n        this.rowModel = rowModel;\n    }\n\n    public isEmpty(): boolean {\n        let count = 0;\n        _.iterateObject(this.selectedNodes, (nodeId: string, rowNode: RowNode) => {\n            if (rowNode) {\n                count++;\n            }\n        });\n        return count === 0;\n    }\n\n    public deselectAllRowNodes(justFiltered = false) {\n\n        const callback = (rowNode: RowNode) => rowNode.selectThisNode(false);\n        const rowModelClientSide = this.rowModel.getType() === Constants.ROW_MODEL_TYPE_CLIENT_SIDE;\n\n        if (justFiltered) {\n            if (!rowModelClientSide) {\n                console.error('ag-Grid: selecting just filtered only works with In Memory Row Model');\n                return;\n            }\n            const clientSideRowModel = this.rowModel as IClientSideRowModel;\n            clientSideRowModel.forEachNodeAfterFilter(callback);\n        } else {\n            _.iterateObject(this.selectedNodes, (id: string, rowNode: RowNode) => {\n                // remember the reference can be to null, as we never 'delete' from the map\n                if (rowNode) {\n                    callback(rowNode);\n                }\n            });\n            // this clears down the map (whereas above only sets the items in map to 'undefined')\n            this.reset();\n        }\n\n        // the above does not clean up the parent rows if they are selected\n        if (rowModelClientSide && this.groupSelectsChildren) {\n            this.updateGroupsFromChildrenSelections();\n        }\n\n        const event: SelectionChangedEvent = {\n            type: Events.EVENT_SELECTION_CHANGED,\n            api: this.gridApi,\n            columnApi: this.columnApi\n        };\n\n        this.eventService.dispatchEvent(event);\n    }\n\n    public selectAllRowNodes(justFiltered = false) {\n        if (this.rowModel.getType() !== Constants.ROW_MODEL_TYPE_CLIENT_SIDE) {\n            throw new Error(`selectAll only available with normal row model, ie not ${this.rowModel.getType()}`);\n        }\n\n        const clientSideRowModel = this.rowModel as IClientSideRowModel;\n        const callback = (rowNode: RowNode) => rowNode.selectThisNode(true);\n\n        if (justFiltered) {\n            clientSideRowModel.forEachNodeAfterFilter(callback);\n        } else {\n            clientSideRowModel.forEachNode(callback);\n        }\n\n        // the above does not clean up the parent rows if they are selected\n        if (this.rowModel.getType() === Constants.ROW_MODEL_TYPE_CLIENT_SIDE && this.groupSelectsChildren) {\n            this.updateGroupsFromChildrenSelections();\n        }\n\n        const event: SelectionChangedEvent = {\n            type: Events.EVENT_SELECTION_CHANGED,\n            api: this.gridApi,\n            columnApi: this.columnApi\n        };\n        this.eventService.dispatchEvent(event);\n    }\n\n    /**\n     * @method\n     * @deprecated\n     */\n    public selectNode(rowNode: RowNode | null, tryMulti: boolean) {\n        if (rowNode) {\n            rowNode.setSelectedParams({newValue: true, clearSelection: !tryMulti});\n        }\n    }\n\n    /**\n     * @method\n     * @deprecated\n     */\n    public deselectIndex(rowIndex: number) {\n        const node = this.rowModel.getRow(rowIndex);\n        this.deselectNode(node);\n    }\n\n    /**\n     * @method\n     * @deprecated\n     */\n    public deselectNode(rowNode: RowNode | null) {\n        if (rowNode) {\n            rowNode.setSelectedParams({newValue: false, clearSelection: false});\n        }\n    }\n\n    /**\n     * @method\n     * @deprecated\n     */\n    public selectIndex(index: any, tryMulti: boolean) {\n        const node = this.rowModel.getRow(index);\n        this.selectNode(node, tryMulti);\n    }\n\n}"]}