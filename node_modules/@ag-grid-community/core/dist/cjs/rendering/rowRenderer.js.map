{"version":3,"sources":["../../src/ts/rendering/rowRenderer.ts"],"names":[],"mappings":"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","file":"rowRenderer.js","sourcesContent":["import { GridOptionsWrapper } from \"../gridOptionsWrapper\";\nimport { GridPanel, RowContainerComponents } from \"../gridPanel/gridPanel\";\nimport { EventService } from \"../eventService\";\nimport { RowComp } from \"./rowComp\";\nimport { Column } from \"../entities/column\";\nimport { RowNode } from \"../entities/rowNode\";\nimport { Events, FirstDataRenderedEvent, ModelUpdatedEvent, ViewportChangedEvent } from \"../events\";\nimport { Constants } from \"../constants\";\nimport { CellComp } from \"./cellComp\";\nimport { Autowired, Bean, Optional, Qualifier } from \"../context/context\";\nimport { GridCore } from \"../gridCore\";\nimport { ColumnApi } from \"../columnController/columnApi\";\nimport { ColumnController } from \"../columnController/columnController\";\nimport { Logger, LoggerFactory } from \"../logger\";\nimport { FocusedCellController } from \"../focusedCellController\";\nimport { IRangeController } from \"../interfaces/iRangeController\";\nimport { CellNavigationService } from \"../cellNavigationService\";\nimport { CellPosition } from \"../entities/cellPosition\";\nimport { NavigateToNextCellParams, TabToNextCellParams } from \"../entities/gridOptions\";\nimport { RowContainerComponent } from \"./rowContainerComponent\";\nimport { BeanStub } from \"../context/beanStub\";\nimport { PaginationProxy } from \"../pagination/paginationProxy\";\nimport { FlashCellsParams, GetCellRendererInstancesParams, GridApi, RefreshCellsParams } from \"../gridApi\";\nimport { Beans } from \"./beans\";\nimport { AnimationFrameService } from \"../misc/animationFrameService\";\nimport { MaxDivHeightScaler } from \"./maxDivHeightScaler\";\nimport { ICellRendererComp } from \"./cellRenderers/iCellRenderer\";\nimport { ICellEditorComp } from \"../interfaces/iCellEditor\";\nimport { IRowModel } from \"../interfaces/iRowModel\";\nimport { _ } from \"../utils\";\nimport { RowPosition, RowPositionUtils } from \"../entities/rowPosition\";\nimport {PinnedRowModel} from \"../pinnedRowModel/pinnedRowModel\";\n\n@Bean(\"rowRenderer\")\nexport class RowRenderer extends BeanStub {\n\n    @Autowired(\"paginationProxy\") private paginationProxy: PaginationProxy;\n    @Autowired(\"columnController\") private columnController: ColumnController;\n    @Autowired(\"gridOptionsWrapper\") private gridOptionsWrapper: GridOptionsWrapper;\n    @Autowired(\"$scope\") private $scope: any;\n    @Autowired(\"eventService\") private eventService: EventService;\n    @Autowired(\"pinnedRowModel\") private pinnedRowModel: PinnedRowModel;\n    @Autowired(\"rowModel\") private rowModel: IRowModel;\n    @Autowired(\"loggerFactory\") private loggerFactory: LoggerFactory;\n    @Autowired(\"focusedCellController\") private focusedCellController: FocusedCellController;\n    @Autowired(\"cellNavigationService\") private cellNavigationService: CellNavigationService;\n    @Autowired(\"columnApi\") private columnApi: ColumnApi;\n    @Autowired(\"gridApi\") private gridApi: GridApi;\n    @Autowired(\"beans\") private beans: Beans;\n    @Autowired(\"maxDivHeightScaler\") private maxDivHeightScaler: MaxDivHeightScaler;\n    @Autowired(\"animationFrameService\") private animationFrameService: AnimationFrameService;\n    @Autowired(\"rowPositionUtils\") private rowPositionUtils: RowPositionUtils;\n    @Optional(\"rangeController\") private rangeController: IRangeController;\n\n    private gridPanel: GridPanel;\n\n    private destroyFuncsForColumnListeners: (() => void)[] = [];\n\n    private firstRenderedRow: number;\n    private lastRenderedRow: number;\n\n    // map of row ids to row objects. keeps track of which elements\n    // are rendered for which rows in the dom.\n    private rowCompsByIndex: { [key: string]: RowComp } = {};\n    private floatingTopRowComps: RowComp[] = [];\n    private floatingBottomRowComps: RowComp[] = [];\n\n    private rowContainers: RowContainerComponents;\n\n    private pinningLeft: boolean;\n    private pinningRight: boolean;\n\n    // we only allow one refresh at a time, otherwise the internal memory structure here\n    // will get messed up. this can happen if the user has a cellRenderer, and inside the\n    // renderer they call an API method that results in another pass of the refresh,\n    // then it will be trying to draw rows in the middle of a refresh.\n    private refreshInProgress = false;\n\n    private logger: Logger;\n\n    private printLayout: boolean;\n    private embedFullWidthRows: boolean;\n\n    private gridCore: GridCore;\n\n    public registerGridCore(gridCore: GridCore): void {\n        this.gridCore = gridCore;\n    }\n\n    public getGridCore(): GridCore {\n        return this.gridCore;\n    }\n\n    public agWire(@Qualifier(\"loggerFactory\") loggerFactory: LoggerFactory) {\n        this.logger = loggerFactory.create(\"RowRenderer\");\n    }\n\n    public registerGridComp(gridPanel: GridPanel): void {\n        this.gridPanel = gridPanel;\n\n        this.rowContainers = this.gridPanel.getRowContainers();\n        this.addDestroyableEventListener(this.eventService, Events.EVENT_PAGINATION_CHANGED, this.onPageLoaded.bind(this));\n        this.addDestroyableEventListener(this.eventService, Events.EVENT_PINNED_ROW_DATA_CHANGED, this.onPinnedRowDataChanged.bind(this));\n        this.addDestroyableEventListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this));\n        this.addDestroyableEventListener(this.eventService, Events.EVENT_BODY_SCROLL, this.redrawAfterScroll.bind(this));\n        this.addDestroyableEventListener(this.eventService, Events.EVENT_BODY_HEIGHT_CHANGED, this.redrawAfterScroll.bind(this));\n        this.addDestroyableEventListener(this.gridOptionsWrapper, GridOptionsWrapper.PROP_DOM_LAYOUT, this.onDomLayoutChanged.bind(this));\n\n        this.registerCellEventListeners();\n\n        this.printLayout = this.gridOptionsWrapper.getDomLayout() === Constants.DOM_LAYOUT_PRINT;\n        this.embedFullWidthRows = this.printLayout || this.gridOptionsWrapper.isEmbedFullWidthRows();\n\n        this.redrawAfterModelUpdate();\n    }\n\n    // in a clean design, each cell would register for each of these events. however when scrolling, all the cells\n    // registering and de-registering for events is a performance bottleneck. so we register here once and inform\n    // all active cells.\n    private registerCellEventListeners(): void {\n\n        this.addDestroyableEventListener(this.eventService, Events.EVENT_CELL_FOCUSED, event => {\n            this.forEachCellComp(cellComp => cellComp.onCellFocused(event));\n        });\n\n        this.addDestroyableEventListener(this.eventService, Events.EVENT_FLASH_CELLS, event => {\n            this.forEachCellComp(cellComp => cellComp.onFlashCells(event));\n        });\n\n        this.addDestroyableEventListener(this.eventService, Events.EVENT_COLUMN_HOVER_CHANGED, () => {\n            this.forEachCellComp(cellComp => cellComp.onColumnHover());\n        });\n\n        // only for printLayout - because we are rendering all the cells in the same row, regardless of pinned state,\n        // then changing the width of the containers will impact left position. eg the center cols all have their\n        // left position adjusted by the width of the left pinned column, so if the pinned left column width changes,\n        // all the center cols need to be shifted to accommodate this. when in normal layout, the pinned cols are\n        // in different containers so doesn't impact.\n        this.addDestroyableEventListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, () => {\n            if (this.printLayout) {\n                this.forEachCellComp(cellComp => cellComp.onLeftChanged());\n            }\n        });\n\n        const rangeSelectionEnabled = this.gridOptionsWrapper.isEnableRangeSelection();\n        if (rangeSelectionEnabled) {\n\n            this.addDestroyableEventListener(this.eventService, Events.EVENT_RANGE_SELECTION_CHANGED, () => {\n                this.forEachCellComp(cellComp => cellComp.onRangeSelectionChanged());\n            });\n            this.addDestroyableEventListener(this.eventService, Events.EVENT_COLUMN_MOVED, () => {\n                this.forEachCellComp(cellComp => cellComp.updateRangeBordersIfRangeCount());\n            });\n            this.addDestroyableEventListener(this.eventService, Events.EVENT_COLUMN_PINNED, () => {\n                this.forEachCellComp(cellComp => cellComp.updateRangeBordersIfRangeCount());\n            });\n            this.addDestroyableEventListener(this.eventService, Events.EVENT_COLUMN_VISIBLE, () => {\n                this.forEachCellComp(cellComp => cellComp.updateRangeBordersIfRangeCount());\n            });\n\n        }\n\n        // add listeners to the grid columns\n        this.refreshListenersToColumnsForCellComps();\n        // if the grid columns change, then refresh the listeners again\n        this.addDestroyableEventListener(this.eventService, Events.EVENT_GRID_COLUMNS_CHANGED, this.refreshListenersToColumnsForCellComps.bind(this));\n\n        this.addDestroyFunc(this.removeGridColumnListeners.bind(this));\n    }\n\n    // executes all functions in destroyFuncsForColumnListeners and then clears the list\n    private removeGridColumnListeners(): void {\n        this.destroyFuncsForColumnListeners.forEach(func => func());\n        this.destroyFuncsForColumnListeners.length = 0;\n    }\n\n    // this function adds listeners onto all the grid columns, which are the column that we could have cellComps for.\n    // when the grid columns change, we add listeners again. in an ideal design, each CellComp would just register to\n    // the column it belongs to on creation, however this was a bottleneck with the number of cells, so do it here\n    // once instead.\n    private refreshListenersToColumnsForCellComps(): void {\n\n        this.removeGridColumnListeners();\n\n        const cols = this.columnController.getAllGridColumns();\n\n        if (!cols) { return; }\n\n        cols.forEach(col => {\n\n            const forEachCellWithThisCol = (callback: (cellComp: CellComp) => void) => {\n                this.forEachCellComp(cellComp => {\n                    if (cellComp.getColumn() === col) {\n                        callback(cellComp);\n                    }\n                });\n            };\n\n            const leftChangedListener = () => {\n                forEachCellWithThisCol(cellComp => cellComp.onLeftChanged());\n            };\n            const widthChangedListener = () => {\n                forEachCellWithThisCol(cellComp => cellComp.onWidthChanged());\n            };\n            const firstRightPinnedChangedListener = () => {\n                forEachCellWithThisCol(cellComp => cellComp.onFirstRightPinnedChanged());\n            };\n            const lastLeftPinnedChangedListener = () => {\n                forEachCellWithThisCol(cellComp => cellComp.onLastLeftPinnedChanged());\n            };\n\n            col.addEventListener(Column.EVENT_LEFT_CHANGED, leftChangedListener);\n            col.addEventListener(Column.EVENT_WIDTH_CHANGED, widthChangedListener);\n            col.addEventListener(Column.EVENT_FIRST_RIGHT_PINNED_CHANGED, firstRightPinnedChangedListener);\n            col.addEventListener(Column.EVENT_LAST_LEFT_PINNED_CHANGED, lastLeftPinnedChangedListener);\n\n            this.destroyFuncsForColumnListeners.push(() => {\n                col.removeEventListener(Column.EVENT_LEFT_CHANGED, leftChangedListener);\n                col.removeEventListener(Column.EVENT_WIDTH_CHANGED, widthChangedListener);\n                col.removeEventListener(Column.EVENT_FIRST_RIGHT_PINNED_CHANGED, firstRightPinnedChangedListener);\n                col.removeEventListener(Column.EVENT_LAST_LEFT_PINNED_CHANGED, lastLeftPinnedChangedListener);\n            });\n        });\n\n    }\n\n    private onDomLayoutChanged(): void {\n        const printLayout = this.gridOptionsWrapper.getDomLayout() === Constants.DOM_LAYOUT_PRINT;\n        const embedFullWidthRows = printLayout || this.gridOptionsWrapper.isEmbedFullWidthRows();\n\n        // if moving towards or away from print layout, means we need to destroy all rows, as rows are not laid\n        // out using absolute positioning when doing print layout\n        const destroyRows = embedFullWidthRows !== this.embedFullWidthRows || this.printLayout !== printLayout;\n\n        this.printLayout = printLayout;\n        this.embedFullWidthRows = embedFullWidthRows;\n\n        if (destroyRows) {\n            this.redrawAfterModelUpdate();\n        }\n    }\n\n    // for row models that have datasources, when we update the datasource, we need to force the rowRenderer\n    // to redraw all rows. otherwise the old rows from the old datasource will stay displayed.\n    public datasourceChanged(): void {\n        this.firstRenderedRow = 0;\n        this.lastRenderedRow = -1;\n        const rowIndexesToRemove = Object.keys(this.rowCompsByIndex);\n        this.removeRowComps(rowIndexesToRemove);\n    }\n\n    private onPageLoaded(refreshEvent?: ModelUpdatedEvent): void {\n        if (_.missing(refreshEvent)) {\n            refreshEvent = {\n                type: Events.EVENT_MODEL_UPDATED,\n                api: this.gridApi,\n                columnApi: this.columnApi,\n                animate: false,\n                keepRenderedRows: false,\n                newData: false,\n                newPage: false\n            };\n        }\n        this.onModelUpdated(refreshEvent);\n    }\n\n    public getAllCellsForColumn(column: Column): HTMLElement[] {\n        const eCells: HTMLElement[] = [];\n\n        _.iterateObject(this.rowCompsByIndex, callback);\n        _.iterateObject(this.floatingBottomRowComps, callback);\n        _.iterateObject(this.floatingTopRowComps, callback);\n\n        function callback(key: any, rowComp: RowComp) {\n            const eCell = rowComp.getCellForCol(column);\n            if (eCell) {\n                eCells.push(eCell);\n            }\n        }\n\n        return eCells;\n    }\n\n    public refreshFloatingRowComps(): void {\n        this.refreshFloatingRows(\n            this.floatingTopRowComps,\n            this.pinnedRowModel.getPinnedTopRowData(),\n            this.rowContainers.floatingTopPinnedLeft,\n            this.rowContainers.floatingTopPinnedRight,\n            this.rowContainers.floatingTop,\n            this.rowContainers.floatingTopFullWidth\n        );\n        this.refreshFloatingRows(\n            this.floatingBottomRowComps,\n            this.pinnedRowModel.getPinnedBottomRowData(),\n            this.rowContainers.floatingBottomPinnedLeft,\n            this.rowContainers.floatingBottomPinnedRight,\n            this.rowContainers.floatingBottom,\n            this.rowContainers.floatingBottomFullWith\n        );\n    }\n\n    private refreshFloatingRows(\n        rowComps: RowComp[],\n        rowNodes: RowNode[],\n        pinnedLeftContainerComp: RowContainerComponent,\n        pinnedRightContainerComp: RowContainerComponent,\n        bodyContainerComp: RowContainerComponent,\n        fullWidthContainerComp: RowContainerComponent\n    ): void {\n        rowComps.forEach((row: RowComp) => {\n            row.destroy();\n        });\n\n        rowComps.length = 0;\n\n        if (rowNodes) {\n            rowNodes.forEach((node: RowNode) => {\n                const rowComp = new RowComp(\n                    this.$scope,\n                    bodyContainerComp,\n                    pinnedLeftContainerComp,\n                    pinnedRightContainerComp,\n                    fullWidthContainerComp,\n                    node,\n                    this.beans,\n                    false,\n                    false,\n                    this.printLayout,\n                    this.embedFullWidthRows\n                );\n\n                rowComp.init();\n                rowComps.push(rowComp);\n            });\n        }\n\n        this.flushContainers(rowComps);\n    }\n\n    private onPinnedRowDataChanged(): void {\n        // recycling rows in order to ensure cell editing is not cancelled\n        const params: RefreshViewParams = {\n            recycleRows: true\n        };\n\n        this.redrawAfterModelUpdate(params);\n    }\n\n    private onModelUpdated(refreshEvent: ModelUpdatedEvent): void {\n        const params: RefreshViewParams = {\n            recycleRows: refreshEvent.keepRenderedRows,\n            animate: refreshEvent.animate,\n            newData: refreshEvent.newData,\n            newPage: refreshEvent.newPage,\n            // because this is a model updated event (not pinned rows), we\n            // can skip updating the pinned rows. this is needed so that if user\n            // is doing transaction updates, the pinned rows are not getting constantly\n            // trashed - or editing cells in pinned rows are not refreshed and put into read mode\n            onlyBody: true\n        };\n        this.redrawAfterModelUpdate(params);\n    }\n\n    // if the row nodes are not rendered, no index is returned\n    private getRenderedIndexesForRowNodes(rowNodes: RowNode[]): string[] {\n        const result: string[] = [];\n        if (_.missing(rowNodes)) {\n            return result;\n        }\n        _.iterateObject(this.rowCompsByIndex, (index: string, renderedRow: RowComp) => {\n            const rowNode = renderedRow.getRowNode();\n            if (rowNodes.indexOf(rowNode) >= 0) {\n                result.push(index);\n            }\n        });\n        return result;\n    }\n\n    public redrawRows(rowNodes: RowNode[]): void {\n        if (!rowNodes || rowNodes.length == 0) {\n            return;\n        }\n\n        // we only need to be worried about rendered rows, as this method is\n        // called to what's rendered. if the row isn't rendered, we don't care\n        const indexesToRemove = this.getRenderedIndexesForRowNodes(rowNodes);\n\n        // remove the rows\n        this.removeRowComps(indexesToRemove);\n\n        // add draw them again\n        this.redrawAfterModelUpdate({\n            recycleRows: true\n        });\n    }\n\n    private getCellToRestoreFocusToAfterRefresh(params: RefreshViewParams): CellPosition {\n        const focusedCell = params.suppressKeepFocus ? null : this.focusedCellController.getFocusCellToUseAfterRefresh();\n\n        if (_.missing(focusedCell)) {\n            return null;\n        }\n\n        // if the dom is not actually focused on a cell, then we don't try to refocus. the problem this\n        // solves is with editing - if the user is editing, eg focus is on a text field, and not on the\n        // cell itself, then the cell can be registered as having focus, however it's the text field that\n        // has the focus and not the cell div. therefore, when the refresh is finished, the grid will focus\n        // the cell, and not the textfield. that means if the user is in a text field, and the grid refreshes,\n        // the focus is lost from the text field. we do not want this.\n        const activeElement = document.activeElement;\n        const domData = this.gridOptionsWrapper.getDomData(activeElement, CellComp.DOM_DATA_KEY_CELL_COMP);\n        const elementIsNotACellDev = _.missing(domData);\n        if (elementIsNotACellDev) {\n            return null;\n        }\n\n        return focusedCell;\n    }\n\n    // gets called after changes to the model.\n    public redrawAfterModelUpdate(params: RefreshViewParams = {}): void {\n        this.getLockOnRefresh();\n\n        const focusedCell: CellPosition = this.getCellToRestoreFocusToAfterRefresh(params);\n\n        this.sizeContainerToPageHeight();\n\n        this.scrollToTopIfNewData(params);\n\n        // never recycle rows when print layout, we draw each row again from scratch. this is because print layout\n        // uses normal dom layout to put cells into dom - it doesn't allow reordering rows.\n        const recycleRows = !this.printLayout && params.recycleRows;\n        const animate = params.animate && this.gridOptionsWrapper.isAnimateRows();\n\n        const rowsToRecycle: { [key: string]: RowComp } = this.binRowComps(recycleRows);\n\n        this.redraw(rowsToRecycle, animate);\n\n        if (!params.onlyBody) {\n            this.refreshFloatingRowComps();\n        }\n\n        this.restoreFocusedCell(focusedCell);\n\n        this.releaseLockOnRefresh();\n    }\n\n    private scrollToTopIfNewData(params: RefreshViewParams): void {\n        const scrollToTop = params.newData || params.newPage;\n        const suppressScrollToTop = this.gridOptionsWrapper.isSuppressScrollOnNewData();\n        if (scrollToTop && !suppressScrollToTop) {\n            this.gridPanel.scrollToTop();\n        }\n    }\n\n    private sizeContainerToPageHeight(): void {\n        const containers: RowContainerComponent[] = [\n            this.rowContainers.body,\n            this.rowContainers.fullWidth,\n            this.rowContainers.pinnedLeft,\n            this.rowContainers.pinnedRight\n        ];\n\n        if (this.printLayout) {\n            containers.forEach(container => container.setHeight(null));\n            return;\n        }\n\n        let containerHeight = this.paginationProxy.getCurrentPageHeight();\n        // we need at least 1 pixel for the horizontal scroll to work. so if there are now rows,\n        // we still want the scroll to be present, otherwise there would be no way to scroll the header\n        // which might be needed us user wants to access columns\n        // on the RHS - and if that was where the filter was that cause no rows to be presented, there\n        // is no way to remove the filter.\n        if (containerHeight === 0) {\n            containerHeight = 1;\n        }\n\n        this.maxDivHeightScaler.setModelHeight(containerHeight);\n\n        const realHeight = this.maxDivHeightScaler.getUiContainerHeight();\n\n        containers.forEach(container => container.setHeight(realHeight));\n    }\n\n    private getLockOnRefresh(): void {\n        if (this.refreshInProgress) {\n            throw new Error(\n                \"ag-Grid: cannot get grid to draw rows when it is in the middle of drawing rows. \" +\n                    \"Your code probably called a grid API method while the grid was in the render stage. To overcome \" +\n                    \"this, put the API call into a timeout, eg instead of api.refreshView(), \" +\n                    \"call setTimeout(function(){api.refreshView(),0}). To see what part of your code \" +\n                    \"that caused the refresh check this stacktrace.\"\n            );\n        }\n\n        this.refreshInProgress = true;\n    }\n\n    private releaseLockOnRefresh(): void {\n        this.refreshInProgress = false;\n    }\n\n    // sets the focus to the provided cell, if the cell is provided. this way, the user can call refresh without\n    // worry about the focus been lost. this is important when the user is using keyboard navigation to do edits\n    // and the cellEditor is calling 'refresh' to get other cells to update (as other cells might depend on the\n    // edited cell).\n    private restoreFocusedCell(cellPosition: CellPosition): void {\n        if (cellPosition) {\n            this.focusedCellController.setFocusedCell(cellPosition.rowIndex, cellPosition.column, cellPosition.rowPinned, true);\n        }\n    }\n\n    public stopEditing(cancel: boolean = false) {\n        this.forEachRowComp((key: string, rowComp: RowComp) => {\n            rowComp.stopEditing(cancel);\n        });\n    }\n\n    public forEachCellComp(callback: (cellComp: CellComp) => void): void {\n        this.forEachRowComp((key: string, rowComp: RowComp) => rowComp.forEachCellComp(callback));\n    }\n\n    private forEachRowComp(callback: (key: string, rowComp: RowComp) => void): void {\n        _.iterateObject(this.rowCompsByIndex, callback);\n        _.iterateObject(this.floatingTopRowComps, callback);\n        _.iterateObject(this.floatingBottomRowComps, callback);\n    }\n\n    public addRenderedRowListener(eventName: string, rowIndex: number, callback: Function): void {\n        const rowComp = this.rowCompsByIndex[rowIndex];\n        if (rowComp) {\n            rowComp.addEventListener(eventName, callback);\n        }\n    }\n\n    public flashCells(params: FlashCellsParams = {}): void {\n        this.forEachCellCompFiltered(params.rowNodes, params.columns, cellComp => cellComp.flashCell());\n    }\n\n    public refreshCells(params: RefreshCellsParams = {}): void {\n        const refreshCellParams = {\n            forceRefresh: params.force,\n            newData: false\n        };\n        this.forEachCellCompFiltered(params.rowNodes, params.columns, cellComp => cellComp.refreshCell(refreshCellParams));\n    }\n\n    public getCellRendererInstances(params: GetCellRendererInstancesParams): ICellRendererComp[] {\n\n        const res: ICellRendererComp[] = [];\n\n        this.forEachCellCompFiltered(params.rowNodes, params.columns, cellComp => {\n            const cellRenderer = cellComp.getCellRenderer();\n            if (cellRenderer) {\n                res.push(cellRenderer);\n            }\n        });\n\n        return res;\n    }\n\n    public getCellEditorInstances(params: GetCellRendererInstancesParams): ICellEditorComp[] {\n\n        const res: ICellEditorComp[] = [];\n\n        this.forEachCellCompFiltered(params.rowNodes, params.columns, cellComp => {\n            const cellEditor = cellComp.getCellEditor();\n            if (cellEditor) {\n                res.push(cellEditor);\n            }\n        });\n\n        return res;\n    }\n\n    public getEditingCells(): CellPosition[] {\n        const res: CellPosition[] = [];\n        this.forEachCellComp(cellComp => {\n            if (cellComp.isEditing()) {\n                const cellPosition = cellComp.getCellPosition();\n                res.push(cellPosition);\n            }\n        });\n        return res;\n    }\n\n    // calls the callback for each cellComp that match the provided rowNodes and columns. eg if one row node\n    // and two columns provided, that identifies 4 cells, so callback gets called 4 times, once for each cell.\n    private forEachCellCompFiltered(rowNodes: RowNode[], columns: (string | Column)[], callback: (cellComp: CellComp) => void): void {\n        let rowIdsMap: any;\n        if (_.exists(rowNodes)) {\n            rowIdsMap = {\n                top: {},\n                bottom: {},\n                normal: {}\n            };\n            rowNodes.forEach(rowNode => {\n                if (rowNode.rowPinned === Constants.PINNED_TOP) {\n                    rowIdsMap.top[rowNode.id] = true;\n                } else if (rowNode.rowPinned === Constants.PINNED_BOTTOM) {\n                    rowIdsMap.bottom[rowNode.id] = true;\n                } else {\n                    rowIdsMap.normal[rowNode.id] = true;\n                }\n            });\n        }\n\n        let colIdsMap: any;\n        if (_.exists(columns)) {\n            colIdsMap = {};\n            columns.forEach((colKey: string | Column) => {\n                const column: Column = this.columnController.getGridColumn(colKey);\n                if (_.exists(column)) {\n                    colIdsMap[column.getId()] = true;\n                }\n            });\n        }\n\n        const processRow = (rowComp: RowComp) => {\n            const rowNode: RowNode = rowComp.getRowNode();\n\n            const id = rowNode.id;\n            const floating = rowNode.rowPinned;\n\n            // skip this row if it is missing from the provided list\n            if (_.exists(rowIdsMap)) {\n                if (floating === Constants.PINNED_BOTTOM) {\n                    if (!rowIdsMap.bottom[id]) {\n                        return;\n                    }\n                } else if (floating === Constants.PINNED_TOP) {\n                    if (!rowIdsMap.top[id]) {\n                        return;\n                    }\n                } else {\n                    if (!rowIdsMap.normal[id]) {\n                        return;\n                    }\n                }\n            }\n\n            rowComp.forEachCellComp(cellComp => {\n                const colId: string = cellComp.getColumn().getId();\n                const excludeColFromRefresh = colIdsMap && !colIdsMap[colId];\n                if (excludeColFromRefresh) {\n                    return;\n                }\n\n                callback(cellComp);\n            });\n        };\n\n        _.iterateObject(this.rowCompsByIndex, (index: string, rowComp: RowComp) => {\n            processRow(rowComp);\n        });\n\n        if (this.floatingTopRowComps) {\n            this.floatingTopRowComps.forEach(processRow);\n        }\n\n        if (this.floatingBottomRowComps) {\n            this.floatingBottomRowComps.forEach(processRow);\n        }\n    }\n\n    public destroy() {\n        super.destroy();\n\n        const rowIndexesToRemove = Object.keys(this.rowCompsByIndex);\n        this.removeRowComps(rowIndexesToRemove);\n    }\n\n    private binRowComps(recycleRows: boolean): { [key: string]: RowComp } {\n        let indexesToRemove: string[];\n        const rowsToRecycle: { [key: string]: RowComp } = {};\n\n        if (recycleRows) {\n            indexesToRemove = [];\n            _.iterateObject(this.rowCompsByIndex, (index: string, rowComp: RowComp) => {\n                const rowNode = rowComp.getRowNode();\n                if (_.exists(rowNode.id)) {\n                    rowsToRecycle[rowNode.id] = rowComp;\n                    delete this.rowCompsByIndex[index];\n                } else {\n                    indexesToRemove.push(index);\n                }\n            });\n        } else {\n            indexesToRemove = Object.keys(this.rowCompsByIndex);\n        }\n\n        this.removeRowComps(indexesToRemove);\n\n        return rowsToRecycle;\n    }\n\n    // takes array of row indexes\n    private removeRowComps(rowsToRemove: any[]) {\n        // if no fromIndex then set to -1, which will refresh everything\n        // let realFromIndex = -1;\n        rowsToRemove.forEach(indexToRemove => {\n            const renderedRow = this.rowCompsByIndex[indexToRemove];\n            renderedRow.destroy();\n            delete this.rowCompsByIndex[indexToRemove];\n        });\n    }\n\n    // gets called when rows don't change, but viewport does, so after:\n    // 1) height of grid body changes, ie number of displayed rows has changed\n    // 2) grid scrolled to new position\n    // 3) ensure index visible (which is a scroll)\n    public redrawAfterScroll() {\n        this.getLockOnRefresh();\n        this.redraw(null, false, true);\n        this.releaseLockOnRefresh();\n    }\n\n    private removeRowCompsNotToDraw(indexesToDraw: number[]): void {\n        // for speedy lookup, dump into map\n        const indexesToDrawMap: { [index: string]: boolean } = {};\n        indexesToDraw.forEach(index => (indexesToDrawMap[index] = true));\n\n        const existingIndexes = Object.keys(this.rowCompsByIndex);\n        const indexesNotToDraw: string[] = existingIndexes.filter(index => !indexesToDrawMap[index]);\n\n        this.removeRowComps(indexesNotToDraw);\n    }\n\n    private calculateIndexesToDraw(): number[] {\n        // all in all indexes in the viewport\n        const indexesToDraw = _.createArrayOfNumbers(this.firstRenderedRow, this.lastRenderedRow);\n\n        // add in indexes of rows we want to keep, because they are currently editing\n        _.iterateObject(this.rowCompsByIndex, (indexStr: string, rowComp: RowComp) => {\n            const index = Number(indexStr);\n            if (index < this.firstRenderedRow || index > this.lastRenderedRow) {\n                if (this.doNotUnVirtualiseRow(rowComp)) {\n                    indexesToDraw.push(index);\n                }\n            }\n        });\n\n        indexesToDraw.sort((a: number, b: number) => a - b);\n\n        return indexesToDraw;\n    }\n\n    private redraw(rowsToRecycle?: { [key: string]: RowComp }, animate = false, afterScroll = false) {\n        this.maxDivHeightScaler.updateOffset();\n        this.workOutFirstAndLastRowsToRender();\n\n        // the row can already exist and be in the following:\n        // rowsToRecycle -> if model change, then the index may be different, however row may\n        //                         exist here from previous time (mapped by id).\n        // this.rowCompsByIndex -> if just a scroll, then this will contain what is currently in the viewport\n\n        // this is all the indexes we want, including those that already exist, so this method\n        // will end up going through each index and drawing only if the row doesn't already exist\n        const indexesToDraw = this.calculateIndexesToDraw();\n\n        this.removeRowCompsNotToDraw(indexesToDraw);\n\n        // never animate when doing print layout - as we want to get things ready to print as quickly as possible,\n        // otherwise we risk the printer printing a row that's half faded (half way through fading in)\n        if (this.printLayout) {\n            animate = false;\n        }\n\n        // add in new rows\n        const nextVmTurnFunctions: Function[] = [];\n\n        const rowComps: RowComp[] = [];\n        indexesToDraw.forEach(rowIndex => {\n            const rowComp = this.createOrUpdateRowComp(rowIndex, rowsToRecycle, animate, afterScroll);\n            if (_.exists(rowComp)) {\n                rowComps.push(rowComp);\n                _.pushAll(nextVmTurnFunctions, rowComp.getAndClearNextVMTurnFunctions());\n            }\n        });\n\n        this.flushContainers(rowComps);\n\n        _.executeNextVMTurn(nextVmTurnFunctions);\n\n        const useAnimationFrame = afterScroll && !this.gridOptionsWrapper.isSuppressAnimationFrame() && !this.printLayout;\n        if (useAnimationFrame) {\n            this.beans.taskQueue.addDestroyTask(this.destroyRowComps.bind(this, rowsToRecycle, animate));\n        } else {\n            this.destroyRowComps(rowsToRecycle, animate);\n        }\n\n        this.checkAngularCompile();\n        this.gridPanel.updateRowCount();\n    }\n\n    private flushContainers(rowComps: RowComp[]): void {\n        _.iterateObject(this.rowContainers, (key: string, rowContainerComp: RowContainerComponent) => {\n            if (rowContainerComp) {\n                rowContainerComp.flushRowTemplates();\n            }\n        });\n\n        rowComps.forEach(rowComp => rowComp.afterFlush());\n    }\n\n    private onDisplayedColumnsChanged(): void {\n        const pinningLeft = this.columnController.isPinningLeft();\n        const pinningRight = this.columnController.isPinningRight();\n        const atLeastOneChanged = this.pinningLeft !== pinningLeft || pinningRight !== this.pinningRight;\n        if (atLeastOneChanged) {\n            this.pinningLeft = pinningLeft;\n            this.pinningRight = pinningRight;\n            if (this.embedFullWidthRows) {\n                this.redrawFullWidthEmbeddedRows();\n            }\n        }\n    }\n\n    // when embedding, what gets showed in each section depends on what is pinned. eg if embedding group expand / collapse,\n    // then it should go into the pinned left area if pinning left, or the center area if not pinning.\n    private redrawFullWidthEmbeddedRows(): void {\n        // if either of the pinned panels has shown / hidden, then need to redraw the fullWidth bits when\n        // embedded, as what appears in each section depends on whether we are pinned or not\n        const rowsToRemove: string[] = [];\n\n        _.iterateObject(this.rowCompsByIndex, (id: string, rowComp: RowComp) => {\n            if (rowComp.isFullWidth()) {\n                const rowIndex = rowComp.getRowNode().rowIndex;\n                rowsToRemove.push(rowIndex.toString());\n            }\n        });\n\n        this.refreshFloatingRowComps();\n        this.removeRowComps(rowsToRemove);\n        this.redrawAfterScroll();\n    }\n\n    public refreshFullWidthRows(): void {\n        const rowsToRemove: string[] = [];\n        _.iterateObject(this.rowCompsByIndex, (id: string, rowComp: RowComp) => {\n            if (rowComp.isFullWidth()) {\n                const fullWidthRowsRefreshed = rowComp.refreshFullWidth();\n                if (!fullWidthRowsRefreshed) {\n                    const rowIndex = rowComp.getRowNode().rowIndex;\n                    rowsToRemove.push(rowIndex.toString());\n                }\n            }\n        });\n        this.removeRowComps(rowsToRemove);\n        this.redrawAfterScroll();\n    }\n\n    private createOrUpdateRowComp(rowIndex: number, rowsToRecycle: { [key: string]: RowComp }, animate: boolean, afterScroll: boolean): RowComp {\n        let rowNode: RowNode;\n\n        let rowComp: RowComp = this.rowCompsByIndex[rowIndex];\n\n        // if no row comp, see if we can get it from the previous rowComps\n        if (!rowComp) {\n            rowNode = this.paginationProxy.getRow(rowIndex);\n            if (_.exists(rowNode) && _.exists(rowsToRecycle) && rowsToRecycle[rowNode.id] && rowNode.alreadyRendered) {\n                rowComp = rowsToRecycle[rowNode.id];\n                rowsToRecycle[rowNode.id] = null;\n            }\n        }\n\n        const creatingNewRowComp = !rowComp;\n\n        if (creatingNewRowComp) {\n            // create a new one\n            if (!rowNode) {\n                rowNode = this.paginationProxy.getRow(rowIndex);\n            }\n            if (_.exists(rowNode)) {\n                rowComp = this.createRowComp(rowNode, animate, afterScroll);\n            } else {\n                // this should never happen - if somehow we are trying to create\n                // a row for a rowNode that does not exist.\n                return;\n            }\n        } else {\n            // ensure row comp is in right position in DOM\n            rowComp.ensureDomOrder();\n        }\n\n        if (rowNode) {\n            // set node as 'alreadyRendered' to ensure we only recycle rowComps that have been rendered, this ensures\n            // we don't reuse rowComps that have been removed and then re-added in the same batch transaction.\n            rowNode.alreadyRendered = true;\n        }\n\n        this.rowCompsByIndex[rowIndex] = rowComp;\n\n        return rowComp;\n    }\n\n    private destroyRowComps(rowCompsMap: { [key: string]: RowComp }, animate: boolean): void {\n        const delayedFuncs: Function[] = [];\n        _.iterateObject(rowCompsMap, (nodeId: string, rowComp: RowComp) => {\n            // if row was used, then it's null\n            if (!rowComp) {\n                return;\n            }\n            rowComp.destroy(animate);\n            _.pushAll(delayedFuncs, rowComp.getAndClearDelayedDestroyFunctions());\n        });\n        _.executeInAWhile(delayedFuncs);\n    }\n\n    private checkAngularCompile(): void {\n        // if we are doing angular compiling, then do digest the scope here\n        if (this.gridOptionsWrapper.isAngularCompileRows()) {\n            // we do it in a timeout, in case we are already in an apply\n            window.setTimeout(() => {\n                this.$scope.$apply();\n            }, 0);\n        }\n    }\n\n    private workOutFirstAndLastRowsToRender(): void {\n\n        let newFirst: number;\n        let newLast: number;\n\n        if (!this.paginationProxy.isRowsToRender()) {\n            newFirst = 0;\n            newLast = -1; // setting to -1 means nothing in range\n        } else if (this.printLayout) {\n            newFirst = this.paginationProxy.getPageFirstRow();\n            newLast = this.paginationProxy.getPageLastRow();\n        } else {\n\n            const paginationOffset = this.paginationProxy.getPixelOffset();\n            const maxDivHeightScaler = this.maxDivHeightScaler.getOffset();\n\n            const bodyVRange = this.gridPanel.getVScrollPosition();\n            const bodyTopPixel = bodyVRange.top;\n            const bodyBottomPixel = bodyVRange.bottom;\n\n            const bufferPixels = this.gridOptionsWrapper.getRowBufferInPixels();\n\n            const firstPixel = bodyTopPixel + paginationOffset + maxDivHeightScaler - bufferPixels;\n            const lastPixel = bodyBottomPixel + paginationOffset + maxDivHeightScaler + bufferPixels;\n\n            this.ensureAllRowsInRangeHaveHeightsCalculated(firstPixel, lastPixel);\n\n            let firstRowIndex = this.paginationProxy.getRowIndexAtPixel(firstPixel);\n            let lastRowIndex = this.paginationProxy.getRowIndexAtPixel(lastPixel);\n\n            const pageFirstRow = this.paginationProxy.getPageFirstRow();\n            const pageLastRow = this.paginationProxy.getPageLastRow();\n\n            // adjust, in case buffer extended actual size\n            if (firstRowIndex < pageFirstRow) {\n                firstRowIndex = pageFirstRow;\n            }\n\n            if (lastRowIndex > pageLastRow) {\n                lastRowIndex = pageLastRow;\n            }\n\n            newFirst = firstRowIndex;\n            newLast = lastRowIndex;\n        }\n\n        // sometimes user doesn't set CSS right and ends up with grid with no height and grid ends up\n        // trying to render all the rows, eg 10,000+ rows. this will kill the browser. so instead of\n        // killing the browser, we limit the number of rows. just in case some use case we didn't think\n        // of, we also have a property to not do this operation.\n        const rowLayoutNormal = this.gridOptionsWrapper.getDomLayout() === Constants.DOM_LAYOUT_NORMAL;\n        const suppressRowCountRestriction = this.gridOptionsWrapper.isSuppressMaxRenderedRowRestriction();\n        const rowBufferMaxSize = Math.max(this.gridOptionsWrapper.getRowBuffer(), 500);\n\n        if (rowLayoutNormal && !suppressRowCountRestriction) {\n            if (newLast - newFirst > rowBufferMaxSize) {\n                newLast = newFirst + rowBufferMaxSize;\n            }\n        }\n\n        const firstDiffers = newFirst !== this.firstRenderedRow;\n        const lastDiffers = newLast !== this.lastRenderedRow;\n        if (firstDiffers || lastDiffers) {\n            this.firstRenderedRow = newFirst;\n            this.lastRenderedRow = newLast;\n\n            const event: ViewportChangedEvent = {\n                type: Events.EVENT_VIEWPORT_CHANGED,\n                firstRow: newFirst,\n                lastRow: newLast,\n                api: this.gridApi,\n                columnApi: this.columnApi\n            };\n\n            this.eventService.dispatchEvent(event);\n        }\n\n        // only dispatch firstDataRendered if we have actually rendered some data\n        if (this.paginationProxy.isRowsToRender()) {\n\n            const event: FirstDataRenderedEvent = {\n                type: Events.EVENT_FIRST_DATA_RENDERED,\n                firstRow: newFirst,\n                lastRow: newLast,\n                api: this.gridApi,\n                columnApi: this.columnApi\n            };\n\n            // added a small delay here because in some scenarios this can be fired\n            // before the grid is actually rendered, causing component creation\n            // on EVENT_FIRST_DATA_RENDERED to fail.\n            window.setTimeout(() => this.eventService.dispatchEventOnce(event), 50);\n        }\n    }\n\n    private ensureAllRowsInRangeHaveHeightsCalculated(topPixel: number, bottomPixel: number): void {\n        // ensureRowHeightsVisible only works with CSRM, as it's the only row model that allows lazy row height calcs.\n        // all the other row models just hard code so the method just returns back false\n        const rowHeightsChanged = this.paginationProxy.ensureRowHeightsValid(topPixel, bottomPixel, -1, -1);\n        if (rowHeightsChanged) {\n            // if row heights have changed, we need to resize the containers the rows sit it\n            this.sizeContainerToPageHeight();\n            // we also need to update heightScaler as this has dependency of row container height\n            this.maxDivHeightScaler.updateOffset();\n        }\n    }\n\n    public getFirstVirtualRenderedRow() {\n        return this.firstRenderedRow;\n    }\n\n    public getLastVirtualRenderedRow() {\n        return this.lastRenderedRow;\n    }\n\n    // check that none of the rows to remove are editing or focused as:\n    // a) if editing, we want to keep them, otherwise the user will loose the context of the edit,\n    //    eg user starts editing, enters some text, then scrolls down and then up, next time row rendered\n    //    the edit is reset - so we want to keep it rendered.\n    // b) if focused, we want ot keep keyboard focus, so if user ctrl+c, it goes to clipboard,\n    //    otherwise the user can range select and drag (with focus cell going out of the viewport)\n    //    and then ctrl+c, nothing will happen if cell is removed from dom.\n    // c) if detail record of master detail, as users complained that the context of detail rows\n    //    was getting lost when detail row out of view. eg user expands to show detail row,\n    //    then manipulates the detail panel (eg sorts the detail grid), then context is lost\n    //    after detail panel is scrolled out of / into view.\n    private doNotUnVirtualiseRow(rowComp: RowComp): boolean {\n        const REMOVE_ROW: boolean = false;\n        const KEEP_ROW: boolean = true;\n        const rowNode = rowComp.getRowNode();\n\n        const rowHasFocus = this.focusedCellController.isRowNodeFocused(rowNode);\n        const rowIsEditing = rowComp.isEditing();\n        const rowIsDetail = rowNode.detail;\n\n        const mightWantToKeepRow = rowHasFocus || rowIsEditing || rowIsDetail;\n\n        // if we deffo don't want to keep it,\n        if (!mightWantToKeepRow) {\n            return REMOVE_ROW;\n        }\n\n        // editing row, only remove if it is no longer rendered, eg filtered out or new data set.\n        // the reason we want to keep is if user is scrolling up and down, we don't want to loose\n        // the context of the editing in process.\n        const rowNodePresent = this.paginationProxy.isRowPresent(rowNode);\n        return rowNodePresent ? KEEP_ROW : REMOVE_ROW;\n    }\n\n    private createRowComp(rowNode: RowNode, animate: boolean, afterScroll: boolean): RowComp {\n\n        const suppressAnimationFrame = this.gridOptionsWrapper.isSuppressAnimationFrame();\n\n        // we don't use animations frames for printing, so the user can put the grid into print mode\n        // and immediately print - otherwise the user would have to wait for the rows to draw in the background\n        // (via the animation frames) which is awkward to do from code.\n\n        // we only do the animation frames after scrolling, as this is where we want the smooth user experience.\n        // having animation frames for other times makes the grid look 'jumpy'.\n\n        const useAnimationFrameForCreate = afterScroll && !suppressAnimationFrame && !this.printLayout;\n\n        const rowComp = new RowComp(\n            this.$scope,\n            this.rowContainers.body,\n            this.rowContainers.pinnedLeft,\n            this.rowContainers.pinnedRight,\n            this.rowContainers.fullWidth,\n            rowNode,\n            this.beans,\n            animate,\n            useAnimationFrameForCreate,\n            this.printLayout,\n            this.embedFullWidthRows\n        );\n\n        rowComp.init();\n\n        return rowComp;\n    }\n\n    public getRenderedNodes() {\n        const renderedRows = this.rowCompsByIndex;\n        return Object.keys(renderedRows).map(key => {\n            return renderedRows[key].getRowNode();\n        });\n    }\n\n    // we use index for rows, but column object for columns, as the next column (by index) might not\n    // be visible (header grouping) so it's not reliable, so using the column object instead.\n    public navigateToNextCell(event: KeyboardEvent | null, key: number, currentCell: CellPosition, allowUserOverride: boolean) {\n        // we keep searching for a next cell until we find one. this is how the group rows get skipped\n        let nextCell = currentCell;\n        let finished = false;\n        while (!finished) {\n            // if the current cell is spanning across multiple columns, we need to move\n            // our current position to be the last cell on the right before finding the\n            // the next target.\n            if (this.gridOptionsWrapper.isEnableRtl()) {\n                if (key === Constants.KEY_LEFT) {\n                    nextCell = this.getLastCellOfColSpan(nextCell);\n                }\n            } else if (key === Constants.KEY_RIGHT) {\n                nextCell = this.getLastCellOfColSpan(nextCell);\n            }\n\n            nextCell = this.cellNavigationService.getNextCellToFocus(key, nextCell);\n\n            // eg if going down, and nextCell=undefined, means we are gone past the last row\n            const hitEdgeOfGrid = _.missing(nextCell);\n            if (hitEdgeOfGrid) {\n                finished = true;\n                continue;\n            }\n\n            const rowNode = this.rowPositionUtils.getRowNode(nextCell);\n\n            // we do not allow focusing on detail rows and full width rows\n            if (rowNode.detail || rowNode.isFullWidthCell()) {\n                continue;\n            }\n\n            // if not a group, then we have a valid row, so quit the search\n            if (!rowNode.group) {\n                finished = true;\n                continue;\n            }\n\n            // full width rows cannot be focused, so if it's a group and using full width rows,\n            // we need to skip over the row\n            const pivotMode = this.columnController.isPivotMode();\n            const usingFullWidthRows = this.gridOptionsWrapper.isGroupUseEntireRow(pivotMode);\n            if (!usingFullWidthRows) {\n                finished = true;\n            }\n        }\n\n        // allow user to override what cell to go to next. when doing normal cell navigation (with keys)\n        // we allow this, however if processing 'enter after edit' we don't allow override\n        if (allowUserOverride) {\n            const userFunc = this.gridOptionsWrapper.getNavigateToNextCellFunc();\n            if (_.exists(userFunc)) {\n                const params: NavigateToNextCellParams = {\n                    key: key,\n                    previousCellPosition: currentCell,\n                    nextCellPosition: nextCell ? nextCell : null,\n                    event: event\n                };\n                const userCell = userFunc(params);\n                if (_.exists(userCell)) {\n                    if ((userCell as any).floating) {\n                        _.doOnce(() => {console.warn(`ag-Grid: tabToNextCellFunc return type should have attributes: rowIndex, rowPinned, column. However you had 'floating', maybe you meant 'rowPinned'?`); }, 'no floating in userCell');\n                        userCell.rowPinned = (userCell as any).floating;\n                    }\n                    nextCell = {\n                        rowPinned: userCell.rowPinned,\n                        rowIndex: userCell.rowIndex,\n                        column: userCell.column\n                    } as CellPosition;\n                } else {\n                    nextCell = null;\n                }\n            }\n        }\n\n        // no next cell means we have reached a grid boundary, eg left, right, top or bottom of grid\n        if (!nextCell) {\n            return;\n        }\n\n        // in case we have col spanning we get the cellComp and use it to\n        // get the position. This was we always focus the first cell inside\n        // the spanning.\n        this.ensureCellVisible(nextCell); // ensureCellVisible first, to make sure nextCell is rendered\n        const cellComp = this.getComponentForCell(nextCell);\n        nextCell = cellComp.getCellPosition();\n\n        // we call this again, as nextCell can be different to it's previous value due to Column Spanning\n        // (ie if cursor moving from right to left, and cell is spanning columns, then nextCell was the\n        // last column in the group, however now it's the first column in the group). if we didn't do\n        // ensureCellVisible again, then we could only be showing the last portion (last column) of the\n        // merged cells.\n        this.ensureCellVisible(nextCell);\n\n        this.focusedCellController.setFocusedCell(nextCell.rowIndex, nextCell.column, nextCell.rowPinned, true);\n\n        if (this.rangeController) {\n            this.rangeController.setRangeToCell(nextCell);\n        }\n    }\n\n    private getLastCellOfColSpan(cell: CellPosition): CellPosition {\n        const cellComp = this.getComponentForCell(cell);\n\n        if (!cellComp) {\n            return cell;\n        }\n\n        const colSpanningList = cellComp.getColSpanningList();\n\n        if (colSpanningList.length === 1) {\n            return cell;\n        }\n\n        return {\n            rowIndex: cell.rowIndex,\n            column: _.last(colSpanningList),\n            rowPinned: cell.rowPinned\n        };\n    }\n\n    public ensureCellVisible(gridCell: CellPosition): void {\n        // this scrolls the row into view\n        if (_.missing(gridCell.rowPinned)) {\n            this.gridPanel.ensureIndexVisible(gridCell.rowIndex);\n        }\n\n        if (!gridCell.column.isPinned()) {\n            this.gridPanel.ensureColumnVisible(gridCell.column);\n        }\n\n        // need to nudge the scrolls for the floating items. otherwise when we set focus on a non-visible\n        // floating cell, the scrolls get out of sync\n        this.gridPanel.horizontallyScrollHeaderCenterAndFloatingCenter();\n\n        // need to flush frames, to make sure the correct cells are rendered\n        this.animationFrameService.flushAllFrames();\n    }\n\n    public startEditingCell(gridCell: CellPosition, keyPress: number, charPress: string): void {\n        const cell = this.getComponentForCell(gridCell);\n        if (cell) {\n            cell.startRowOrCellEdit(keyPress, charPress);\n        }\n    }\n\n    public getComponentForCell(cellPosition: CellPosition): CellComp {\n        let rowComponent: RowComp;\n        switch (cellPosition.rowPinned) {\n            case Constants.PINNED_TOP:\n                rowComponent = this.floatingTopRowComps[cellPosition.rowIndex];\n                break;\n            case Constants.PINNED_BOTTOM:\n                rowComponent = this.floatingBottomRowComps[cellPosition.rowIndex];\n                break;\n            default:\n                rowComponent = this.rowCompsByIndex[cellPosition.rowIndex];\n                break;\n        }\n\n        if (!rowComponent) {\n            return null;\n        }\n\n        const cellComponent: CellComp = rowComponent.getRenderedCellForColumn(cellPosition.column);\n        return cellComponent;\n    }\n\n    public getRowNode(gridRow: RowPosition): RowNode | null {\n        switch (gridRow.rowPinned) {\n            case Constants.PINNED_TOP:\n                return this.pinnedRowModel.getPinnedTopRowData()[gridRow.rowIndex];\n            case Constants.PINNED_BOTTOM:\n                return this.pinnedRowModel.getPinnedBottomRowData()[gridRow.rowIndex];\n            default:\n                return this.rowModel.getRow(gridRow.rowIndex);\n        }\n    }\n\n    public onTabKeyDown(previousRenderedCell: CellComp, keyboardEvent: KeyboardEvent): void {\n        const backwards = keyboardEvent.shiftKey;\n        const success = this.moveToCellAfter(previousRenderedCell, backwards);\n        if (success) {\n            keyboardEvent.preventDefault();\n        }\n    }\n\n    public tabToNextCell(backwards: boolean): boolean {\n        const focusedCell = this.focusedCellController.getFocusedCell();\n        // if no focus, then cannot navigate\n        if (_.missing(focusedCell)) {\n            return false;\n        }\n        const renderedCell = this.getComponentForCell(focusedCell);\n        // if cell is not rendered, means user has scrolled away from the cell\n        if (_.missing(renderedCell)) {\n            return false;\n        }\n\n        const result = this.moveToCellAfter(renderedCell, backwards);\n        return result;\n    }\n\n    private moveToCellAfter(previousRenderedCell: CellComp, backwards: boolean): boolean {\n        const editing = previousRenderedCell.isEditing();\n        let res: boolean;\n        if (editing) {\n            if (this.gridOptionsWrapper.isFullRowEdit()) {\n                res = this.moveToNextEditingRow(previousRenderedCell, backwards);\n            } else {\n                res = this.moveToNextEditingCell(previousRenderedCell, backwards);\n            }\n        } else {\n            res = this.moveToNextCellNotEditing(previousRenderedCell, backwards);\n        }\n        return res;\n    }\n\n    private moveToNextEditingCell(previousRenderedCell: CellComp, backwards: boolean): boolean {\n        const gridCell = previousRenderedCell.getCellPosition();\n\n        // need to do this before getting next cell to edit, in case the next cell\n        // has editable function (eg colDef.editable=func() ) and it depends on the\n        // result of this cell, so need to save updates from the first edit, in case\n        // the value is referenced in the function.\n        previousRenderedCell.stopEditing();\n\n        // find the next cell to start editing\n        const nextRenderedCell = this.findNextCellToFocusOn(gridCell, backwards, true);\n\n        const foundCell = _.exists(nextRenderedCell);\n\n        // only prevent default if we found a cell. so if user is on last cell and hits tab, then we default\n        // to the normal tabbing so user can exit the grid.\n        if (foundCell) {\n            nextRenderedCell.startEditingIfEnabled(null, null, true);\n            nextRenderedCell.focusCell(false);\n        }\n\n        return foundCell;\n    }\n\n    private moveToNextEditingRow(previousRenderedCell: CellComp, backwards: boolean): boolean {\n        const gridCell = previousRenderedCell.getCellPosition();\n\n        // find the next cell to start editing\n        const nextRenderedCell = this.findNextCellToFocusOn(gridCell, backwards, true);\n\n        const foundCell = _.exists(nextRenderedCell);\n\n        // only prevent default if we found a cell. so if user is on last cell and hits tab, then we default\n        // to the normal tabbing so user can exit the grid.\n        if (foundCell) {\n            this.moveEditToNextCellOrRow(previousRenderedCell, nextRenderedCell);\n        }\n\n        return foundCell;\n    }\n\n    private moveToNextCellNotEditing(previousRenderedCell: CellComp, backwards: boolean): boolean {\n        const gridCell = previousRenderedCell.getCellPosition();\n\n        // find the next cell to start editing\n        const nextRenderedCell = this.findNextCellToFocusOn(gridCell, backwards, false);\n\n        const foundCell = _.exists(nextRenderedCell);\n\n        // only prevent default if we found a cell. so if user is on last cell and hits tab, then we default\n        // to the normal tabbing so user can exit the grid.\n        if (foundCell) {\n            nextRenderedCell.focusCell(true);\n        }\n\n        return foundCell;\n    }\n\n    private moveEditToNextCellOrRow(previousRenderedCell: CellComp, nextRenderedCell: CellComp): void {\n        const pGridCell = previousRenderedCell.getCellPosition();\n        const nGridCell = nextRenderedCell.getCellPosition();\n\n        const rowsMatch = pGridCell.rowIndex === nGridCell.rowIndex && pGridCell.rowPinned === nGridCell.rowPinned;\n\n        if (rowsMatch) {\n            // same row, so we don't start / stop editing, we just move the focus along\n            previousRenderedCell.setFocusOutOnEditor();\n            nextRenderedCell.setFocusInOnEditor();\n        } else {\n            const pRow = previousRenderedCell.getRenderedRow();\n            const nRow = nextRenderedCell.getRenderedRow();\n\n            previousRenderedCell.setFocusOutOnEditor();\n            pRow.stopEditing();\n\n            nRow.startRowEditing();\n            nextRenderedCell.setFocusInOnEditor();\n        }\n\n        nextRenderedCell.focusCell();\n    }\n\n    // called by the cell, when tab is pressed while editing.\n    // @return: RenderedCell when navigation successful, otherwise null\n    private findNextCellToFocusOn(gridCell: CellPosition, backwards: boolean, startEditing: boolean): CellComp {\n        let nextCell: CellPosition = gridCell;\n\n        while (true) {\n            if (!backwards) {\n                nextCell = this.getLastCellOfColSpan(nextCell);\n            }\n            nextCell = this.cellNavigationService.getNextTabbedCell(nextCell, backwards);\n\n            // allow user to override what cell to go to next\n            const userFunc = this.gridOptionsWrapper.getTabToNextCellFunc();\n            if (_.exists(userFunc)) {\n                const params = {\n                    backwards: backwards,\n                    editing: startEditing,\n                    previousCellPosition: gridCell,\n                    nextCellPosition: nextCell ? nextCell : null\n                } as TabToNextCellParams;\n                const userCell = userFunc(params);\n                if (_.exists(userCell)) {\n                    if ((userCell as any).floating) {\n                        _.doOnce(() => {console.warn(`ag-Grid: tabToNextCellFunc return type should have attributes: rowIndex, rowPinned, column. However you had 'floating', maybe you meant 'rowPinned'?`); }, 'no floating in userCell');\n                        userCell.rowPinned = (userCell as any).floating;\n                    }\n                    nextCell = {\n                        rowIndex: userCell.rowIndex,\n                        column: userCell.column,\n                        rowPinned: userCell.rowPinned\n                    } as CellPosition;\n                } else {\n                    nextCell = null;\n                }\n            }\n\n            // if no 'next cell', means we have got to last cell of grid, so nothing to move to,\n            // so bottom right cell going forwards, or top left going backwards\n            if (!nextCell) {\n                return null;\n            }\n\n            // if editing, but cell not editable, skip cell. we do this before we do all of\n            // the 'ensure index visible' and 'flush all frames', otherwise if we are skipping\n            // a bunch of cells (eg 10 rows) then all the work on ensuring cell visible is useless\n            // (except for the last one) which causes grid to stall for a while.\n            if (startEditing) {\n                const rowNode = this.lookupRowNodeForCell(nextCell);\n                const cellIsEditable = nextCell.column.isCellEditable(rowNode);\n                if (!cellIsEditable) { continue; }\n            }\n\n            // this scrolls the row into view\n            const cellIsNotFloating = _.missing(nextCell.rowPinned);\n            if (cellIsNotFloating) {\n                this.gridPanel.ensureIndexVisible(nextCell.rowIndex);\n            }\n\n            // pinned columns don't scroll, so no need to ensure index visible\n            if (!nextCell.column.isPinned()) {\n                this.gridPanel.ensureColumnVisible(nextCell.column);\n            }\n\n            // need to nudge the scrolls for the floating items. otherwise when we set focus on a non-visible\n            // floating cell, the scrolls get out of sync\n            this.gridPanel.horizontallyScrollHeaderCenterAndFloatingCenter();\n\n            // get the grid panel to flush all animation frames - otherwise the call below to get the cellComp\n            // could fail, if we just scrolled the grid (to make a cell visible) and the rendering hasn't finished.\n            this.animationFrameService.flushAllFrames();\n\n            // we have to call this after ensureColumnVisible - otherwise it could be a virtual column\n            // or row that is not currently in view, hence the renderedCell would not exist\n            const nextCellComp = this.getComponentForCell(nextCell);\n\n            // if next cell is fullWidth row, then no rendered cell,\n            // as fullWidth rows have no cells, so we skip it\n            if (_.missing(nextCellComp)) {\n                continue;\n            }\n\n            if (nextCellComp.isSuppressNavigable()) {\n                continue;\n            }\n\n            // by default, when we click a cell, it gets selected into a range, so to keep keyboard navigation\n            // consistent, we set into range here also.\n            if (this.rangeController) {\n                this.rangeController.setRangeToCell(nextCell);\n            }\n\n            // we successfully tabbed onto a grid cell, so return true\n            return nextCellComp;\n        }\n    }\n\n    private lookupRowNodeForCell(cell: CellPosition) {\n        if (cell.rowPinned === Constants.PINNED_TOP) {\n            return this.pinnedRowModel.getPinnedTopRow(cell.rowIndex);\n        }\n\n        if (cell.rowPinned === Constants.PINNED_BOTTOM) {\n            return this.pinnedRowModel.getPinnedBottomRow(cell.rowIndex);\n        }\n\n        return this.paginationProxy.getRow(cell.rowIndex);\n    }\n}\n\nexport interface RefreshViewParams {\n    recycleRows?: boolean;\n    animate?: boolean;\n    suppressKeepFocus?: boolean;\n    onlyBody?: boolean;\n    // when new data, grid scrolls back to top\n    newData?: boolean;\n    newPage?: boolean;\n}\n"]}