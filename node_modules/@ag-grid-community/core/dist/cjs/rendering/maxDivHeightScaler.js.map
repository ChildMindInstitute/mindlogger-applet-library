{"version":3,"sources":["../../src/ts/rendering/maxDivHeightScaler.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,gDAA+C;AAC/C,8CAAoE;AAEpE,0CAAsC;AAGtC,kCAA6B;AAE7B;;;GAGG;AAGH;IAAwC,sCAAQ;IAAhD;QAAA,qEA0HC;QArGG,uBAAuB;QACf,aAAO,GAAG,CAAC,CAAC;QACpB,uBAAuB;QACf,kBAAY,GAAG,CAAC,CAAC;;IAkG7B,CAAC;IAzFW,0CAAa,GAArB;QACI,IAAI,CAAC,2BAA2B,CAAC,IAAI,CAAC,YAAY,EAAE,kBAAM,CAAC,yBAAyB,EAAE,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;QACpH,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,kBAAkB,CAAC,iBAAiB,EAAE,CAAC;QAClE,IAAI,CAAC,YAAY,GAAG,SAAC,CAAC,eAAe,EAAE,CAAC;IAC5C,CAAC;IAEM,6CAAgB,GAAvB,UAAwB,SAAoB;QACxC,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;IAC/B,CAAC;IAEM,sCAAS,GAAhB;QACI,OAAO,IAAI,CAAC,OAAO,CAAC;IACxB,CAAC;IAEM,sCAAS,GAAhB;QACI,OAAO,IAAI,CAAC,MAAM,CAAC;IACvB,CAAC;IAEM,yCAAY,GAAnB;QACI,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;YAAE,OAAO;SAAE;QAE9B,IAAM,UAAU,GAAG,IAAI,CAAC,SAAS,CAAC,kBAAkB,EAAE,CAAC,GAAG,CAAC;QAC3D,IAAM,aAAa,GAAG,IAAI,CAAC,eAAe,EAAE,CAAC;QAE7C,IAAM,iBAAiB,GAAG,UAAU,KAAK,IAAI,CAAC,OAAO,IAAI,aAAa,KAAK,IAAI,CAAC,YAAY,CAAC;QAC7F,IAAI,iBAAiB,EAAE;YACnB,IAAI,CAAC,OAAO,GAAG,UAAU,CAAC;YAC1B,IAAI,CAAC,YAAY,GAAG,aAAa,CAAC;YAClC,IAAI,CAAC,eAAe,EAAE,CAAC;SAC1B;IACL,CAAC;IAEO,4CAAe,GAAvB;QACI,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC,YAAY,CAAC;QAC3C,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,iBAAiB,CAAC;QAE/D,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC,YAAY,CAAC;QAC7D,IAAM,aAAa,GAAG,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,UAAU,CAAC;QAErD,IAAI,CAAC,SAAS,CAAC,aAAa,GAAG,IAAI,CAAC,aAAa,CAAC,CAAC;IACvD,CAAC;IAEO,wCAAW,GAAnB;QACI,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC,WAAW,CAAC;QAC1C,IAAI,CAAC,aAAa,GAAG,CAAC,CAAC;QAEvB,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;IACtB,CAAC;IAEO,sCAAS,GAAjB,UAAkB,SAAiB;QAC/B,gFAAgF;QAChF,IAAM,cAAc,GAAG,OAAO,SAAS,KAAK,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;QACpF,IAAI,IAAI,CAAC,MAAM,KAAK,cAAc,EAAE;YAAE,OAAO;SAAE;QAE/C,IAAI,CAAC,MAAM,GAAG,cAAc,CAAC;QAC7B,IAAI,CAAC,YAAY,CAAC,aAAa,CAAC,EAAC,IAAI,EAAE,kBAAM,CAAC,0BAA0B,EAAC,CAAC,CAAC;IAC/E,CAAC;IAEM,2CAAc,GAArB,UAAsB,WAAmB;QACrC,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;QAC/B,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,YAAY,GAAG,CAAC,IAAI,WAAW,GAAG,IAAI,CAAC,YAAY,CAAC;QACxE,IAAI,IAAI,CAAC,OAAO,EAAE;YACd,IAAI,CAAC,eAAe,EAAE,CAAC;SAC1B;aAAM;YACH,IAAI,CAAC,WAAW,EAAE,CAAC;SACtB;IACL,CAAC;IAEM,iDAAoB,GAA3B;QACI,OAAO,IAAI,CAAC,iBAAiB,CAAC;IAClC,CAAC;IAEM,iDAAoB,GAA3B,UAA4B,UAAkB;QAC1C,OAAO,UAAU,GAAG,IAAI,CAAC,MAAM,CAAC;IACpC,CAAC;IAEO,4CAAe,GAAvB;QACI,IAAM,GAAG,GAAG,IAAI,CAAC,SAAS,CAAC,kBAAkB,EAAE,CAAC;QAChD,OAAO,GAAG,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG,CAAC;IAChC,CAAC;IAEM,sDAAyB,GAAhC,UAAiC,MAAc;QAC3C,IAAI,IAAI,CAAC,aAAa,IAAI,CAAC,EAAE;YAAE,OAAO,MAAM,CAAC;SAAE;QAE/C,IAAM,cAAc,GAAG,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,eAAe,EAAE,CAAC;QACjE,IAAM,aAAa,GAAG,MAAM,GAAG,cAAc,CAAC;QAC9C,IAAM,WAAW,GAAG,IAAI,CAAC,UAAU,GAAG,aAAa,CAAC;QACpD,OAAO,WAAW,CAAC;IACvB,CAAC;IAvH0B;QAA1B,mBAAS,CAAC,cAAc,CAAC;4DAAoC;IAC7B;QAAhC,mBAAS,CAAC,oBAAoB,CAAC;kEAAgD;IA8BhF;QADC,uBAAa;2DAKb;IArCQ,kBAAkB;QAD9B,cAAI,CAAC,oBAAoB,CAAC;OACd,kBAAkB,CA0H9B;IAAD,yBAAC;CA1HD,AA0HC,CA1HuC,mBAAQ,GA0H/C;AA1HY,gDAAkB","file":"maxDivHeightScaler.js","sourcesContent":["import { BeanStub } from \"../context/beanStub\";\nimport { Autowired, Bean, PostConstruct } from \"../context/context\";\nimport { EventService } from \"../eventService\";\nimport { Events } from \"../eventKeys\";\nimport { GridOptionsWrapper } from \"../gridOptionsWrapper\";\nimport { GridPanel } from \"../gridPanel/gridPanel\";\nimport { _ } from \"../utils\";\n\n/**\n * This class solves the 'max height' problem, where the user might want to show more data than\n * the max div height actually allows.\n */\n\n@Bean('maxDivHeightScaler')\nexport class MaxDivHeightScaler extends BeanStub {\n\n    @Autowired('eventService') private eventService: EventService;\n    @Autowired('gridOptionsWrapper') private gridOptionsWrapper: GridOptionsWrapper;\n\n    private gridPanel: GridPanel;\n\n    private maxDivHeight: number;\n\n    // if false, then scaling is not active, logic in this class is not used,\n    // the pixel height of the row container matches what is actually needed,\n    // no scaling applied.\n    private scaling: boolean;\n\n    private modelHeight: number; // how many pixels the model needs\n    private uiContainerHeight: number; // how many pixels we actually have\n    private pixelsToShave: number; // the number of pixels we need to shave\n\n    // the number of pixels we add to each rowTop - depends on the scroll position\n    private offset: number;\n\n    // the scrollY position\n    private scrollY = 0;\n    // how tall the body is\n    private uiBodyHeight = 0;\n\n    // the max scroll position\n    private maxScrollY: number;\n\n    // we need this for the maths, as it impacts the grid height\n    private scrollBarWidth: number;\n\n    @PostConstruct\n    private postConstruct(): void {\n        this.addDestroyableEventListener(this.eventService, Events.EVENT_BODY_HEIGHT_CHANGED, this.updateOffset.bind(this));\n        this.scrollBarWidth = this.gridOptionsWrapper.getScrollbarWidth();\n        this.maxDivHeight = _.getMaxDivHeight();\n    }\n\n    public registerGridComp(gridPanel: GridPanel): void {\n        this.gridPanel = gridPanel;\n    }\n\n    public isScaling(): boolean {\n        return this.scaling;\n    }\n\n    public getOffset(): number {\n        return this.offset;\n    }\n\n    public updateOffset(): void {\n        if (!this.scaling) { return; }\n\n        const newScrollY = this.gridPanel.getVScrollPosition().top;\n        const newBodyHeight = this.getUiBodyHeight();\n\n        const atLeastOneChanged = newScrollY !== this.scrollY || newBodyHeight !== this.uiBodyHeight;\n        if (atLeastOneChanged) {\n            this.scrollY = newScrollY;\n            this.uiBodyHeight = newBodyHeight;\n            this.calculateOffset();\n        }\n    }\n\n    private calculateOffset(): void {\n        this.uiContainerHeight = this.maxDivHeight;\n        this.pixelsToShave = this.modelHeight - this.uiContainerHeight;\n\n        this.maxScrollY = this.uiContainerHeight - this.uiBodyHeight;\n        const scrollPercent = this.scrollY / this.maxScrollY;\n\n        this.setOffset(scrollPercent * this.pixelsToShave);\n    }\n\n    private clearOffset(): void {\n        this.uiContainerHeight = this.modelHeight;\n        this.pixelsToShave = 0;\n\n        this.setOffset(0);\n    }\n\n    private setOffset(newOffset: number): void {\n        // because we are talking pixels, no point in confusing things with half numbers\n        const newOffsetFloor = typeof newOffset === 'number' ? Math.floor(newOffset) : null;\n        if (this.offset === newOffsetFloor) { return; }\n\n        this.offset = newOffsetFloor;\n        this.eventService.dispatchEvent({type: Events.EVENT_HEIGHT_SCALE_CHANGED});\n    }\n\n    public setModelHeight(modelHeight: number): void {\n        this.modelHeight = modelHeight;\n        this.scaling = this.maxDivHeight > 0 && modelHeight > this.maxDivHeight;\n        if (this.scaling) {\n            this.calculateOffset();\n        } else {\n            this.clearOffset();\n        }\n    }\n\n    public getUiContainerHeight(): number {\n        return this.uiContainerHeight;\n    }\n\n    public getRealPixelPosition(modelPixel: number): number {\n        return modelPixel - this.offset;\n    }\n\n    private getUiBodyHeight(): number {\n        const pos = this.gridPanel.getVScrollPosition();\n        return pos.bottom - pos.top;\n    }\n\n    public getScrollPositionForPixel(rowTop: number): number {\n        if (this.pixelsToShave <= 0) { return rowTop; }\n\n        const modelMaxScroll = this.modelHeight - this.getUiBodyHeight();\n        const scrollPercent = rowTop / modelMaxScroll;\n        const scrollPixel = this.maxScrollY * scrollPercent;\n        return scrollPixel;\n    }\n}"]}