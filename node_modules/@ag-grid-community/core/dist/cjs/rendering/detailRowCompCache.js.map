{"version":3,"sources":["../../src/ts/rendering/detailRowCompCache.ts"],"names":[],"mappings":";;;;;;;;;;;;;;AAGA,8CAAgF;AAEhF,0CAAuC;AAEvC;;;;;;GAMG;AAEH;IAAA;QAIY,eAAU,GAAgB,EAAE,CAAC;IAqIzC,CAAC;IA9HW,0CAAa,GAArB;QACI,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,kBAAkB,CAAC,gBAAgB,EAAE,CAAC;QACzD,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,kBAAkB,CAAC,sBAAsB,EAAE,CAAC;IACzE,CAAC;IAEM,yCAAY,GAAnB,UAAoB,OAAgB,EAAE,MAAc,EAAE,IAAuB;QACzE,0BAA0B;QAC1B,IAAM,aAAa,GAAG,CAAC,IAAI,CAAC,MAAM,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC;QACtD,IAAI,aAAa,EAAE;YACf,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAC;YAC/B,OAAO;SACV;QAED,IAAM,IAAI,GAAG,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;QAE9C,kDAAkD;QAClD,+DAA+D;QAC/D,0EAA0E;QAC1E,uEAAuE;QACvE,0DAA0D;QAC1D,QAAQ,MAAM,EAAE;YACZ,KAAK,qBAAS,CAAC,WAAW;gBACtB,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBACpC,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;gBACjB,MAAM;YACV,KAAK,qBAAS,CAAC,YAAY;gBACvB,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gBACrC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;gBAClB,MAAM;YACV;gBACI,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;gBACtC,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;gBACnB,MAAM;SACb;QAED,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,UAAC,CAAY,EAAE,CAAY;YAC5C,OAAO,CAAC,CAAC,gBAAgB,GAAG,CAAC,CAAC,gBAAgB,CAAC;QACnD,CAAC,CAAC,CAAC;QACH,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;IACvC,CAAC;IAEO,yCAAY,GAApB,UAAqB,OAAgB,EAAE,UAAkB;QAAlB,2BAAA,EAAA,kBAAkB;QACrD,IAAI,GAAc,CAAC;QAEnB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAC7C,IAAM,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;YAChC,IAAI,IAAI,CAAC,OAAO,KAAK,OAAO,EAAE;gBAC1B,GAAG,GAAG,IAAI,CAAC;gBACX,MAAM;aACT;SACJ;QAED,IAAI,CAAC,GAAG,IAAI,UAAU,EAAE;YACpB,GAAG,GAAG;gBACF,OAAO,EAAE,OAAO;aACN,CAAC;YACf,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;SAC7B;QAED,IAAI,GAAG,EAAE;YACL,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC;SAC5B;QAED,OAAO,GAAG,CAAC;IACf,CAAC;IAEO,2CAAc,GAAtB,UAAuB,IAAe;QAClC,IAAI,CAAC,gBAAgB,GAAG,IAAI,IAAI,EAAE,CAAC,OAAO,EAAE,CAAC;IACjD,CAAC;IAEO,gDAAmB,GAA3B,UAA4B,IAAuB;QAC/C,IAAI,IAAI,IAAI,IAAI,CAAC,OAAO,EAAE;YACtB,IAAI,CAAC,OAAO,EAAE,CAAC;SAClB;IACL,CAAC;IAEO,uCAAU,GAAlB,UAAmB,UAAkB;QACjC,6CAA6C;QAC7C,KAAK,IAAI,CAAC,GAAG,UAAU,EAAE,CAAC,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACtD,IAAM,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;YAChC,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YACtC,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YACpC,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;SACxC;QAED,4EAA4E;QAC5E,IAAI,IAAI,CAAC,UAAU,CAAC,MAAM,GAAG,UAAU,EAAE;YACrC,IAAI,CAAC,UAAU,CAAC,MAAM,GAAG,UAAU,CAAC;SACvC;IACL,CAAC;IAEM,gCAAG,GAAV,UAAW,OAAgB,EAAE,MAAc;QACvC,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE;YAAE,OAAO,SAAS,CAAC;SAAE;QAE1C,IAAM,IAAI,GAAG,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC;QACxC,IAAI,GAAsB,CAAC;QAC3B,IAAI,IAAI,EAAE;YACN,QAAQ,MAAM,EAAE;gBACZ,KAAK,qBAAS,CAAC,WAAW;oBACtB,IAAI,IAAI,CAAC,IAAI,EAAE;wBACX,GAAG,GAAG,IAAI,CAAC,IAAI,CAAC;wBAChB,IAAI,CAAC,IAAI,GAAG,SAAS,CAAC;qBACzB;oBACD,MAAM;gBACV,KAAK,qBAAS,CAAC,YAAY;oBACvB,IAAI,IAAI,CAAC,KAAK,EAAE;wBACZ,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC;wBACjB,IAAI,CAAC,KAAK,GAAG,SAAS,CAAC;qBAC1B;oBACD,MAAM;gBACV;oBACI,IAAI,IAAI,CAAC,MAAM,EAAE;wBACb,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC;wBAClB,IAAI,CAAC,MAAM,GAAG,SAAS,CAAC;qBAC3B;oBACD,MAAM;aACb;SACJ;QACD,OAAO,GAAG,CAAC;IACf,CAAC;IAGM,oCAAO,GAAd;QACI,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;IACvB,CAAC;IArIgC;QAAhC,mBAAS,CAAC,oBAAoB,CAAC;kEAAgD;IAShF;QADC,uBAAa;2DAIb;IAuHD;QADC,oBAAU;qDAGV;IAvIQ,kBAAkB;QAD9B,cAAI,CAAC,oBAAoB,CAAC;OACd,kBAAkB,CAyI9B;IAAD,yBAAC;CAzID,AAyIC,IAAA;AAzIY,gDAAkB","file":"detailRowCompCache.js","sourcesContent":["import { ICellRendererComp } from \"./cellRenderers/iCellRenderer\";\nimport { RowNode } from \"../entities/rowNode\";\nimport { Column } from \"../entities/column\";\nimport { Autowired, Bean, PostConstruct, PreDestroy } from \"../context/context\";\nimport { GridOptionsWrapper } from \"../gridOptionsWrapper\";\nimport {Constants} from \"../constants\";\n\n/**\n * For Master Detail, it is required to keep components between expanding & collapsing parents.\n * For example a user expands row A (and shows a detail grid for this row), then when row A\n * is closed, we want to keep the detail grid, so next time row A is expanded the detail grid\n * is showed with it's context intact, eg if user sorted in the detail grid, that sort should\n * still be applied after the detail grid is shown for the second time.\n */\n@Bean('detailRowCompCache')\nexport class DetailRowCompCache {\n\n    @Autowired('gridOptionsWrapper') private gridOptionsWrapper: GridOptionsWrapper;\n\n    private cacheItems: CacheItem[] = [];\n\n    private maxCacheSize: number;\n\n    private active: boolean;\n\n    @PostConstruct\n    private postConstruct(): void {\n        this.active = this.gridOptionsWrapper.isKeepDetailRows();\n        this.maxCacheSize = this.gridOptionsWrapper.getKeepDetailRowsCount();\n    }\n\n    public addOrDestroy(rowNode: RowNode, pinned: string, comp: ICellRendererComp): void {\n        // only accept detail rows\n        const doNotUseCache = !this.active || !rowNode.detail;\n        if (doNotUseCache) {\n            this.destroyFullWidthRow(comp);\n            return;\n        }\n\n        const item = this.getCacheItem(rowNode, true);\n\n        // put the comp in the right location of the item.\n        // we also destroy any previous comp - this should never happen\n        // as the logic outside of this class shouldn't be adding same item to the\n        // cache twice, however we cater for it in case in future releases code\n        // outside of this class is changed and this could happen.\n        switch (pinned) {\n            case Constants.PINNED_LEFT:\n                this.destroyFullWidthRow(item.left);\n                item.left = comp;\n                break;\n            case Constants.PINNED_RIGHT:\n                this.destroyFullWidthRow(item.right);\n                item.right = comp;\n                break;\n            default:\n                this.destroyFullWidthRow(item.center);\n                item.center = comp;\n                break;\n        }\n\n        this.cacheItems.sort((a: CacheItem, b: CacheItem) => {\n            return b.lastAccessedTime - a.lastAccessedTime;\n        });\n        this.purgeCache(this.maxCacheSize);\n    }\n\n    private getCacheItem(rowNode: RowNode, autoCreate = false): CacheItem {\n        let res: CacheItem;\n\n        for (let i = 0; i < this.cacheItems.length; i++) {\n            const item = this.cacheItems[i];\n            if (item.rowNode === rowNode) {\n                res = item;\n                break;\n            }\n        }\n\n        if (!res && autoCreate) {\n            res = {\n                rowNode: rowNode\n            } as CacheItem;\n            this.cacheItems.push(res);\n        }\n\n        if (res) {\n            this.stampCacheItem(res);\n        }\n\n        return res;\n    }\n\n    private stampCacheItem(item: CacheItem) {\n        item.lastAccessedTime = new Date().getTime();\n    }\n\n    private destroyFullWidthRow(comp: ICellRendererComp): void {\n        if (comp && comp.destroy) {\n            comp.destroy();\n        }\n    }\n\n    private purgeCache(startIndex: number): void {\n        // delete all rows past the index of interest\n        for (let i = startIndex; i < this.cacheItems.length; i++) {\n            const item = this.cacheItems[i];\n            this.destroyFullWidthRow(item.center);\n            this.destroyFullWidthRow(item.left);\n            this.destroyFullWidthRow(item.right);\n        }\n\n        // change the length of the array so it no longer contains the deleted items\n        if (this.cacheItems.length > startIndex) {\n            this.cacheItems.length = startIndex;\n        }\n    }\n\n    public get(rowNode: RowNode, pinned: string): ICellRendererComp {\n        if (!rowNode.detail) { return undefined; }\n\n        const item = this.getCacheItem(rowNode);\n        let res: ICellRendererComp;\n        if (item) {\n            switch (pinned) {\n                case Constants.PINNED_LEFT:\n                    if (item.left) {\n                        res = item.left;\n                        item.left = undefined;\n                    }\n                    break;\n                case Constants.PINNED_RIGHT:\n                    if (item.right) {\n                        res = item.right;\n                        item.right = undefined;\n                    }\n                    break;\n                default:\n                    if (item.center) {\n                        res = item.center;\n                        item.center = undefined;\n                    }\n                    break;\n            }\n        }\n        return res;\n    }\n\n    @PreDestroy\n    public destroy(): void {\n        this.purgeCache(0);\n    }\n\n}\n\ninterface CacheItem {\n    rowNode: RowNode;\n    lastAccessedTime: number;\n    center?: ICellRendererComp;\n    left?: ICellRendererComp;\n    right?: ICellRendererComp;\n}\n"]}