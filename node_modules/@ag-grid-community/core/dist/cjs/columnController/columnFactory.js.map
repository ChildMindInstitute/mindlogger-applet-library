{"version":3,"sources":["../../src/ts/columnController/columnFactory.ts"],"names":[],"mappings":"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","file":"columnFactory.js","sourcesContent":["import { GridOptionsWrapper } from '../gridOptionsWrapper';\nimport { Logger, LoggerFactory } from '../logger';\nimport { ColumnUtils } from './columnUtils';\nimport { AbstractColDef, ColDef, ColGroupDef } from \"../entities/colDef\";\nimport { ColumnKeyCreator } from \"./columnKeyCreator\";\nimport { OriginalColumnGroupChild } from \"../entities/originalColumnGroupChild\";\nimport { OriginalColumnGroup } from \"../entities/originalColumnGroup\";\nimport { Column } from \"../entities/column\";\nimport { Autowired, Bean, Context, Qualifier } from \"../context/context\";\nimport { DefaultColumnTypes } from \"../entities/defaultColumnTypes\";\nimport { _ } from \"../utils\";\n\n// takes ColDefs and ColGroupDefs and turns them into Columns and OriginalGroups\n@Bean('columnFactory')\nexport class ColumnFactory {\n\n    @Autowired('gridOptionsWrapper') private gridOptionsWrapper: GridOptionsWrapper;\n    @Autowired('columnUtils') private columnUtils: ColumnUtils;\n    @Autowired('context') private context: Context;\n\n    private logger: Logger;\n\n    private setBeans(@Qualifier('loggerFactory') loggerFactory: LoggerFactory) {\n        this.logger = loggerFactory.create('ColumnFactory');\n    }\n\n    public createColumnTree(defs: (ColDef | ColGroupDef)[] | null, primaryColumns: boolean, existingColumns?: Column[])\n        : { columnTree: OriginalColumnGroupChild[], treeDept: number } {\n\n        // column key creator dishes out unique column id's in a deterministic way,\n        // so if we have two grids (that could be master/slave) with same column definitions,\n        // then this ensures the two grids use identical id's.\n        const columnKeyCreator = new ColumnKeyCreator();\n\n        if (existingColumns) {\n            const existingKeys: string[] = existingColumns.map(col => col.getId());\n            columnKeyCreator.addExistingKeys(existingKeys);\n        }\n\n        // we take a copy of the columns as we are going to be removing from them\n        const existingColsCopy = existingColumns ? existingColumns.slice() : null;\n\n        // create am unbalanced tree that maps the provided definitions\n        const unbalancedTree = this.recursivelyCreateColumns(defs, 0, primaryColumns,\n            existingColsCopy, columnKeyCreator, null);\n        const treeDept = this.findMaxDept(unbalancedTree, 0);\n        this.logger.log('Number of levels for grouped columns is ' + treeDept);\n        const columnTree = this.balanceColumnTree(unbalancedTree, 0, treeDept, columnKeyCreator);\n\n        const deptFirstCallback = (child: OriginalColumnGroupChild, parent: OriginalColumnGroup) => {\n            if (child instanceof OriginalColumnGroup) {\n                child.setupExpandable();\n            }\n            // we set the original parents at the end, rather than when we go along, as balancing the tree\n            // adds extra levels into the tree. so we can only set parents when balancing is done.\n            child.setOriginalParent(parent);\n        };\n\n        this.columnUtils.depthFirstOriginalTreeSearch(null, columnTree, deptFirstCallback);\n\n        return {\n            columnTree,\n            treeDept\n        };\n    }\n\n    public createForAutoGroups(autoGroupCols: Column[] | null, gridBalancedTree: OriginalColumnGroupChild[]): OriginalColumnGroupChild[] {\n        const autoColBalancedTree: OriginalColumnGroupChild[] = [];\n        autoGroupCols.forEach(col => {\n            const fakeTreeItem = this.createAutoGroupTreeItem(gridBalancedTree, col);\n            autoColBalancedTree.push(fakeTreeItem);\n        });\n\n        return autoColBalancedTree;\n    }\n\n    private createAutoGroupTreeItem(balancedColumnTree: OriginalColumnGroupChild[], column: Column): OriginalColumnGroupChild {\n\n        const dept = this.findDepth(balancedColumnTree);\n\n        // at the end, this will be the top of the tree item.\n        let nextChild: OriginalColumnGroupChild = column;\n\n        for (let i = dept - 1; i >= 0; i--) {\n            const autoGroup = new OriginalColumnGroup(\n                null,\n                `FAKE_PATH_${column.getId()}}_${i}`,\n                true,\n                i\n            );\n            this.context.wireBean(autoGroup);\n            autoGroup.setChildren([nextChild]);\n            nextChild.setOriginalParent(autoGroup);\n            nextChild = autoGroup;\n        }\n\n        // at this point, the nextChild is the top most item in the tree\n        return nextChild;\n    }\n\n    private findDepth(balancedColumnTree: OriginalColumnGroupChild[]): number {\n        let dept = 0;\n        let pointer = balancedColumnTree;\n\n        while (pointer && pointer[0] && pointer[0] instanceof OriginalColumnGroup) {\n            dept++;\n            pointer = (pointer[0] as OriginalColumnGroup).getChildren();\n        }\n        return dept;\n    }\n\n    private balanceColumnTree(\n            unbalancedTree: OriginalColumnGroupChild[],\n            currentDept: number,\n            columnDept: number,\n            columnKeyCreator: ColumnKeyCreator\n        ): OriginalColumnGroupChild[] {\n\n        const result: OriginalColumnGroupChild[] = [];\n\n        // go through each child, for groups, recurse a level deeper,\n        // for columns we need to pad\n        for (let i = 0; i < unbalancedTree.length; i++) {\n            const child = unbalancedTree[i];\n            if (child instanceof OriginalColumnGroup) {\n                // child is a group, all we do is go to the next level of recursion\n                const originalGroup = child;\n                const newChildren = this.balanceColumnTree(originalGroup.getChildren(),\n                    currentDept + 1, columnDept, columnKeyCreator);\n                originalGroup.setChildren(newChildren);\n                result.push(originalGroup);\n            } else {\n                // child is a column - so here we add in the padded column groups if needed\n                let firstPaddedGroup: OriginalColumnGroup | undefined;\n                let currentPaddedGroup: OriginalColumnGroup | undefined;\n\n                // this for loop will NOT run any loops if no padded column groups are needed\n                for (let j = columnDept - 1; j >= currentDept; j--) {\n                    const newColId = columnKeyCreator.getUniqueKey(null, null);\n                    const colGroupDefMerged = this.createMergedColGroupDef(null);\n\n                    const paddedGroup = new OriginalColumnGroup(colGroupDefMerged, newColId, true, currentDept);\n                    this.context.wireBean(paddedGroup);\n\n                    if (currentPaddedGroup) {\n                        currentPaddedGroup.setChildren([paddedGroup]);\n                    }\n\n                    currentPaddedGroup = paddedGroup;\n\n                    if (!firstPaddedGroup) {\n                        firstPaddedGroup = currentPaddedGroup;\n                    }\n                }\n\n                // likewise this if statement will not run if no padded groups\n                if (firstPaddedGroup) {\n                    result.push(firstPaddedGroup);\n                    const hasGroups = unbalancedTree.some(child => child instanceof OriginalColumnGroup);\n\n                    if (hasGroups) {\n                        currentPaddedGroup.setChildren([child]);\n                        continue;\n                    } else {\n                        currentPaddedGroup.setChildren(unbalancedTree);\n                        break;\n                    }\n                }\n\n                result.push(child);\n            }\n        }\n\n        return result;\n    }\n\n    private findMaxDept(treeChildren: OriginalColumnGroupChild[], dept: number): number {\n        let maxDeptThisLevel = dept;\n\n        for (let i = 0; i < treeChildren.length; i++) {\n            const abstractColumn = treeChildren[i];\n            if (abstractColumn instanceof OriginalColumnGroup) {\n                const originalGroup = abstractColumn;\n                const newDept = this.findMaxDept(originalGroup.getChildren(), dept + 1);\n                if (maxDeptThisLevel < newDept) {\n                    maxDeptThisLevel = newDept;\n                }\n            }\n        }\n\n        return maxDeptThisLevel;\n    }\n\n    private recursivelyCreateColumns(\n            defs: (ColDef | ColGroupDef)[],\n            level: number,\n            primaryColumns: boolean,\n            existingColsCopy: Column[],\n            columnKeyCreator: ColumnKeyCreator,\n            parent: OriginalColumnGroup | null\n        ): OriginalColumnGroupChild[] {\n\n        const result: OriginalColumnGroupChild[] = [];\n\n        if (!defs) { return result; }\n\n        defs.forEach((def: ColDef | ColGroupDef) => {\n            let newGroupOrColumn: OriginalColumnGroupChild;\n\n            if (this.isColumnGroup(def)) {\n                newGroupOrColumn = this.createColumnGroup(primaryColumns, def as ColGroupDef, level, existingColsCopy,\n                    columnKeyCreator, parent);\n            } else {\n                newGroupOrColumn = this.createColumn(primaryColumns, def as ColDef, existingColsCopy, columnKeyCreator, parent);\n            }\n\n            result.push(newGroupOrColumn);\n        });\n\n        return result;\n    }\n\n    private createColumnGroup(\n            primaryColumns: boolean,\n            colGroupDef: ColGroupDef,\n            level: number,\n            existingColumns: Column[],\n            columnKeyCreator: ColumnKeyCreator,\n            parent: OriginalColumnGroup | null\n        ): OriginalColumnGroup {\n        const colGroupDefMerged = this.createMergedColGroupDef(colGroupDef);\n        const groupId = columnKeyCreator.getUniqueKey(colGroupDefMerged.groupId, null);\n        const originalGroup = new OriginalColumnGroup(colGroupDefMerged, groupId, false, level);\n\n        this.context.wireBean(originalGroup);\n\n        const children = this.recursivelyCreateColumns(colGroupDefMerged.children,\n            level + 1, primaryColumns, existingColumns, columnKeyCreator, originalGroup);\n\n        originalGroup.setChildren(children);\n\n        return originalGroup;\n    }\n\n    private createMergedColGroupDef(colGroupDef: ColGroupDef): ColGroupDef {\n        const colGroupDefMerged: ColGroupDef = {} as ColGroupDef;\n        _.assign(colGroupDefMerged, this.gridOptionsWrapper.getDefaultColGroupDef());\n        _.assign(colGroupDefMerged, colGroupDef);\n        this.checkForDeprecatedItems(colGroupDefMerged);\n\n        return colGroupDefMerged;\n    }\n\n    private createColumn(\n            primaryColumns: boolean,\n            colDef: ColDef,\n            existingColsCopy: Column[],\n            columnKeyCreator: ColumnKeyCreator,\n            parent: OriginalColumnGroup | null\n        ): Column {\n        const colDefMerged = this.mergeColDefs(colDef);\n\n        this.checkForDeprecatedItems(colDefMerged);\n\n        // see if column already exists\n        let column = this.findExistingColumn(colDef, existingColsCopy);\n\n        if (!column) {\n            // no existing column, need to create one\n            const colId = columnKeyCreator.getUniqueKey(colDefMerged.colId, colDefMerged.field);\n            column = new Column(colDefMerged, colDef, colId, primaryColumns);\n            this.context.wireBean(column);\n        } else {\n            column.setColDef(colDefMerged, colDef);\n        }\n\n        return column;\n    }\n\n    private findExistingColumn(colDef: ColDef, existingColsCopy: Column[]): Column {\n        const res: Column = _.find(existingColsCopy, col => {\n            const oldColDef = col.getUserProvidedColDef();\n\n            if (!oldColDef) { return false; }\n\n            // first check object references\n            if (oldColDef === colDef) { return true; }\n            // second check id's\n            const oldColHadId = oldColDef.colId !== null && oldColDef.colId !== undefined;\n\n            if (oldColHadId) {\n                return oldColDef.colId === colDef.colId;\n            }\n\n            return false;\n        });\n\n        // make sure we remove, so if user provided duplicate id, then we don't have more than\n        // one column instance for colDef with common id\n        if (res) {\n            _.removeFromArray(existingColsCopy, res);\n        }\n\n        return res;\n    }\n\n    public mergeColDefs(colDef: ColDef) {\n        // start with empty merged definition\n        const colDefMerged: ColDef = {} as ColDef;\n\n        // merge properties from default column definitions\n        _.assign(colDefMerged, this.gridOptionsWrapper.getDefaultColDef());\n\n        // merge properties from column type properties\n        if (colDef.type) {\n            this.assignColumnTypes(colDef, colDefMerged);\n        }\n\n        // merge properties from column definitions\n        _.assign(colDefMerged, colDef);\n\n        return colDefMerged;\n    }\n\n    private assignColumnTypes(colDef: ColDef, colDefMerged: ColDef) {\n        let typeKeys: string[];\n\n        if (colDef.type instanceof Array) {\n            const invalidArray = colDef.type.some(a => typeof a !== 'string');\n            if (invalidArray) {\n                console.warn(\"ag-grid: if colDef.type is supplied an array it should be of type 'string[]'\");\n            } else {\n                typeKeys = colDef.type;\n            }\n        } else if (typeof colDef.type === 'string') {\n            typeKeys = colDef.type.split(',');\n        } else {\n            console.warn(\"ag-grid: colDef.type should be of type 'string' | 'string[]'\");\n            return;\n        }\n\n        // merge user defined with default column types\n        const allColumnTypes = _.assign({}, this.gridOptionsWrapper.getColumnTypes(), DefaultColumnTypes);\n\n        typeKeys.forEach((t) => {\n            const typeColDef = allColumnTypes[t.trim()];\n            if (typeColDef) {\n                _.assign(colDefMerged, typeColDef);\n            } else {\n                console.warn(\"ag-grid: colDef.type '\" + t + \"' does not correspond to defined gridOptions.columnTypes\");\n            }\n        });\n    }\n\n    private checkForDeprecatedItems(colDef: AbstractColDef) {\n        if (colDef) {\n            const colDefNoType = colDef as any; // take out the type, so we can access attributes not defined in the type\n            if (colDefNoType.group !== undefined) {\n                console.warn('ag-grid: colDef.group is invalid, please check documentation on how to do grouping as it changed in version 3');\n            }\n            if (colDefNoType.headerGroup !== undefined) {\n                console.warn('ag-grid: colDef.headerGroup is invalid, please check documentation on how to do grouping as it changed in version 3');\n            }\n            if (colDefNoType.headerGroupShow !== undefined) {\n                console.warn('ag-grid: colDef.headerGroupShow is invalid, should be columnGroupShow, please check documentation on how to do grouping as it changed in version 3');\n            }\n\n            if (colDefNoType.suppressRowGroup !== undefined) {\n                console.warn('ag-grid: colDef.suppressRowGroup is deprecated, please use colDef.type instead');\n            }\n            if (colDefNoType.suppressAggregation !== undefined) {\n                console.warn('ag-grid: colDef.suppressAggregation is deprecated, please use colDef.type instead');\n            }\n\n            if (colDefNoType.suppressRowGroup || colDefNoType.suppressAggregation) {\n                console.warn('ag-grid: colDef.suppressAggregation and colDef.suppressRowGroup are deprecated, use allowRowGroup, allowPivot and allowValue instead');\n            }\n\n            if (colDefNoType.displayName) {\n                console.warn(\"ag-grid: Found displayName \" + colDefNoType.displayName + \", please use headerName instead, displayName is deprecated.\");\n                colDefNoType.headerName = colDefNoType.displayName;\n            }\n        }\n    }\n\n    // if object has children, we assume it's a group\n    private isColumnGroup(abstractColDef: ColDef | ColGroupDef): boolean {\n        return (abstractColDef as ColGroupDef).children !== undefined;\n    }\n}"]}