{"version":3,"sources":["../../src/ts/columnController/columnController.ts"],"names":[],"mappings":"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","file":"columnController.js","sourcesContent":["import { ColumnGroup } from \"../entities/columnGroup\";\nimport { Column } from \"../entities/column\";\nimport { AbstractColDef, ColDef, ColGroupDef, IAggFunc } from \"../entities/colDef\";\nimport { ColumnGroupChild } from \"../entities/columnGroupChild\";\nimport { GridOptionsWrapper } from \"../gridOptionsWrapper\";\nimport { ExpressionService } from \"../valueService/expressionService\";\nimport { ColumnFactory } from \"./columnFactory\";\nimport { DisplayedGroupCreator } from \"./displayedGroupCreator\";\nimport { AutoWidthCalculator } from \"../rendering/autoWidthCalculator\";\nimport { OriginalColumnGroupChild } from \"../entities/originalColumnGroupChild\";\nimport { EventService } from \"../eventService\";\nimport { ColumnUtils } from \"./columnUtils\";\nimport { Logger, LoggerFactory } from \"../logger\";\nimport {\n    ColumnEvent,\n    ColumnEventType,\n    ColumnEverythingChangedEvent,\n    ColumnGroupOpenedEvent,\n    ColumnMovedEvent,\n    ColumnPinnedEvent,\n    ColumnPivotModeChangedEvent,\n    ColumnResizedEvent,\n    ColumnRowGroupChangedEvent,\n    ColumnValueChangedEvent,\n    ColumnVisibleEvent,\n    DisplayedColumnsChangedEvent,\n    DisplayedColumnsWidthChangedEvent,\n    Events,\n    GridColumnsChangedEvent,\n    NewColumnsLoadedEvent,\n    VirtualColumnsChangedEvent\n} from \"../events\";\nimport { OriginalColumnGroup } from \"../entities/originalColumnGroup\";\nimport { GroupInstanceIdCreator } from \"./groupInstanceIdCreator\";\nimport { Autowired, Bean, Context, Optional, PostConstruct, Qualifier } from \"../context/context\";\nimport { IAggFuncService } from \"../interfaces/iAggFuncService\";\nimport { ColumnAnimationService } from \"../rendering/columnAnimationService\";\nimport { AutoGroupColService } from \"./autoGroupColService\";\nimport { RowNode } from \"../entities/rowNode\";\nimport { ValueCache } from \"../valueService/valueCache\";\nimport { GridApi } from \"../gridApi\";\nimport { ColumnApi } from \"./columnApi\";\nimport { Constants } from \"../constants\";\nimport { _ } from \"../utils\";\n\nexport interface ColumnResizeSet {\n    columns: Column[];\n    ratios: number[];\n    width: number;\n}\n\nexport interface ColumnState {\n    colId: string;\n    hide?: boolean;\n    aggFunc?: string | IAggFunc | null;\n    width?: number;\n    pivotIndex?: number | null;\n    pinned?: boolean | string | \"left\" | \"right\";\n    rowGroupIndex?: number | null;\n}\n\n@Bean('columnController')\nexport class ColumnController {\n\n    @Autowired('gridOptionsWrapper') private gridOptionsWrapper: GridOptionsWrapper;\n    @Autowired('expressionService') private expressionService: ExpressionService;\n    @Autowired('columnFactory') private columnFactory: ColumnFactory;\n    @Autowired('displayedGroupCreator') private displayedGroupCreator: DisplayedGroupCreator;\n    @Autowired('autoWidthCalculator') private autoWidthCalculator: AutoWidthCalculator;\n    @Autowired('eventService') private eventService: EventService;\n    @Autowired('columnUtils') private columnUtils: ColumnUtils;\n    @Autowired('context') private context: Context;\n    @Autowired('columnAnimationService') private columnAnimationService: ColumnAnimationService;\n    @Autowired('autoGroupColService') private autoGroupColService: AutoGroupColService;\n    @Optional('aggFuncService') private aggFuncService: IAggFuncService;\n    @Optional('valueCache') private valueCache: ValueCache;\n\n    @Autowired('columnApi') private columnApi: ColumnApi;\n    @Autowired('gridApi') private gridApi: GridApi;\n\n    // these are the columns provided by the client. this doesn't change, even if the\n    // order or state of the columns and groups change. it will only change if the client\n    // provides a new set of column definitions. otherwise this tree is used to build up\n    // the groups for displaying.\n    private primaryColumnTree: OriginalColumnGroupChild[];\n    // header row count, based on user provided columns\n    private primaryHeaderRowCount = 0;\n    // all columns provided by the user. basically it's the leaf level nodes of the\n    // tree above (originalBalancedTree)\n    private primaryColumns: Column[]; // every column available\n\n    // if pivoting, these are the generated columns as a result of the pivot\n    private secondaryBalancedTree: OriginalColumnGroupChild[] | null;\n    private secondaryColumns: Column[] | null;\n    private secondaryHeaderRowCount = 0;\n    private secondaryColumnsPresent = false;\n\n    // the columns the quick filter should use. this will be all primary columns\n    // plus the autoGroupColumns if any exist\n    private columnsForQuickFilter: Column[];\n\n    // these are all columns that are available to the grid for rendering after pivot\n    private gridBalancedTree: OriginalColumnGroupChild[];\n    private gridColumns: Column[];\n    // header row count, either above, or based on pivoting if we are pivoting\n    private gridHeaderRowCount = 0;\n\n    private lastPrimaryOrder: Column[];\n    private gridColsArePrimary: boolean;\n\n    // these are the columns actually shown on the screen. used by the header renderer,\n    // as header needs to know about column groups and the tree structure.\n    private displayedLeftColumnTree: ColumnGroupChild[];\n    private displayedRightColumnTree: ColumnGroupChild[];\n    private displayedCentreColumnTree: ColumnGroupChild[];\n\n    private displayedLeftHeaderRows: { [row: number]: ColumnGroupChild[] };\n    private displayedRightHeaderRows: { [row: number]: ColumnGroupChild[] };\n    private displayedCentreHeaderRows: { [row: number]: ColumnGroupChild[] };\n\n    // these are the lists used by the rowRenderer to render nodes. almost the leaf nodes of the above\n    // displayed trees, however it also takes into account if the groups are open or not.\n    private displayedLeftColumns: Column[] = [];\n    private displayedRightColumns: Column[] = [];\n    private displayedCenterColumns: Column[] = [];\n    // all three lists above combined\n    private allDisplayedColumns: Column[] = [];\n    // same as above, except trimmed down to only columns within the viewport\n    private allDisplayedVirtualColumns: Column[] = [];\n    private allDisplayedCenterVirtualColumns: Column[] = [];\n\n    // true if we are doing column spanning\n    private colSpanActive: boolean;\n\n    // grid columns that have colDef.autoHeight set\n    private autoRowHeightColumns: Column[];\n\n    private suppressColumnVirtualisation: boolean;\n\n    private rowGroupColumns: Column[] = [];\n    private valueColumns: Column[] = [];\n    private pivotColumns: Column[] = [];\n\n    private groupAutoColumns: Column[] | null;\n\n    private groupDisplayColumns: Column[];\n\n    private ready = false;\n    private logger: Logger;\n\n    private autoGroupsNeedBuilding = false;\n\n    private pivotMode = false;\n    private usingTreeData: boolean;\n\n    // for horizontal visualisation of columns\n    private scrollWidth: number;\n    private scrollPosition: number;\n\n    private bodyWidth = 0;\n    private leftWidth = 0;\n    private rightWidth = 0;\n\n    private bodyWidthDirty = true;\n\n    private viewportLeft: number;\n    private viewportRight: number;\n    private flexViewportWidth: number;\n\n    private columnDefs: (ColDef | ColGroupDef)[];\n    private flexActive = false;\n\n    @PostConstruct\n    public init(): void {\n        const pivotMode = this.gridOptionsWrapper.isPivotMode();\n\n        this.suppressColumnVirtualisation = this.gridOptionsWrapper.isSuppressColumnVirtualisation();\n\n        if (this.isPivotSettingAllowed(pivotMode)) {\n            this.pivotMode = pivotMode;\n        }\n\n        this.usingTreeData = this.gridOptionsWrapper.isTreeData();\n    }\n\n    public setColumnDefs(columnDefs: (ColDef | ColGroupDef)[], source: ColumnEventType = \"api\") {\n        const colsPreviouslyExisted = !!this.columnDefs;\n\n        this.columnDefs = columnDefs;\n\n        // always invalidate cache on changing columns, as the column id's for the new columns\n        // could overlap with the old id's, so the cache would return old values for new columns.\n        this.valueCache.expire();\n\n        // NOTE ==================\n        // we should be destroying the existing columns and groups if they exist, for example, the original column\n        // group adds a listener to the columns, it should be also removing the listeners\n        this.autoGroupsNeedBuilding = true;\n\n        const oldPrimaryColumns = this.primaryColumns;\n        const balancedTreeResult = this.columnFactory.createColumnTree(columnDefs, true, oldPrimaryColumns);\n\n        this.primaryColumnTree = balancedTreeResult.columnTree;\n        this.primaryHeaderRowCount = balancedTreeResult.treeDept + 1;\n\n        this.primaryColumns = this.getColumnsFromTree(this.primaryColumnTree);\n\n        this.extractRowGroupColumns(source, oldPrimaryColumns);\n        this.extractPivotColumns(source, oldPrimaryColumns);\n        this.createValueColumns(source, oldPrimaryColumns);\n\n        this.ready = true;\n\n        this.updateGridColumns();\n        this.updateDisplayedColumns(source);\n        this.checkDisplayedVirtualColumns();\n\n        if (this.gridOptionsWrapper.isDeltaColumnMode() && colsPreviouslyExisted) {\n            this.resetColumnState(true, source);\n        }\n\n        const eventEverythingChanged: ColumnEverythingChangedEvent = {\n            type: Events.EVENT_COLUMN_EVERYTHING_CHANGED,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            source: source\n        };\n\n        this.eventService.dispatchEvent(eventEverythingChanged);\n\n        const newColumnsLoadedEvent: NewColumnsLoadedEvent = {\n            type: Events.EVENT_NEW_COLUMNS_LOADED,\n            api: this.gridApi,\n            columnApi: this.columnApi\n        };\n\n        this.eventService.dispatchEvent(newColumnsLoadedEvent);\n\n        this.flexActive = !!_.find(this.getDisplayedCenterColumns(), col => !!col.getFlex());\n    }\n\n    public isAutoRowHeightActive(): boolean {\n        return this.autoRowHeightColumns && this.autoRowHeightColumns.length > 0;\n    }\n\n    public getAllAutoRowHeightCols(): Column[] {\n        return this.autoRowHeightColumns;\n    }\n\n    private setVirtualViewportLeftAndRight(): void {\n        if (this.gridOptionsWrapper.isEnableRtl()) {\n            this.viewportLeft = this.bodyWidth - this.scrollPosition - this.scrollWidth;\n            this.viewportRight = this.bodyWidth - this.scrollPosition;\n        } else {\n            this.viewportLeft = this.scrollPosition;\n            this.viewportRight = this.scrollWidth + this.scrollPosition;\n        }\n    }\n\n    // used by clipboard service, to know what columns to paste into\n    public getDisplayedColumnsStartingAt(column: Column): Column[] {\n        let currentColumn: Column | null = column;\n        const result: Column[] = [];\n\n        while (currentColumn && _.exists(currentColumn)) {\n            result.push(currentColumn);\n            currentColumn = this.getDisplayedColAfter(currentColumn);\n        }\n\n        return result;\n    }\n\n    // checks what columns are currently displayed due to column virtualisation. fires an event\n    // if the list of columns has changed.\n    // + setColumnWidth(), setVirtualViewportPosition(), setColumnDefs(), sizeColumnsToFit()\n    private checkDisplayedVirtualColumns(): void {\n        // check displayCenterColumnTree exists first, as it won't exist when grid is initialising\n        if (!_.exists(this.displayedCenterColumns)) { return; }\n\n        const hashBefore = this.allDisplayedVirtualColumns.map(column => column.getId()).join('#');\n\n        this.updateVirtualSets();\n\n        const hashAfter = this.allDisplayedVirtualColumns.map(column => column.getId()).join('#');\n\n        if (hashBefore !== hashAfter) {\n            const event: VirtualColumnsChangedEvent = {\n                type: Events.EVENT_VIRTUAL_COLUMNS_CHANGED,\n                api: this.gridApi,\n                columnApi: this.columnApi\n            };\n            this.eventService.dispatchEvent(event);\n        }\n    }\n\n    public setVirtualViewportPosition(scrollWidth: number, scrollPosition: number): void {\n        if (scrollWidth !== this.scrollWidth || scrollPosition !== this.scrollPosition || this.bodyWidthDirty) {\n            this.scrollWidth = scrollWidth;\n            this.scrollPosition = scrollPosition;\n            // we need to call setVirtualViewportLeftAndRight() at least once after the body width changes,\n            // as the viewport can stay the same, but in RTL, if body width changes, we need to work out the\n            // virtual columns again\n            this.bodyWidthDirty = true;\n            this.setVirtualViewportLeftAndRight();\n\n            if (this.ready) {\n                this.checkDisplayedVirtualColumns();\n            }\n        }\n    }\n\n    public isPivotMode(): boolean {\n        return this.pivotMode;\n    }\n\n    private isPivotSettingAllowed(pivot: boolean): boolean {\n        if (pivot) {\n            if (this.gridOptionsWrapper.isTreeData()) {\n                console.warn(\"ag-Grid: Pivot mode not available in conjunction Tree Data i.e. 'gridOptions.treeData: true'\");\n                return false;\n            }\n            return true;\n        }\n        return true;\n    }\n\n    public setPivotMode(pivotMode: boolean, source: ColumnEventType = \"api\"): void {\n        if (pivotMode === this.pivotMode) { return; }\n        if (!this.isPivotSettingAllowed(this.pivotMode)) { return; }\n\n        this.pivotMode = pivotMode;\n\n        // we need to update grid columns to cover the scenario where user has groupSuppressAutoColumn=true, as\n        // this means we don't use auto group column UNLESS we are in pivot mode (it's mandatory in pivot mode),\n        // so need to updateGridColumn() to check it autoGroupCol needs to be added / removed\n        this.autoGroupsNeedBuilding = true;\n        this.updateGridColumns();\n\n        this.updateDisplayedColumns(source);\n        const event: ColumnPivotModeChangedEvent = {\n            type: Events.EVENT_COLUMN_PIVOT_MODE_CHANGED,\n            api: this.gridApi,\n            columnApi: this.columnApi\n        };\n\n        this.eventService.dispatchEvent(event);\n    }\n\n    public getSecondaryPivotColumn(pivotKeys: string[], valueColKey: Column | string): Column | null {\n        if (!this.secondaryColumnsPresent) { return null; }\n\n        const valueColumnToFind = this.getPrimaryColumn(valueColKey);\n\n        let foundColumn: Column | null = null;\n\n        if (this.secondaryColumns) {\n            this.secondaryColumns.forEach(column => {\n\n                const thisPivotKeys = column.getColDef().pivotKeys;\n                const pivotValueColumn = column.getColDef().pivotValueColumn;\n\n                const pivotKeyMatches = _.compareArrays(thisPivotKeys, pivotKeys);\n                const pivotValueMatches = pivotValueColumn === valueColumnToFind;\n\n                if (pivotKeyMatches && pivotValueMatches) {\n                    foundColumn = column;\n                }\n            });\n        }\n\n        return foundColumn;\n    }\n\n    private setBeans(@Qualifier('loggerFactory') loggerFactory: LoggerFactory) {\n        this.logger = loggerFactory.create('ColumnController');\n    }\n\n    private setFirstRightAndLastLeftPinned(source: ColumnEventType): void {\n        let lastLeft: Column | null;\n        let firstRight: Column | null;\n\n        if (this.gridOptionsWrapper.isEnableRtl()) {\n            lastLeft = this.displayedLeftColumns ? this.displayedLeftColumns[0] : null;\n            firstRight = this.displayedRightColumns ? _.last(this.displayedRightColumns) : null;\n        } else {\n            lastLeft = this.displayedLeftColumns ? _.last(this.displayedLeftColumns) : null;\n            firstRight = this.displayedRightColumns ? this.displayedRightColumns[0] : null;\n        }\n\n        this.gridColumns.forEach((column: Column) => {\n            column.setLastLeftPinned(column === lastLeft, source);\n            column.setFirstRightPinned(column === firstRight, source);\n        });\n    }\n\n    public autoSizeColumns(keys: (string | Column)[], skipHeader?: boolean, source: ColumnEventType = \"api\"): void {\n        // because of column virtualisation, we can only do this function on columns that are\n        // actually rendered, as non-rendered columns (outside the viewport and not rendered\n        // due to column virtualisation) are not present. this can result in all rendered columns\n        // getting narrowed, which in turn introduces more rendered columns on the RHS which\n        // did not get autosized in the original run, leaving the visible grid with columns on\n        // the LHS sized, but RHS no. so we keep looping through the visible columns until\n        // no more cols are available (rendered) to be resized\n\n        // keep track of which cols we have resized in here\n        const columnsAutosized: Column[] = [];\n        // initialise with anything except 0 so that while loop executes at least once\n        let changesThisTimeAround = -1;\n\n        if (skipHeader == null) {\n            skipHeader = this.gridOptionsWrapper.isSkipHeaderOnAutoSize();\n        }\n\n        while (changesThisTimeAround !== 0) {\n            changesThisTimeAround = 0;\n            this.actionOnGridColumns(keys, (column: Column): boolean => {\n                // if already autosized, skip it\n                if (columnsAutosized.indexOf(column) >= 0) {\n                    return false;\n                }\n                // get how wide this col should be\n                const preferredWidth = this.autoWidthCalculator.getPreferredWidthForColumn(column, skipHeader);\n                // preferredWidth = -1 if this col is not on the screen\n                if (preferredWidth > 0) {\n                    const newWidth = this.normaliseColumnWidth(column, preferredWidth);\n                    column.setActualWidth(newWidth, source);\n                    columnsAutosized.push(column);\n                    changesThisTimeAround++;\n                }\n                return true;\n            }, source);\n        }\n\n        if (columnsAutosized.length) {\n            const event: ColumnResizedEvent = {\n                type: Events.EVENT_COLUMN_RESIZED,\n                columns: columnsAutosized,\n                column: columnsAutosized.length === 1 ? columnsAutosized[0] : null,\n                finished: true,\n                api: this.gridApi,\n                columnApi: this.columnApi,\n                source: \"autosizeColumns\"\n            };\n            this.eventService.dispatchEvent(event);\n        }\n    }\n\n    public autoSizeColumn(key: string | Column | null, skipHeader?: boolean, source: ColumnEventType = \"api\"): void {\n        if (key) {\n            this.autoSizeColumns([key], skipHeader, source);\n        }\n    }\n\n    public autoSizeAllColumns(skipHeader?: boolean, source: ColumnEventType = \"api\"): void {\n        const allDisplayedColumns = this.getAllDisplayedColumns();\n        this.autoSizeColumns(allDisplayedColumns, skipHeader, source);\n    }\n\n    private getColumnsFromTree(rootColumns: OriginalColumnGroupChild[]): Column[] {\n        const result: Column[] = [];\n\n        const recursiveFindColumns = (childColumns: OriginalColumnGroupChild[]): void => {\n            for (let i = 0; i < childColumns.length; i++) {\n                const child = childColumns[i];\n                if (child instanceof Column) {\n                    result.push(child);\n                } else if (child instanceof OriginalColumnGroup) {\n                    recursiveFindColumns(child.getChildren());\n                }\n            }\n        };\n\n        recursiveFindColumns(rootColumns);\n\n        return result;\n    }\n\n    public getAllDisplayedColumnGroups(): ColumnGroupChild[] | null {\n        if (this.displayedLeftColumnTree && this.displayedRightColumnTree && this.displayedCentreColumnTree) {\n            return this.displayedLeftColumnTree\n                .concat(this.displayedCentreColumnTree)\n                .concat(this.displayedRightColumnTree);\n        }\n\n        return null;\n    }\n\n    // + columnSelectPanel\n    public getPrimaryColumnTree(): OriginalColumnGroupChild[] {\n        return this.primaryColumnTree;\n    }\n\n    // + gridPanel -> for resizing the body and setting top margin\n    public getHeaderRowCount(): number {\n        return this.gridHeaderRowCount;\n    }\n\n    // + headerRenderer -> setting pinned body width\n    public getLeftDisplayedColumnGroups(): ColumnGroupChild[] {\n        return this.displayedLeftColumnTree;\n    }\n\n    // + headerRenderer -> setting pinned body width\n    public getRightDisplayedColumnGroups(): ColumnGroupChild[] {\n        return this.displayedRightColumnTree;\n    }\n\n    // + headerRenderer -> setting pinned body width\n    public getCenterDisplayedColumnGroups(): ColumnGroupChild[] {\n        return this.displayedCentreColumnTree;\n    }\n\n    public getDisplayedColumnGroups(type: string): ColumnGroupChild[] {\n        switch (type) {\n            case Constants.PINNED_LEFT:\n                return this.getLeftDisplayedColumnGroups();\n            case Constants.PINNED_RIGHT:\n                return this.getRightDisplayedColumnGroups();\n            default:\n                return this.getCenterDisplayedColumnGroups();\n        }\n    }\n\n    // gridPanel -> ensureColumnVisible\n    public isColumnDisplayed(column: Column): boolean {\n        return this.getAllDisplayedColumns().indexOf(column) >= 0;\n    }\n\n    // + csvCreator\n    public getAllDisplayedColumns(): Column[] {\n        return this.allDisplayedColumns;\n    }\n\n    public getAllDisplayedVirtualColumns(): Column[] {\n        return this.allDisplayedVirtualColumns;\n    }\n\n    public getDisplayedLeftColumnsForRow(rowNode: RowNode): Column[] {\n        if (!this.colSpanActive) {\n            return this.displayedLeftColumns;\n        }\n\n        return this.getDisplayedColumnsForRow(rowNode, this.displayedLeftColumns);\n    }\n\n    public getDisplayedRightColumnsForRow(rowNode: RowNode): Column[] {\n        if (!this.colSpanActive) {\n            return this.displayedRightColumns;\n        }\n\n        return this.getDisplayedColumnsForRow(rowNode, this.displayedRightColumns);\n    }\n\n    private getDisplayedColumnsForRow(\n            rowNode: RowNode, displayedColumns: Column[],\n            filterCallback?: (column: Column) => boolean,\n            emptySpaceBeforeColumn?: (column: Column) => boolean\n        ): Column[] {\n\n        const result: Column[] = [];\n        let lastConsideredCol: Column | null = null;\n\n        for (let i = 0; i < displayedColumns.length; i++) {\n            const col = displayedColumns[i];\n            const maxAllowedColSpan = displayedColumns.length - i;\n            const colSpan = Math.min(col.getColSpan(rowNode), maxAllowedColSpan);\n            const columnsToCheckFilter: Column[] = [col];\n\n            if (colSpan > 1) {\n                const colsToRemove = colSpan - 1;\n\n                for (let j = 1; j <= colsToRemove; j++) {\n                    columnsToCheckFilter.push(displayedColumns[i + j]);\n                }\n\n                i += colsToRemove;\n            }\n\n            // see which cols we should take out for column virtualisation\n            let filterPasses: boolean;\n\n            if (filterCallback) {\n                // if user provided a callback, means some columns may not be in the viewport.\n                // the user will NOT provide a callback if we are talking about pinned areas,\n                // as pinned areas have no horizontal scroll and do not virtualise the columns.\n                // if lots of columns, that means column spanning, and we set filterPasses = true\n                // if one or more of the columns spanned pass the filter.\n                filterPasses = false;\n                columnsToCheckFilter.forEach(colForFilter => {\n                    if (filterCallback(colForFilter)) { filterPasses = true; }\n                });\n            } else {\n                filterPasses = true;\n            }\n\n            if (filterPasses) {\n                if (result.length === 0 && lastConsideredCol) {\n                    const gapBeforeColumn = emptySpaceBeforeColumn ? emptySpaceBeforeColumn(col) : false;\n                    if (gapBeforeColumn) {\n                        result.push(lastConsideredCol);\n                    }\n                }\n                result.push(col);\n            }\n\n            lastConsideredCol = col;\n        }\n\n        return result;\n    }\n\n    // + rowRenderer\n    // if we are not column spanning, this just returns back the virtual centre columns,\n    // however if we are column spanning, then different rows can have different virtual\n    // columns, so we have to work out the list for each individual row.\n    public getAllDisplayedCenterVirtualColumnsForRow(rowNode: RowNode): Column[] {\n        if (!this.colSpanActive) {\n            return this.allDisplayedCenterVirtualColumns;\n        }\n\n        const emptySpaceBeforeColumn = (col: Column) => col.getLeft() > this.viewportLeft;\n\n        // if doing column virtualisation, then we filter based on the viewport.\n        const filterCallback = this.suppressColumnVirtualisation ? null : this.isColumnInViewport.bind(this);\n\n        return this.getDisplayedColumnsForRow(\n            rowNode,\n            this.displayedCenterColumns,\n            filterCallback,\n            emptySpaceBeforeColumn\n        );\n    }\n\n    private isColumnInViewport(col: Column): boolean {\n        const columnLeft = col.getLeft();\n        const columnRight = col.getLeft() + col.getActualWidth();\n\n        // adding 200 for buffer size, so some cols off viewport are rendered.\n        // this helps horizontal scrolling so user rarely sees white space (unless\n        // they scroll horizontally fast). however we are conservative, as the more\n        // buffer the slower the vertical redraw speed\n        const leftBounds = this.viewportLeft - 200;\n        const rightBounds = this.viewportRight + 200;\n\n        const columnToMuchLeft = columnLeft < leftBounds && columnRight < leftBounds;\n        const columnToMuchRight = columnLeft > rightBounds && columnRight > rightBounds;\n\n        return !columnToMuchLeft && !columnToMuchRight;\n    }\n\n    // used by:\n    // + angularGrid -> setting pinned body width\n    // note: this should be cached\n    public getPinnedLeftContainerWidth() {\n        return this.getWidthOfColsInList(this.displayedLeftColumns);\n    }\n\n    // note: this should be cached\n    public getPinnedRightContainerWidth() {\n        return this.getWidthOfColsInList(this.displayedRightColumns);\n    }\n\n    public updatePrimaryColumnList(\n            keys: (string | Column)[] | null,\n            masterList: Column[],\n            actionIsAdd: boolean,\n            columnCallback: (column: Column) => void,\n            eventType: string,\n            source: ColumnEventType = \"api\"\n        ) {\n\n        if (!keys || _.missingOrEmpty(keys)) { return; }\n\n        let atLeastOne = false;\n\n        keys.forEach(key => {\n            const columnToAdd = this.getPrimaryColumn(key);\n            if (!columnToAdd) { return; }\n\n            if (actionIsAdd) {\n                if (masterList.indexOf(columnToAdd) >= 0) { return; }\n                masterList.push(columnToAdd);\n            } else {\n                if (masterList.indexOf(columnToAdd) < 0) { return; }\n                _.removeFromArray(masterList, columnToAdd);\n            }\n\n            columnCallback(columnToAdd);\n            atLeastOne = true;\n        });\n\n        if (!atLeastOne) { return; }\n\n        if (this.autoGroupsNeedBuilding) {\n            this.updateGridColumns();\n        }\n\n        this.updateDisplayedColumns(source);\n\n        const event: ColumnEvent = {\n            type: eventType,\n            columns: masterList,\n            column: masterList.length === 1 ? masterList[0] : null,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            source: source\n        };\n\n        this.eventService.dispatchEvent(event);\n    }\n\n    public setRowGroupColumns(colKeys: (string | Column)[], source: ColumnEventType = \"api\"): void {\n        this.autoGroupsNeedBuilding = true;\n        this.setPrimaryColumnList(colKeys, this.rowGroupColumns,\n            Events.EVENT_COLUMN_ROW_GROUP_CHANGED,\n            this.setRowGroupActive.bind(this),\n            source);\n    }\n\n    private setRowGroupActive(active: boolean, column: Column, source: ColumnEventType): void {\n        if (active === column.isRowGroupActive()) { return; }\n\n        column.setRowGroupActive(active, source);\n\n        if (!active && !this.gridOptionsWrapper.isSuppressMakeColumnVisibleAfterUnGroup()) {\n            column.setVisible(true, source);\n        }\n    }\n\n    public addRowGroupColumn(key: string | Column | null, source: ColumnEventType = \"api\"): void {\n        if (key) { this.addRowGroupColumns([key], source); }\n    }\n\n    public addRowGroupColumns(keys: (string | Column)[], source: ColumnEventType = \"api\"): void {\n        this.autoGroupsNeedBuilding = true;\n        this.updatePrimaryColumnList(keys, this.rowGroupColumns, true,\n            this.setRowGroupActive.bind(this, true),\n            Events.EVENT_COLUMN_ROW_GROUP_CHANGED,\n            source);\n    }\n\n    public removeRowGroupColumns(keys: (string | Column)[] | null, source: ColumnEventType = \"api\"): void {\n        this.autoGroupsNeedBuilding = true;\n        this.updatePrimaryColumnList(keys, this.rowGroupColumns, false,\n            this.setRowGroupActive.bind(this, false),\n            Events.EVENT_COLUMN_ROW_GROUP_CHANGED,\n            source);\n    }\n\n    public removeRowGroupColumn(key: string | Column | null, source: ColumnEventType = \"api\"): void {\n        if (key) { this.removeRowGroupColumns([key], source); }\n    }\n\n    public addPivotColumns(keys: (string | Column)[], source: ColumnEventType = \"api\"): void {\n        this.updatePrimaryColumnList(keys, this.pivotColumns, true,\n            column => column.setPivotActive(true, source),\n            Events.EVENT_COLUMN_PIVOT_CHANGED, source);\n    }\n\n    public setPivotColumns(colKeys: (string | Column)[], source: ColumnEventType = \"api\"): void {\n        this.setPrimaryColumnList(colKeys, this.pivotColumns, Events.EVENT_COLUMN_PIVOT_CHANGED,\n            (added: boolean, column: Column) => {\n                column.setPivotActive(added, source);\n            }, source\n        );\n    }\n\n    public addPivotColumn(key: string | Column, source: ColumnEventType = \"api\"): void {\n        this.addPivotColumns([key], source);\n    }\n\n    public removePivotColumns(keys: (string | Column)[], source: ColumnEventType = \"api\"): void {\n        this.updatePrimaryColumnList(\n            keys,\n            this.pivotColumns,\n            false,\n            column => column.setPivotActive(false, source),\n            Events.EVENT_COLUMN_PIVOT_CHANGED,\n            source\n        );\n    }\n\n    public removePivotColumn(key: string | Column, source: ColumnEventType = \"api\"): void {\n        this.removePivotColumns([key], source);\n    }\n\n    private setPrimaryColumnList(\n            colKeys: (string | Column)[],\n            masterList: Column[],\n            eventName: string,\n            columnCallback: (added: boolean, column: Column) => void,\n            source: ColumnEventType\n        ): void {\n\n        masterList.length = 0;\n\n        if (_.exists(colKeys)) {\n            colKeys.forEach(key => {\n                const column = this.getPrimaryColumn(key);\n                if (column) {\n                    masterList.push(column);\n                }\n            });\n        }\n\n        this.primaryColumns.forEach(column => {\n            const added = masterList.indexOf(column) >= 0;\n            columnCallback(added, column);\n        });\n\n        if (this.autoGroupsNeedBuilding) {\n            this.updateGridColumns();\n        }\n\n        this.updateDisplayedColumns(source);\n\n        const event: ColumnEvent = {\n            type: eventName,\n            columns: masterList,\n            column: masterList.length === 1 ? masterList[0] : null,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            source: source\n        };\n\n        this.eventService.dispatchEvent(event);\n    }\n\n    public setValueColumns(colKeys: (string | Column)[], source: ColumnEventType = \"api\"): void {\n        this.setPrimaryColumnList(colKeys, this.valueColumns,\n            Events.EVENT_COLUMN_VALUE_CHANGED,\n            this.setValueActive.bind(this),\n            source\n        );\n    }\n\n    private setValueActive(active: boolean, column: Column, source: ColumnEventType): void {\n        if (active === column.isValueActive()) { return; }\n\n        column.setValueActive(active, source);\n\n        if (active && !column.getAggFunc()) {\n            const defaultAggFunc = this.aggFuncService.getDefaultAggFunc(column);\n            column.setAggFunc(defaultAggFunc);\n        }\n    }\n\n    public addValueColumns(keys: (string | Column)[], source: ColumnEventType = \"api\"): void {\n        this.updatePrimaryColumnList(keys, this.valueColumns, true,\n            this.setValueActive.bind(this, true),\n            Events.EVENT_COLUMN_VALUE_CHANGED,\n            source\n        );\n    }\n\n    public addValueColumn(colKey: (string | Column) | null | undefined, source: ColumnEventType = \"api\"): void {\n        if (colKey) { this.addValueColumns([colKey], source); }\n    }\n\n    public removeValueColumn(colKey: (string | Column), source: ColumnEventType = \"api\"): void {\n        this.removeValueColumns([colKey], source);\n    }\n\n    public removeValueColumns(keys: (string | Column)[], source: ColumnEventType = \"api\"): void {\n        this.updatePrimaryColumnList(keys, this.valueColumns, false,\n            this.setValueActive.bind(this, false),\n            Events.EVENT_COLUMN_VALUE_CHANGED,\n            source\n        );\n    }\n\n    // returns the width we can set to this col, taking into consideration min and max widths\n    private normaliseColumnWidth(column: Column, newWidth: number): number {\n        if (newWidth < column.getMinWidth()) {\n            newWidth = column.getMinWidth();\n        }\n\n        if (column.isGreaterThanMax(newWidth)) {\n            newWidth = column.getMaxWidth();\n        }\n\n        return newWidth;\n    }\n\n    private getPrimaryOrGridColumn(key: string | Column): Column | null {\n        const column = this.getPrimaryColumn(key);\n\n        return column || this.getGridColumn(key);\n    }\n\n    public setColumnWidth(\n            key: string | Column, // @key - the column who's size we want to change\n            newWidth: number, // @newWidth - width in pixels\n            shiftKey: boolean, // @takeFromAdjacent - if user has 'shift' pressed, then pixels are taken from adjacent column\n            finished: boolean, // @finished - ends up in the event, tells the user if more events are to come\n            source: ColumnEventType = \"api\"\n        ): void {\n\n        const col = this.getPrimaryOrGridColumn(key);\n\n        if (!col) { return; }\n\n        const sets: ColumnResizeSet[] = [];\n\n        sets.push({\n            width: newWidth,\n            ratios: [1],\n            columns: [col]\n        });\n\n        // if user wants to do shift resize by default, then we invert the shift operation\n        const defaultIsShift = this.gridOptionsWrapper.getColResizeDefault() === 'shift';\n\n        if (defaultIsShift) {\n            shiftKey = !shiftKey;\n        }\n\n        if (shiftKey) {\n            const otherCol = this.getDisplayedColAfter(col);\n            if (!otherCol) { return; }\n\n            const widthDiff = col.getActualWidth() - newWidth;\n            const otherColWidth = otherCol.getActualWidth() + widthDiff;\n\n            sets.push({\n                width: otherColWidth,\n                ratios: [1],\n                columns: [otherCol]\n            });\n        }\n\n        this.resizeColumnSets(sets, finished, source);\n\n        if (this.flexActive) {\n            this.refreshFlexedColumns();\n        }\n    }\n\n    private checkMinAndMaxWidthsForSet(columnResizeSet: ColumnResizeSet): boolean {\n        const {columns, width} = columnResizeSet;\n\n        // every col has a min width, so sum them all up and see if we have enough room\n        // for all the min widths\n        let minWidthAccumulated = 0;\n        let maxWidthAccumulated = 0;\n        let maxWidthActive = true;\n\n        columns.forEach(col => {\n            minWidthAccumulated += col.getMinWidth();\n\n            if (col.getMaxWidth() > 0) {\n                maxWidthAccumulated += col.getMaxWidth();\n            } else {\n                // if at least one columns has no max width, it means the group of columns\n                // then has no max width, as at least one column can take as much width as possible\n                maxWidthActive = false;\n            }\n        });\n\n        const minWidthPasses = width >= minWidthAccumulated;\n        const maxWidthPasses = !maxWidthActive || (width <= maxWidthAccumulated);\n\n        return minWidthPasses && maxWidthPasses;\n    }\n\n    // method takes sets of columns and resizes them. either all sets will be resized, or nothing\n    // be resized. this is used for example when user tries to resize a group and holds shift key,\n    // then both the current group (grows), and the adjacent group (shrinks), will get resized,\n    // so that's two sets for this method.\n    public resizeColumnSets(\n            resizeSets: ColumnResizeSet[],\n            finished: boolean,\n            source: ColumnEventType\n        ): void {\n\n        const passMinMaxCheck = _.every(resizeSets, this.checkMinAndMaxWidthsForSet.bind(this));\n\n        if (!passMinMaxCheck) {\n            // even though we are not going to resize beyond min/max size, we still need to raise event when finished\n            if (finished) {\n                const columns = resizeSets && resizeSets.length > 0 ? resizeSets[0].columns : null;\n                const event: ColumnResizedEvent = {\n                    type: Events.EVENT_COLUMN_RESIZED,\n                    columns: columns,\n                    column: columns && columns.length === 1 ? columns[0] : null,\n                    finished: finished,\n                    api: this.gridApi,\n                    columnApi: this.columnApi,\n                    source: source\n                };\n                this.eventService.dispatchEvent(event);\n            }\n\n            return; // don't resize!\n        }\n\n        const changedCols: Column[] = [];\n        const allCols: Column[] = [];\n\n        resizeSets.forEach(set => {\n            const {width, columns, ratios} = set;\n\n            // keep track of pixels used, and last column gets the remaining,\n            // to cater for rounding errors, and min width adjustments\n            const newWidths: { [colId: string]: number } = {};\n            const finishedCols: { [colId: string]: boolean } = {};\n\n            columns.forEach(col => allCols.push(col));\n\n            // the loop below goes through each col. if a col exceeds it's min/max width,\n            // it then gets set to its min/max width and the column is removed marked as 'finished'\n            // and the calculation is done again leaving this column out. take for example columns\n            // {A, width: 50, maxWidth: 100}\n            // {B, width: 50}\n            // {C, width: 50}\n            // and then the set is set to width 600 - on the first pass the grid tries to set each column\n            // to 200. it checks A and sees 200 > 100 and so sets the width to 100. col A is then marked\n            // as 'finished' and the calculation is done again with the remaining cols B and C, which end up\n            // splitting the remaining 500 pixels.\n            let finishedColsGrew = true;\n            let loopCount = 0;\n\n            while (finishedColsGrew) {\n                loopCount++;\n                if (loopCount > 1000) {\n                    // this should never happen, but in the future, someone might introduce a bug here,\n                    // so we stop the browser from hanging and report bug properly\n                    console.error('ag-Grid: infinite loop in resizeColumnSets');\n                    break;\n                }\n\n                finishedColsGrew = false;\n\n                const subsetCols: Column[] = [];\n                const subsetRatios: number[] = [];\n                let subsetRatioTotal = 0;\n                let pixelsToDistribute = width;\n\n                columns.forEach((col: Column, index: number) => {\n                    const thisColFinished = finishedCols[col.getId()];\n                    if (thisColFinished) {\n                        pixelsToDistribute -= newWidths[col.getId()];\n                    } else {\n                        subsetCols.push(col);\n                        const ratioThisCol = ratios[index];\n                        subsetRatioTotal += ratioThisCol;\n                        subsetRatios.push(ratioThisCol);\n                    }\n                });\n\n                // because we are not using all of the ratios (cols can be missing),\n                // we scale the ratio. if all columns are included, then subsetRatioTotal=1,\n                // and so the ratioScale will be 1.\n                const ratioScale = 1 / subsetRatioTotal;\n\n                subsetCols.forEach((col: Column, index: number) => {\n                    const lastCol = index === (subsetCols.length - 1);\n                    let colNewWidth: number;\n\n                    if (lastCol) {\n                        colNewWidth = pixelsToDistribute;\n                    } else {\n                        colNewWidth = Math.round(ratios[index] * width * ratioScale);\n                        pixelsToDistribute -= colNewWidth;\n                    }\n\n                    if (colNewWidth < col.getMinWidth()) {\n                        colNewWidth = col.getMinWidth();\n                        finishedCols[col.getId()] = true;\n                        finishedColsGrew = true;\n                    } else if (col.getMaxWidth() > 0 && colNewWidth > col.getMaxWidth()) {\n                        colNewWidth = col.getMaxWidth();\n                        finishedCols[col.getId()] = true;\n                        finishedColsGrew = true;\n                    }\n\n                    newWidths[col.getId()] = colNewWidth;\n                });\n            }\n\n            columns.forEach(col => {\n                const newWidth = newWidths[col.getId()];\n                if (col.getActualWidth() !== newWidth) {\n                    col.setActualWidth(newWidth, source);\n                    changedCols.push(col);\n                }\n            });\n        });\n\n        // if no cols changed, then no need to update more or send event.\n        const atLeastOneColChanged = changedCols.length > 0;\n\n        if (atLeastOneColChanged) {\n            this.setLeftValues(source);\n            this.updateBodyWidths();\n            this.checkDisplayedVirtualColumns();\n        }\n\n        // check for change first, to avoid unnecessary firing of events\n        // however we always fire 'finished' events. this is important\n        // when groups are resized, as if the group is changing slowly,\n        // eg 1 pixel at a time, then each change will fire change events\n        // in all the columns in the group, but only one with get the pixel.\n        if (atLeastOneColChanged || finished) {\n            const event: ColumnResizedEvent = {\n                type: Events.EVENT_COLUMN_RESIZED,\n                columns: allCols,\n                column: allCols.length === 1 ? allCols[0] : null,\n                finished: finished,\n                api: this.gridApi,\n                columnApi: this.columnApi,\n                source: source\n            };\n            this.eventService.dispatchEvent(event);\n        }\n    }\n\n    public setColumnAggFunc(column: Column | null | undefined, aggFunc: string, source: ColumnEventType = \"api\"): void {\n        if (!column) { return; }\n\n        column.setAggFunc(aggFunc);\n        const event: ColumnValueChangedEvent = {\n            type: Events.EVENT_COLUMN_VALUE_CHANGED,\n            columns: [column],\n            column: column,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            source: source\n        };\n        this.eventService.dispatchEvent(event);\n    }\n\n    public moveRowGroupColumn(fromIndex: number, toIndex: number, source: ColumnEventType = \"api\"): void {\n        const column = this.rowGroupColumns[fromIndex];\n\n        this.rowGroupColumns.splice(fromIndex, 1);\n        this.rowGroupColumns.splice(toIndex, 0, column);\n\n        const event: ColumnRowGroupChangedEvent = {\n            type: Events.EVENT_COLUMN_ROW_GROUP_CHANGED,\n            columns: this.rowGroupColumns,\n            column: this.rowGroupColumns.length === 1 ? this.rowGroupColumns[0] : null,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            source: source\n        };\n\n        this.eventService.dispatchEvent(event);\n    }\n\n    public moveColumns(columnsToMoveKeys: (string | Column)[], toIndex: number, source: ColumnEventType = \"api\"): void {\n        this.columnAnimationService.start();\n\n        if (toIndex > this.gridColumns.length - columnsToMoveKeys.length) {\n            console.warn('ag-Grid: tried to insert columns in invalid location, toIndex = ' + toIndex);\n            console.warn('ag-Grid: remember that you should not count the moving columns when calculating the new index');\n            return;\n        }\n\n        // we want to pull all the columns out first and put them into an ordered list\n        const columnsToMove = this.getGridColumns(columnsToMoveKeys);\n        const failedRules = !this.doesMovePassRules(columnsToMove, toIndex);\n\n        if (failedRules) { return; }\n\n        _.moveInArray(this.gridColumns, columnsToMove, toIndex);\n        this.updateDisplayedColumns(source);\n\n        const event: ColumnMovedEvent = {\n            type: Events.EVENT_COLUMN_MOVED,\n            columns: columnsToMove,\n            column: columnsToMove.length === 1 ? columnsToMove[0] : null,\n            toIndex: toIndex,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            source: source\n        };\n\n        this.eventService.dispatchEvent(event);\n        this.columnAnimationService.finish();\n    }\n\n    public doesMovePassRules(columnsToMove: Column[], toIndex: number): boolean {\n        // make a copy of what the grid columns would look like after the move\n        const proposedColumnOrder = this.gridColumns.slice();\n        _.moveInArray(proposedColumnOrder, columnsToMove, toIndex);\n\n        // then check that the new proposed order of the columns passes all rules\n        if (!this.doesMovePassMarryChildren(proposedColumnOrder)) {\n            return false;\n        }\n\n        if (!this.doesMovePassLockedPositions(proposedColumnOrder)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    public doesMovePassLockedPositions(proposedColumnOrder: Column[]): boolean {\n        let foundNonLocked = false;\n        let rulePassed = true;\n\n        // go though the cols, see if any non-locked appear before any locked\n        proposedColumnOrder.forEach(col => {\n            if (col.getColDef().lockPosition) {\n                if (foundNonLocked) {\n                    rulePassed = false;\n                }\n            } else {\n                foundNonLocked = true;\n            }\n        });\n\n        return rulePassed;\n    }\n\n    public doesMovePassMarryChildren(allColumnsCopy: Column[]): boolean {\n        let rulePassed = true;\n\n        this.columnUtils.depthFirstOriginalTreeSearch(null, this.gridBalancedTree, child => {\n            if (!(child instanceof OriginalColumnGroup)) { return; }\n\n            const columnGroup = child as OriginalColumnGroup;\n            const marryChildren = columnGroup.getColGroupDef() && columnGroup.getColGroupDef().marryChildren;\n\n            if (!marryChildren) { return; }\n\n            const newIndexes: number[] = [];\n            columnGroup.getLeafColumns().forEach(col => {\n                const newColIndex = allColumnsCopy.indexOf(col);\n                newIndexes.push(newColIndex);\n            });\n\n            const maxIndex = Math.max.apply(Math, newIndexes);\n            const minIndex = Math.min.apply(Math, newIndexes);\n\n            // spread is how far the first column in this group is away from the last column\n            const spread = maxIndex - minIndex;\n            const maxSpread = columnGroup.getLeafColumns().length - 1;\n\n            // if the columns\n            if (spread > maxSpread) {\n                rulePassed = false;\n            }\n\n            // console.log(`maxIndex = ${maxIndex}, minIndex = ${minIndex}, spread = ${spread}, maxSpread = ${maxSpread}, fail = ${spread > (count-1)}`)\n            // console.log(allColumnsCopy.map( col => col.getColDef().field).join(','));\n        });\n\n        return rulePassed;\n    }\n\n    public moveColumn(key: string | Column, toIndex: number, source: ColumnEventType = \"api\") {\n        this.moveColumns([key], toIndex, source);\n    }\n\n    public moveColumnByIndex(fromIndex: number, toIndex: number, source: ColumnEventType = \"api\"): void {\n        const column = this.gridColumns[fromIndex];\n        this.moveColumn(column, toIndex, source);\n    }\n\n    // used by:\n    // + angularGrid -> for setting body width\n    // + rowController -> setting main row widths (when inserting and resizing)\n    // need to cache this\n    public getBodyContainerWidth(): number {\n        return this.bodyWidth;\n    }\n\n    public getContainerWidth(pinned: string): number {\n        switch (pinned) {\n            case Constants.PINNED_LEFT:\n                return this.leftWidth;\n            case Constants.PINNED_RIGHT:\n                return this.rightWidth;\n            default:\n                return this.bodyWidth;\n        }\n    }\n\n    // after setColumnWidth or updateGroupsAndDisplayedColumns\n    private updateBodyWidths(): void {\n        const newBodyWidth = this.getWidthOfColsInList(this.displayedCenterColumns);\n        const newLeftWidth = this.getWidthOfColsInList(this.displayedLeftColumns);\n        const newRightWidth = this.getWidthOfColsInList(this.displayedRightColumns);\n\n        // this is used by virtual col calculation, for RTL only, as a change to body width can impact displayed\n        // columns, due to RTL inverting the y coordinates\n        this.bodyWidthDirty = this.bodyWidth !== newBodyWidth;\n\n        const atLeastOneChanged = this.bodyWidth !== newBodyWidth || this.leftWidth !== newLeftWidth || this.rightWidth !== newRightWidth;\n\n        if (atLeastOneChanged) {\n            this.bodyWidth = newBodyWidth;\n            this.leftWidth = newLeftWidth;\n            this.rightWidth = newRightWidth;\n            // when this fires, it is picked up by the gridPanel, which ends up in\n            // gridPanel calling setWidthAndScrollPosition(), which in turn calls setVirtualViewportPosition()\n            const event: DisplayedColumnsWidthChangedEvent = {\n                type: Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED,\n                api: this.gridApi,\n                columnApi: this.columnApi\n            };\n            this.eventService.dispatchEvent(event);\n        }\n    }\n\n    // + rowController\n    public getValueColumns(): Column[] {\n        return this.valueColumns ? this.valueColumns : [];\n    }\n\n    // + rowController\n    public getPivotColumns(): Column[] {\n        return this.pivotColumns ? this.pivotColumns : [];\n    }\n\n    // + clientSideRowModel\n    public isPivotActive(): boolean {\n        return this.pivotColumns && this.pivotColumns.length > 0 && this.pivotMode;\n    }\n\n    // + toolPanel\n    public getRowGroupColumns(): Column[] {\n        return this.rowGroupColumns ? this.rowGroupColumns : [];\n    }\n\n    // + rowController -> while inserting rows\n    public getDisplayedCenterColumns(): Column[] {\n        return this.displayedCenterColumns;\n    }\n\n    // + rowController -> while inserting rows\n    public getDisplayedLeftColumns(): Column[] {\n        return this.displayedLeftColumns;\n    }\n\n    public getDisplayedRightColumns(): Column[] {\n        return this.displayedRightColumns;\n    }\n\n    public getDisplayedColumns(type: string): Column[] {\n        switch (type) {\n            case Constants.PINNED_LEFT:\n                return this.getDisplayedLeftColumns();\n            case Constants.PINNED_RIGHT:\n                return this.getDisplayedRightColumns();\n            default:\n                return this.getDisplayedCenterColumns();\n        }\n    }\n\n    // used by:\n    // + clientSideRowController -> sorting, building quick filter text\n    // + headerRenderer -> sorting (clearing icon)\n    public getAllPrimaryColumns(): Column[] | null {\n        return this.primaryColumns ? this.primaryColumns.slice() : null;\n    }\n\n    public getSecondaryColumns(): Column[] | null {\n        return this.secondaryColumns ? this.secondaryColumns.slice() : null;\n    }\n\n    public getAllColumnsForQuickFilter(): Column[] {\n        return this.columnsForQuickFilter;\n    }\n\n    // + moveColumnController\n    public getAllGridColumns(): Column[] {\n        return this.gridColumns;\n    }\n\n    public isEmpty(): boolean {\n        return _.missingOrEmpty(this.gridColumns);\n    }\n\n    public isRowGroupEmpty(): boolean {\n        return _.missingOrEmpty(this.rowGroupColumns);\n    }\n\n    public setColumnVisible(key: string | Column, visible: boolean, source: ColumnEventType = \"api\"): void {\n        this.setColumnsVisible([key], visible, source);\n    }\n\n    public setColumnsVisible(keys: (string | Column)[], visible: boolean, source: ColumnEventType = \"api\"): void {\n        this.columnAnimationService.start();\n\n        this.actionOnGridColumns(keys, (column: Column): boolean => {\n            if (column.isVisible() !== visible) {\n                column.setVisible(visible, source);\n                return true;\n            }\n            return false;\n        }, source, () => {\n            const event: ColumnVisibleEvent = {\n                type: Events.EVENT_COLUMN_VISIBLE,\n                visible: visible,\n                column: null,\n                columns: null,\n                api: this.gridApi,\n                columnApi: this.columnApi,\n                source: source\n            };\n            return event;\n        });\n        this.columnAnimationService.finish();\n    }\n\n    public setColumnPinned(key: string | Column | null, pinned: string | boolean | null, source: ColumnEventType = \"api\"): void {\n        if (key) {\n            this.setColumnsPinned([key], pinned, source);\n        }\n    }\n\n    public setColumnsPinned(keys: (string | Column)[], pinned: string | boolean | null, source: ColumnEventType = \"api\"): void {\n        if (this.gridOptionsWrapper.getDomLayout() === 'print') {\n            console.warn(`Changing the column pinning status is not allowed with domLayout='print'`);\n            return;\n        }\n        this.columnAnimationService.start();\n\n        let actualPinned: string | null;\n        if (pinned === true || pinned === Constants.PINNED_LEFT) {\n            actualPinned = Constants.PINNED_LEFT;\n        } else if (pinned === Constants.PINNED_RIGHT) {\n            actualPinned = Constants.PINNED_RIGHT;\n        } else {\n            actualPinned = null;\n        }\n\n        this.actionOnGridColumns(keys, (col: Column): boolean => {\n            if (col.getPinned() !== actualPinned) {\n                col.setPinned(actualPinned);\n                return true;\n            }\n            return false;\n        }, source, () => {\n            const event: ColumnPinnedEvent = {\n                type: Events.EVENT_COLUMN_PINNED,\n                pinned: actualPinned,\n                column: null,\n                columns: null,\n                api: this.gridApi,\n                columnApi: this.columnApi,\n                source: source\n            };\n            return event;\n        });\n\n        this.columnAnimationService.finish();\n    }\n\n    // does an action on a set of columns. provides common functionality for looking up the\n    // columns based on key, getting a list of effected columns, and then updated the event\n    // with either one column (if it was just one col) or a list of columns\n    // used by: autoResize, setVisible, setPinned\n    private actionOnGridColumns(// the column keys this action will be on\n        keys: (string | Column)[],\n        // the action to do - if this returns false, the column was skipped\n        // and won't be included in the event\n        action: (column: Column) => boolean,\n        // should return back a column event of the right type\n        source: ColumnEventType,\n        createEvent?: () => ColumnEvent): void {\n\n        if (_.missingOrEmpty(keys)) { return; }\n\n        const updatedColumns: Column[] = [];\n\n        keys.forEach((key: string | Column) => {\n            const column = this.getGridColumn(key);\n            if (!column) { return; }\n\n            // need to check for false with type (ie !== instead of !=)\n            // as not returning anything (undefined) would also be false\n            const resultOfAction = action(column);\n            if (resultOfAction !== false) {\n                updatedColumns.push(column);\n            }\n        });\n\n        if (!updatedColumns.length) { return; }\n\n        this.updateDisplayedColumns(source);\n\n        if (_.exists(createEvent) && createEvent) {\n            const event = createEvent();\n\n            event.columns = updatedColumns;\n            event.column = updatedColumns.length === 1 ? updatedColumns[0] : null;\n\n            this.eventService.dispatchEvent(event);\n        }\n    }\n\n    public getDisplayedColBefore(col: Column): Column | null {\n        const allDisplayedColumns = this.getAllDisplayedColumns();\n        const oldIndex = allDisplayedColumns.indexOf(col);\n\n        if (oldIndex > 0) {\n            return allDisplayedColumns[oldIndex - 1];\n        }\n\n        return null;\n    }\n\n    // used by:\n    // + rowRenderer -> for navigation\n    public getDisplayedColAfter(col: Column): Column | null {\n        const allDisplayedColumns = this.getAllDisplayedColumns();\n        const oldIndex = allDisplayedColumns.indexOf(col);\n\n        if (oldIndex < (allDisplayedColumns.length - 1)) {\n            return allDisplayedColumns[oldIndex + 1];\n        }\n\n        return null;\n    }\n\n    public getDisplayedGroupAfter(columnGroup: ColumnGroup): ColumnGroup | null {\n        // pick one col in this group at random\n        let col: Column | null = columnGroup.getDisplayedLeafColumns()[0];\n        const requiredLevel = columnGroup.getOriginalColumnGroup().getLevel();\n\n        while (true) {\n            // keep moving to the next col, until we get to another group\n            col = this.getDisplayedColAfter(col);\n\n            // if no col after, means no group after\n            if (!col) { return null; }\n\n            // get group at same level as the one we are looking for\n            let groupPointer = col.getParent();\n            while (groupPointer.getOriginalColumnGroup().getLevel() !== requiredLevel) {\n                groupPointer = groupPointer.getParent();\n            }\n\n            if (groupPointer !== columnGroup) {\n                return groupPointer;\n            }\n        }\n    }\n\n    public isPinningLeft(): boolean {\n        return this.displayedLeftColumns.length > 0;\n    }\n\n    public isPinningRight(): boolean {\n        return this.displayedRightColumns.length > 0;\n    }\n\n    public getPrimaryAndSecondaryAndAutoColumns(): Column[] {\n        const result = this.primaryColumns ? this.primaryColumns.slice(0) : [];\n\n        if (this.groupAutoColumns && _.exists(this.groupAutoColumns)) {\n            this.groupAutoColumns.forEach(col => result.push(col));\n        }\n\n        if (this.secondaryColumnsPresent && this.secondaryColumns) {\n            this.secondaryColumns.forEach(column => result.push(column));\n        }\n\n        return result;\n    }\n\n    private createStateItemFromColumn(column: Column): ColumnState {\n        const rowGroupIndex = column.isRowGroupActive() ? this.rowGroupColumns.indexOf(column) : null;\n        const pivotIndex = column.isPivotActive() ? this.pivotColumns.indexOf(column) : null;\n        const aggFunc = column.isValueActive() ? column.getAggFunc() : null;\n\n        return {\n            colId: column.getColId(),\n            hide: !column.isVisible(),\n            aggFunc,\n            width: column.getActualWidth(),\n            pivotIndex: pivotIndex,\n            pinned: column.getPinned(),\n            rowGroupIndex\n        };\n    }\n\n    public getColumnState(): ColumnState[] {\n        if (_.missing(this.primaryColumns)) { return []; }\n\n        const primaryColumnState: ColumnState[]\n            = this.primaryColumns.map(this.createStateItemFromColumn.bind(this));\n\n        const groupAutoColumnState: ColumnState[]\n            = this.groupAutoColumns\n            // if groupAutoCols, then include them\n            ? this.groupAutoColumns.map(this.createStateItemFromColumn.bind(this))\n            // otherwise no\n            : [];\n\n        const columnStateList = groupAutoColumnState.concat(primaryColumnState);\n\n        if (!this.pivotMode) {\n            this.orderColumnStateList(columnStateList);\n        }\n\n        return columnStateList;\n    }\n\n    private orderColumnStateList(columnStateList: any[]): void {\n        const gridColumnIds = this.gridColumns.map(column => column.getColId());\n\n        columnStateList.sort((itemA: any, itemB: any) => {\n            const posA = gridColumnIds.indexOf(itemA.colId);\n            const posB = gridColumnIds.indexOf(itemB.colId);\n            return posA - posB;\n        });\n    }\n\n    public resetColumnState(suppressEverythingEvent = false, source: ColumnEventType = \"api\"): void {\n        // NOTE = there is one bug here that no customer has noticed - if a column has colDef.lockPosition,\n        // this is ignored  below when ordering the cols. to work, we should always put lockPosition cols first.\n        // As a work around, developers should just put lockPosition columns first in their colDef list.\n\n        // we can't use 'allColumns' as the order might of messed up, so get the primary ordered list\n        const primaryColumns = this.getColumnsFromTree(this.primaryColumnTree);\n        const columnStates: ColumnState[] = [];\n\n        // we start at 1000, so if user has mix of rowGroup and group specified, it will work with both.\n        // eg IF user has ColA.rowGroupIndex=0, ColB.rowGroupIndex=1, ColC.rowGroup=true,\n        // THEN result will be ColA.rowGroupIndex=0, ColB.rowGroupIndex=1, ColC.rowGroup=1000\n        let letRowGroupIndex = 1000;\n        let letPivotIndex = 1000;\n\n        if (primaryColumns) {\n            primaryColumns.forEach((column) => {\n                const rowGroupIndex: number = column.getColDef().rowGroupIndex;\n                const rowGroup: boolean = column.getColDef().rowGroup;\n                const pivotIndex: number = column.getColDef().pivotIndex;\n                const pivot: boolean = column.getColDef().pivot;\n\n                const stateItem = {\n                    colId: column.getColId(),\n                    aggFunc: column.getColDef().aggFunc,\n                    hide: column.getColDef().hide,\n                    pinned: column.getColDef().pinned,\n                    rowGroupIndex: rowGroupIndex,\n                    pivotIndex: column.getColDef().pivotIndex,\n                    width: column.getColDef().width\n                };\n\n                if (_.missing(rowGroupIndex) && rowGroup) {\n                    stateItem.rowGroupIndex = letRowGroupIndex++;\n                }\n\n                if (_.missing(pivotIndex) && pivot) {\n                    stateItem.pivotIndex = letPivotIndex++;\n                }\n\n                columnStates.push(stateItem);\n            });\n        }\n\n        this.setColumnState(columnStates, suppressEverythingEvent, source);\n    }\n\n    public setColumnState(columnStates: ColumnState[], suppressEverythingEvent = false, source: ColumnEventType = \"api\"): boolean {\n        if (_.missingOrEmpty(this.primaryColumns)) { return false; }\n\n        const columnStateBefore = this.getColumnState();\n\n        this.autoGroupsNeedBuilding = true;\n\n        // at the end below, this list will have all columns we got no state for\n        const columnsWithNoState = this.primaryColumns.slice();\n\n        this.rowGroupColumns = [];\n        this.valueColumns = [];\n        this.pivotColumns = [];\n\n        let success = true;\n\n        const rowGroupIndexes: { [key: string]: number } = {};\n        const pivotIndexes: { [key: string]: number } = {};\n        const autoGroupColumnStates: ColumnState[] = [];\n\n        if (columnStates) {\n            columnStates.forEach((state: ColumnState) => {\n\n                // auto group columns are re-created so deferring syncing with ColumnState\n                if (_.exists(this.getAutoColumn(state.colId))) {\n                    autoGroupColumnStates.push(state);\n                    return;\n                }\n\n                const column = this.getPrimaryColumn(state.colId);\n\n                if (!column) {\n                    console.warn('ag-grid: column ' + state.colId + ' not found');\n                    success = false;\n                } else {\n                    this.syncColumnWithStateItem(column, state, rowGroupIndexes, pivotIndexes, source);\n                    _.removeFromArray(columnsWithNoState, column);\n                }\n            });\n        }\n\n        // anything left over, we got no data for, so add in the column as non-value, non-rowGroup and hidden\n        columnsWithNoState.forEach(this.syncColumnWithNoState.bind(this));\n\n        // sort the lists according to the indexes that were provided\n        this.rowGroupColumns.sort(this.sortColumnListUsingIndexes.bind(this, rowGroupIndexes));\n        this.pivotColumns.sort(this.sortColumnListUsingIndexes.bind(this, pivotIndexes));\n\n        this.updateGridColumns();\n\n        // sync newly created auto group columns with ColumnState\n        autoGroupColumnStates.forEach(stateItem => {\n            const autoCol = this.getAutoColumn(stateItem.colId);\n            this.syncColumnWithStateItem(autoCol, stateItem, rowGroupIndexes, pivotIndexes, source);\n        });\n\n        if (columnStates) {\n            const orderOfColIds = columnStates.map(stateItem => stateItem.colId);\n\n            this.gridColumns.sort((colA: Column, colB: Column) => {\n                const indexA = orderOfColIds.indexOf(colA.getId());\n                const indexB = orderOfColIds.indexOf(colB.getId());\n\n                return indexA - indexB;\n            });\n        }\n\n        // this is already done in updateGridColumns, however we changed the order above (to match the order of the state\n        // columns) so we need to do it again. we could of put logic into the order above to take into account fixed\n        // columns, however if we did then we would have logic for updating fixed columns twice. reusing the logic here\n        // is less sexy for the code here, but it keeps consistency.\n        this.putFixedColumnsFirst();\n        this.updateDisplayedColumns(source);\n\n        if (!suppressEverythingEvent) {\n            const event: ColumnEverythingChangedEvent = {\n                type: Events.EVENT_COLUMN_EVERYTHING_CHANGED,\n                api: this.gridApi,\n                columnApi: this.columnApi,\n                source: source\n            };\n            this.eventService.dispatchEvent(event);\n        }\n\n        this.raiseColumnEvents(columnStateBefore, source);\n\n        return success;\n    }\n\n    private raiseColumnEvents(columnStateBefore: ColumnState[], source: ColumnEventType) {\n        if (this.gridOptionsWrapper.isSuppressSetColumnStateEvents()) { return; }\n\n        const columnStateAfter = this.getColumnState();\n\n        // raises generic ColumnEvents where all columns are returned rather than what has changed\n        const raiseEventWithAllColumns = (eventType: string, idMapper: (cs: ColumnState) => string, columns: Column[]) => {\n            const unchanged = _.compareArrays(columnStateBefore.map(idMapper).sort(), columnStateAfter.map(idMapper).sort());\n\n            if (unchanged) { return; }\n\n            // returning all columns rather than what has changed!\n            const event: ColumnEvent = {\n                type: eventType,\n                columns: columns,\n                column: columns.length === 1 ? columns[0] : null,\n                api: this.gridApi,\n                columnApi: this.columnApi,\n                source: source\n            };\n\n            this.eventService.dispatchEvent(event);\n        };\n\n        // determines which columns have changed according to supplied predicate\n        const getChangedColumns = (changedPredicate: (cs: ColumnState, c: Column) => boolean): Column[] => {\n            const changedColumns: Column[] = [];\n            const columnStateBeforeMap: { [colId: string]: ColumnState } = {};\n\n            columnStateBefore.forEach(col => {\n                columnStateBeforeMap[col.colId] = col;\n            });\n\n            this.gridColumns.forEach(column => {\n                const colStateBefore = columnStateBeforeMap[column.getColId()];\n                if (!colStateBefore || changedPredicate(colStateBefore, column)) {\n                    changedColumns.push(column);\n                }\n            });\n\n            return changedColumns;\n        };\n\n        // generic ColumnEvents which return current column list\n        const valueColumnIdMapper = (cs: ColumnState) => cs.colId + '-' + cs.aggFunc;\n        raiseEventWithAllColumns(Events.EVENT_COLUMN_VALUE_CHANGED, valueColumnIdMapper, this.valueColumns);\n\n        const pivotColumnIdMapper = (cs: ColumnState) => cs.colId + '-' + cs.pivotIndex;\n        raiseEventWithAllColumns(Events.EVENT_COLUMN_PIVOT_CHANGED, pivotColumnIdMapper, this.pivotColumns);\n\n        const rowGroupColumnIdMapper = (cs: ColumnState) => cs.colId + '-' + cs.rowGroupIndex;\n        raiseEventWithAllColumns(Events.EVENT_COLUMN_ROW_GROUP_CHANGED, rowGroupColumnIdMapper, this.rowGroupColumns);\n\n        // specific ColumnEvents which return what's changed\n        const pinnedChangePredicate = (cs: ColumnState, c: Column) => cs.pinned !== c.getPinned();\n        this.raiseColumnPinnedEvent(getChangedColumns(pinnedChangePredicate), source);\n\n        const visibilityChangePredicate = (cs: ColumnState, c: Column) => cs.hide === c.isVisible();\n        const cols = getChangedColumns(visibilityChangePredicate);\n        this.raiseColumnVisibleEvent(cols, source);\n\n        const resizeChangePredicate = (cs: ColumnState, c: Column) => cs.width !== c.getActualWidth();\n        this.raiseColumnResizeEvent(getChangedColumns(resizeChangePredicate), source);\n\n        // special handling for moved column events\n        this.raiseColumnMovedEvent(columnStateBefore, source);\n    }\n\n    private raiseColumnPinnedEvent(changedColumns: Column[], source: ColumnEventType) {\n        if (!changedColumns.length) { return; }\n\n        const event: ColumnPinnedEvent = {\n            type: Events.EVENT_COLUMN_PINNED,\n            pinned: null,\n            columns: changedColumns,\n            column: null,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            source: source\n        };\n\n        this.eventService.dispatchEvent(event);\n    }\n\n    private raiseColumnVisibleEvent(changedColumns: Column[], source: ColumnEventType) {\n        if (!changedColumns.length) { return; }\n\n        const event: ColumnVisibleEvent = {\n            type: Events.EVENT_COLUMN_VISIBLE,\n            visible: undefined,\n            columns: changedColumns,\n            column: null,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            source: source\n        };\n\n        this.eventService.dispatchEvent(event);\n    }\n\n    private raiseColumnResizeEvent(changedColumns: Column[], source: ColumnEventType) {\n        if (!changedColumns.length) { return; }\n\n        const event: ColumnResizedEvent = {\n            type: Events.EVENT_COLUMN_RESIZED,\n            columns: changedColumns,\n            column: null,\n            finished: true,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            source: source\n        };\n\n        this.eventService.dispatchEvent(event);\n    }\n\n    private raiseColumnMovedEvent(columnStateBefore: ColumnState[], source: ColumnEventType) {\n        const movedColumns: Column[] = [];\n        const columnStateAfter = this.getColumnState();\n\n        for (let i = 0; i < columnStateAfter.length; i++) {\n            const before = columnStateBefore[i];\n            const after = columnStateAfter[i];\n\n            // don't consider column if reintroduced or hidden\n            if (!before || after.hide) { continue; }\n\n            if (before.colId !== after.colId) {\n                const predicate = (column: Column) => column.getColId() === after.colId;\n                const movedColumn = _.find(this.allDisplayedColumns, predicate);\n                movedColumns.push(movedColumn);\n            }\n        }\n\n        if (!movedColumns.length) { return; }\n\n        const event: ColumnMovedEvent = {\n            type: Events.EVENT_COLUMN_MOVED,\n            columns: movedColumns,\n            column: null,\n            toIndex: undefined,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            source: source\n        };\n\n        this.eventService.dispatchEvent(event);\n    }\n\n    private sortColumnListUsingIndexes(indexes: { [key: string]: number }, colA: Column, colB: Column): number {\n        const indexA = indexes[colA.getId()];\n        const indexB = indexes[colB.getId()];\n\n        return indexA - indexB;\n    }\n\n    private syncColumnWithNoState(column: Column, source: ColumnEventType): void {\n        column.setVisible(false, source);\n        column.setAggFunc(null);\n        column.setPinned(null);\n        column.setRowGroupActive(false, source);\n        column.setPivotActive(false, source);\n        column.setValueActive(false, source);\n    }\n\n    private syncColumnWithStateItem(\n            column: Column | null,\n            stateItem: ColumnState,\n            rowGroupIndexes: { [key: string]: number },\n            pivotIndexes: { [key: string]: number },\n            source: ColumnEventType\n        ): void {\n\n        if (!column) { return; }\n\n        // following ensures we are left with boolean true or false, eg converts (null, undefined, 0) all to true\n        column.setVisible(!stateItem.hide, source);\n        // sets pinned to 'left' or 'right'\n        column.setPinned(stateItem.pinned);\n        // if width provided and valid, use it, otherwise stick with the old width\n        const minColWidth = this.gridOptionsWrapper.getMinColWidth();\n\n        if (stateItem.width && minColWidth &&\n            (stateItem.width >= minColWidth)) {\n            column.setActualWidth(stateItem.width, source);\n        }\n\n        if (typeof stateItem.aggFunc === 'string') {\n            column.setAggFunc(stateItem.aggFunc);\n            column.setValueActive(true, source);\n            this.valueColumns.push(column);\n        } else {\n            if (_.exists(stateItem.aggFunc)) {\n                console.warn('ag-Grid: stateItem.aggFunc must be a string. if using your own aggregation ' +\n                    'functions, register the functions first before using them in get/set state. This is because it is' +\n                    'intended for the column state to be stored and retrieved as simple JSON.');\n            }\n            column.setAggFunc(null);\n            column.setValueActive(false, source);\n        }\n\n        if (typeof stateItem.rowGroupIndex === 'number') {\n            this.rowGroupColumns.push(column);\n            column.setRowGroupActive(true, source);\n            rowGroupIndexes[column.getId()] = stateItem.rowGroupIndex;\n        } else {\n            column.setRowGroupActive(false, source);\n        }\n\n        if (typeof stateItem.pivotIndex === 'number') {\n            this.pivotColumns.push(column);\n            column.setPivotActive(true, source);\n            pivotIndexes[column.getId()] = stateItem.pivotIndex;\n        } else {\n            column.setPivotActive(false, source);\n        }\n    }\n\n    public getGridColumns(keys: (string | Column)[]): Column[] {\n        return this.getColumns(keys, this.getGridColumn.bind(this));\n    }\n\n    private getColumns(keys: (string | Column)[], columnLookupCallback: (key: string | Column) => Column): Column[] {\n        const foundColumns: Column[] = [];\n\n        if (keys) {\n            keys.forEach((key: (string | Column)) => {\n                const column = columnLookupCallback(key);\n                if (column) {\n                    foundColumns.push(column);\n                }\n            });\n        }\n\n        return foundColumns;\n    }\n\n    // used by growGroupPanel\n    public getColumnWithValidation(key: string | Column | undefined): Column | null {\n        if (key == null) { return null; }\n\n        const column = this.getGridColumn(key);\n\n        if (!column) {\n            console.warn('ag-Grid: could not find column ' + key);\n        }\n\n        return column;\n    }\n\n    public getPrimaryColumn(key: string | Column): Column | null {\n        return this.getColumn(key, this.primaryColumns);\n    }\n\n    public getGridColumn(key: string | Column): Column | null {\n        return this.getColumn(key, this.gridColumns);\n    }\n\n    private getColumn(key: string | Column, columnList: Column[]): Column | null {\n        if (!key) { return null; }\n\n        for (let i = 0; i < columnList.length; i++) {\n            if (this.columnsMatch(columnList[i], key)) {\n                return columnList[i];\n            }\n        }\n\n        return this.getAutoColumn(key);\n    }\n\n    private getAutoColumn(key: string | Column): Column | null {\n        if (\n            !this.groupAutoColumns ||\n            !_.exists(this.groupAutoColumns) ||\n            _.missing(this.groupAutoColumns)\n        ) { return null; }\n\n        return _.find(this.groupAutoColumns, groupCol => this.columnsMatch(groupCol, key));\n    }\n\n    private columnsMatch(column: Column, key: string | Column): boolean {\n        const columnMatches = column === key;\n        const colDefMatches = column.getColDef() === key;\n        const idMatches = column.getColId() == key;\n\n        return columnMatches || colDefMatches || idMatches;\n    }\n\n    public getDisplayNameForColumn(column: Column | null, location: string | null, includeAggFunc = false): string | null {\n        if (!column) { return null; }\n\n        const headerName: string | null = this.getHeaderName(column.getColDef(), column, null, null, location);\n\n        if (includeAggFunc) {\n            return this.wrapHeaderNameWithAggFunc(column, headerName);\n        }\n\n        return headerName;\n    }\n\n    public getDisplayNameForOriginalColumnGroup(\n            columnGroup: ColumnGroup | null,\n            originalColumnGroup: OriginalColumnGroup | null,\n            location: string\n        ): string | null {\n        const colGroupDef = originalColumnGroup ? originalColumnGroup.getColGroupDef() : null;\n\n        if (colGroupDef) {\n            return this.getHeaderName(colGroupDef, null, columnGroup, originalColumnGroup, location);\n        }\n\n        return null;\n    }\n\n    public getDisplayNameForColumnGroup(columnGroup: ColumnGroup, location: string): string | null {\n        return this.getDisplayNameForOriginalColumnGroup(columnGroup, columnGroup.getOriginalColumnGroup(), location);\n    }\n\n    // location is where the column is going to appear, ie who is calling us\n    private getHeaderName(\n            colDef: AbstractColDef,\n            column: Column | null,\n            columnGroup: ColumnGroup | null,\n            originalColumnGroup: OriginalColumnGroup | null,\n            location: string | null\n        ): string | null {\n        const headerValueGetter = colDef.headerValueGetter;\n\n        if (headerValueGetter) {\n            const params = {\n                colDef: colDef,\n                column: column,\n                columnGroup: columnGroup,\n                originalColumnGroup: originalColumnGroup,\n                location: location,\n                api: this.gridOptionsWrapper.getApi(),\n                context: this.gridOptionsWrapper.getContext()\n            };\n\n            if (typeof headerValueGetter === 'function') {\n                // valueGetter is a function, so just call it\n                return headerValueGetter(params);\n            } else if (typeof headerValueGetter === 'string') {\n                // valueGetter is an expression, so execute the expression\n                return this.expressionService.evaluate(headerValueGetter, params);\n            }\n            console.warn('ag-grid: headerValueGetter must be a function or a string');\n            return '';\n        } else if (colDef.headerName != null) {\n            return colDef.headerName;\n        } else if ((colDef as ColDef).field) {\n            return _.camelCaseToHumanText((colDef as ColDef).field);\n        }\n\n        return '';\n    }\n\n    /*\n        private getHeaderGroupName(columnGroup: ColumnGroup): string {\n            let colGroupDef = columnGroup.getOriginalColumnGroup().getColGroupDef();\n            let headerValueGetter = colGroupDef.headerValueGetter;\n\n            if (headerValueGetter) {\n                let params = {\n                    columnGroup: columnGroup,\n                    colDef: colGroupDef,\n                    api: this.gridOptionsWrapper.getApi(),\n                    context: this.gridOptionsWrapper.getContext()\n                };\n\n                if (typeof headerValueGetter === 'function') {\n                    // valueGetter is a function, so just call it\n                    return headerValueGetter(params);\n                } else if (typeof headerValueGetter === 'string') {\n                    // valueGetter is an expression, so execute the expression\n                    return this.expressionService.evaluate(headerValueGetter, params);\n                } else {\n                    console.warn('ag-grid: headerValueGetter must be a function or a string');\n                    return '';\n                }\n            } else {\n                return colGroupDef.headerName;\n            }\n        }\n    */\n\n    private wrapHeaderNameWithAggFunc(column: Column, headerName: string | null): string | null {\n        if (this.gridOptionsWrapper.isSuppressAggFuncInHeader()) { return headerName; }\n\n        // only columns with aggregation active can have aggregations\n        const pivotValueColumn = column.getColDef().pivotValueColumn;\n        const pivotActiveOnThisColumn = _.exists(pivotValueColumn);\n        let aggFunc: string | IAggFunc | null = null;\n        let aggFuncFound: boolean;\n\n        // otherwise we have a measure that is active, and we are doing aggregation on it\n        if (pivotActiveOnThisColumn) {\n            aggFunc = pivotValueColumn ? pivotValueColumn.getAggFunc() : null;\n            aggFuncFound = true;\n        } else {\n            const measureActive = column.isValueActive();\n            const aggregationPresent = this.pivotMode || !this.isRowGroupEmpty();\n\n            if (measureActive && aggregationPresent) {\n                aggFunc = column.getAggFunc();\n                aggFuncFound = true;\n            } else {\n                aggFuncFound = false;\n            }\n        }\n\n        if (aggFuncFound) {\n            const aggFuncString = (typeof aggFunc === 'string') ? aggFunc : 'func';\n            const localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();\n            const aggFuncStringTranslated = localeTextFunc(aggFuncString, aggFuncString);\n            return `${aggFuncStringTranslated}(${headerName})`;\n        }\n\n        return headerName;\n    }\n\n    // returns the group with matching colId and instanceId. If instanceId is missing,\n    // matches only on the colId.\n    public getColumnGroup(colId: string | ColumnGroup, instanceId?: number): ColumnGroup | null {\n        if (!colId) { return null; }\n        if (colId instanceof ColumnGroup) { return colId; }\n\n        const allColumnGroups = this.getAllDisplayedColumnGroups();\n        const checkInstanceId = typeof instanceId === 'number';\n        let result: ColumnGroup | null = null;\n\n        this.columnUtils.depthFirstAllColumnTreeSearch(allColumnGroups, (child: ColumnGroupChild) => {\n            if (child instanceof ColumnGroup) {\n                const columnGroup = child;\n                let matched: boolean;\n\n                if (checkInstanceId) {\n                    matched = colId === columnGroup.getGroupId() && instanceId === columnGroup.getInstanceId();\n                } else {\n                    matched = colId === columnGroup.getGroupId();\n                }\n\n                if (matched) {\n                    result = columnGroup;\n                }\n            }\n        });\n\n        return result;\n    }\n\n    public isReady(): boolean {\n        return this.ready;\n    }\n\n    private createValueColumns(source: ColumnEventType, oldPrimaryColumns: Column[]): void {\n        this.valueColumns = this.extractColumns(oldPrimaryColumns, this.valueColumns,\n            (col: Column, flag: boolean) => col.setValueActive(flag, source),\n            // aggFunc doesn't have index variant, cos order of value cols doesn't matter, so always return null\n            () => null,\n            // aggFunc is a string, so return it's existence\n            (colDef: ColDef) => !!colDef.aggFunc,\n        );\n\n        // all new columns added will have aggFunc missing, so set it to what is in the colDef\n        this.valueColumns.forEach(col => {\n            if (!col.getAggFunc()) {\n                col.setAggFunc(col.getColDef().aggFunc);\n            }\n        });\n    }\n\n    private extractRowGroupColumns(source: ColumnEventType, oldPrimaryColumns: Column[]): void {\n        this.rowGroupColumns = this.extractColumns(oldPrimaryColumns, this.rowGroupColumns,\n            (col: Column, flag: boolean) => col.setRowGroupActive(flag, source),\n            (colDef: ColDef) => colDef.rowGroupIndex,\n            (colDef: ColDef) => colDef.rowGroup,\n        );\n    }\n\n    private extractColumns(\n            oldPrimaryColumns: Column[], previousCols: Column[],\n            setFlagFunc: (col: Column, flag: boolean) => void,\n            getIndexFunc: (colDef: ColDef) => number | null | undefined,\n            getValueFunc: (colDef: ColDef) => boolean | undefined\n        ): Column[] {\n\n        if (!previousCols) { previousCols = []; }\n\n        // remove cols that no longer exist\n        const colPresentInPrimaryFunc = (col: Column) => this.primaryColumns.indexOf(col) >= 0;\n        const colMissingFromPrimaryFunc = (col: Column) => this.primaryColumns.indexOf(col) < 0;\n        const colNewFunc = (col: Column) => !oldPrimaryColumns || oldPrimaryColumns.indexOf(col) < 0;\n        const removedCols = previousCols.filter(colMissingFromPrimaryFunc);\n        const existingCols = previousCols.filter(colPresentInPrimaryFunc);\n        const newPrimaryCols = this.primaryColumns.filter(colNewFunc);\n\n        removedCols.forEach(col => setFlagFunc(col, false));\n\n        const newCols: Column[] = [];\n\n        // we only want to work on new columns, as old columns already got processed first time around\n        // pull out items with xxxIndex\n        newPrimaryCols.forEach(col => {\n            const index = getIndexFunc(col.getColDef());\n\n            if (typeof index === 'number') {\n                newCols.push(col);\n            }\n        });\n\n        // then sort them\n        newCols.sort(function(colA: Column, colB: Column): number {\n            const indexA = getIndexFunc(colA.getColDef());\n            const indexB = getIndexFunc(colB.getColDef());\n\n            if (indexA === indexB) {\n                return 0;\n            } else if (indexA < indexB) {\n                return -1;\n            }\n\n            return 1;\n        });\n        // now just pull out items xxx (boolean value), they will be added at the end\n        // after the indexed ones, but in the order the columns appear\n        newPrimaryCols.forEach(col => {\n            const booleanValue = getValueFunc(col.getColDef());\n            if (booleanValue) {\n                // if user already specified xxxIndex then we skip it as this col already included\n                if (newCols.indexOf(col) >= 0) { return; }\n                newCols.push(col);\n            }\n        });\n\n        newCols.forEach(col => setFlagFunc(col, true));\n\n        const res = existingCols.concat(newCols);\n\n        return res;\n    }\n\n    private extractPivotColumns(source: ColumnEventType, oldPrimaryColumns: Column[]): void {\n        this.pivotColumns = this.extractColumns(oldPrimaryColumns, this.pivotColumns,\n            (col: Column, flag: boolean) => col.setPivotActive(flag, source),\n            (colDef: ColDef) => colDef.pivotIndex,\n            (colDef: ColDef) => colDef.pivot,\n        );\n    }\n\n    public resetColumnGroupState(source: ColumnEventType = \"api\"): void {\n        const stateItems: { groupId: string, open: boolean | undefined }[] = [];\n\n        this.columnUtils.depthFirstOriginalTreeSearch(null, this.primaryColumnTree, child => {\n            if (child instanceof OriginalColumnGroup) {\n                const groupState = {\n                    groupId: child.getGroupId(),\n                    open: child.getColGroupDef().openByDefault\n                };\n                stateItems.push(groupState);\n            }\n        });\n\n        this.setColumnGroupState(stateItems, source);\n    }\n\n    public getColumnGroupState(): { groupId: string, open: boolean }[] {\n        const columnGroupState: { groupId: string, open: boolean }[] = [];\n\n        this.columnUtils.depthFirstOriginalTreeSearch(null, this.gridBalancedTree, node => {\n            if (node instanceof OriginalColumnGroup) {\n                const originalColumnGroup = node;\n                columnGroupState.push({\n                    groupId: originalColumnGroup.getGroupId(),\n                    open: originalColumnGroup.isExpanded()\n                });\n            }\n        });\n\n        return columnGroupState;\n    }\n\n    public setColumnGroupState(stateItems: { groupId: string, open: boolean | undefined }[], source: ColumnEventType = \"api\"): void {\n        this.columnAnimationService.start();\n\n        const impactedGroups: OriginalColumnGroup[] = [];\n\n        stateItems.forEach(stateItem => {\n            const groupKey = stateItem.groupId;\n            const newValue = stateItem.open;\n            const originalColumnGroup: OriginalColumnGroup | null = this.getOriginalColumnGroup(groupKey);\n\n            if (!originalColumnGroup) { return; }\n            if (originalColumnGroup.isExpanded() === newValue) { return; }\n\n            this.logger.log('columnGroupOpened(' + originalColumnGroup.getGroupId() + ',' + newValue + ')');\n            originalColumnGroup.setExpanded(newValue);\n            impactedGroups.push(originalColumnGroup);\n        });\n\n        this.updateGroupsAndDisplayedColumns(source);\n        this.setFirstRightAndLastLeftPinned(source);\n\n        impactedGroups.forEach(originalColumnGroup => {\n            const event: ColumnGroupOpenedEvent = {\n                type: Events.EVENT_COLUMN_GROUP_OPENED,\n                columnGroup: originalColumnGroup,\n                api: this.gridApi,\n                columnApi: this.columnApi\n            };\n            this.eventService.dispatchEvent(event);\n        });\n\n        this.columnAnimationService.finish();\n    }\n\n    // called by headerRenderer - when a header is opened or closed\n    public setColumnGroupOpened(key: OriginalColumnGroup | string | undefined, newValue: boolean, source: ColumnEventType = \"api\"): void {\n        let keyAsString: string;\n\n        if (key instanceof OriginalColumnGroup) {\n            keyAsString = key.getId();\n        } else {\n            keyAsString = key;\n        }\n        this.setColumnGroupState([{groupId: keyAsString, open: newValue}], source);\n    }\n\n    public getOriginalColumnGroup(key: OriginalColumnGroup | string): OriginalColumnGroup | null {\n        if (key instanceof OriginalColumnGroup) { return key; }\n\n        if (typeof key !== 'string') {\n            console.error('ag-Grid: group key must be a string');\n        }\n\n        // otherwise, search for the column group by id\n        let res: OriginalColumnGroup | null = null;\n\n        this.columnUtils.depthFirstOriginalTreeSearch(null, this.gridBalancedTree, node => {\n            if (node instanceof OriginalColumnGroup) {\n                const originalColumnGroup = node;\n                if (originalColumnGroup.getId() === key) {\n                    res = originalColumnGroup;\n                }\n            }\n        });\n\n        return res;\n    }\n\n    private calculateColumnsForDisplay(): Column[] {\n        let columnsForDisplay: Column[];\n\n        if (this.pivotMode && !this.secondaryColumnsPresent) {\n            // pivot mode is on, but we are not pivoting, so we only\n            // show columns we are aggregating on\n            columnsForDisplay = this.gridColumns.filter(column => {\n                const isAutoGroupCol = this.groupAutoColumns && _.includes(this.groupAutoColumns, column);\n                const isValueCol = this.valueColumns && _.includes(this.valueColumns, column);\n                return isAutoGroupCol || isValueCol;\n            });\n\n        } else {\n            // otherwise continue as normal. this can be working on the primary\n            // or secondary columns, whatever the gridColumns are set to\n            columnsForDisplay = this.gridColumns.filter(column => {\n                // keep col if a) it's auto-group or b) it's visible\n                const isAutoGroupCol = this.groupAutoColumns && _.includes(this.groupAutoColumns, column);\n                return isAutoGroupCol || column.isVisible();\n            });\n        }\n\n        return columnsForDisplay;\n    }\n\n    private checkColSpanActiveInCols(columns: Column[]): boolean {\n        let result = false;\n\n        columns.forEach(col => {\n            if (_.exists(col.getColDef().colSpan)) {\n                result = true;\n            }\n        });\n\n        return result;\n    }\n\n    private calculateColumnsForGroupDisplay(): void {\n        this.groupDisplayColumns = [];\n\n        const checkFunc = (col: Column) => {\n            const colDef = col.getColDef();\n            if (colDef && _.exists(colDef.showRowGroup)) {\n                this.groupDisplayColumns.push(col);\n            }\n        };\n\n        this.gridColumns.forEach(checkFunc);\n\n        if (this.groupAutoColumns) {\n            this.groupAutoColumns.forEach(checkFunc);\n        }\n    }\n\n    public getGroupDisplayColumns(): Column[] {\n        return this.groupDisplayColumns;\n    }\n\n    private updateDisplayedColumns(source: ColumnEventType): void {\n        const columnsForDisplay = this.calculateColumnsForDisplay();\n\n        this.buildDisplayedTrees(columnsForDisplay);\n        this.calculateColumnsForGroupDisplay();\n\n        // also called when group opened/closed\n        this.updateGroupsAndDisplayedColumns(source);\n\n        // also called when group opened/closed\n        this.setFirstRightAndLastLeftPinned(source);\n    }\n\n    public isSecondaryColumnsPresent(): boolean {\n        return this.secondaryColumnsPresent;\n    }\n\n    public setSecondaryColumns(colDefs: (ColDef | ColGroupDef)[] | null, source: ColumnEventType = \"api\"): void {\n        const newColsPresent = colDefs && colDefs.length > 0;\n\n        // if not cols passed, and we had to cols anyway, then do nothing\n        if (!newColsPresent && !this.secondaryColumnsPresent) { return; }\n\n        if (newColsPresent) {\n            this.processSecondaryColumnDefinitions(colDefs);\n            const balancedTreeResult = this.columnFactory.createColumnTree(colDefs, false);\n            this.secondaryBalancedTree = balancedTreeResult.columnTree;\n            this.secondaryHeaderRowCount = balancedTreeResult.treeDept + 1;\n            this.secondaryColumns = this.getColumnsFromTree(this.secondaryBalancedTree);\n            this.secondaryColumnsPresent = true;\n        } else {\n            this.secondaryBalancedTree = null;\n            this.secondaryHeaderRowCount = -1;\n            this.secondaryColumns = null;\n            this.secondaryColumnsPresent = false;\n        }\n\n        this.updateGridColumns();\n        this.updateDisplayedColumns(source);\n    }\n\n    private processSecondaryColumnDefinitions(colDefs: (ColDef | ColGroupDef)[] | null): (ColDef | ColGroupDef)[] | undefined {\n\n        const columnCallback = this.gridOptionsWrapper.getProcessSecondaryColDefFunc();\n        const groupCallback = this.gridOptionsWrapper.getProcessSecondaryColGroupDefFunc();\n\n        if (!columnCallback && !groupCallback) { return undefined; }\n\n        const searchForColDefs = (colDefs2: (ColDef | ColGroupDef)[]): void => {\n            colDefs2.forEach(function(abstractColDef: AbstractColDef) {\n                const isGroup = _.exists((abstractColDef as any).children);\n                if (isGroup) {\n                    const colGroupDef = abstractColDef as ColGroupDef;\n                    if (groupCallback) {\n                        groupCallback(colGroupDef);\n                    }\n                    searchForColDefs(colGroupDef.children);\n                } else {\n                    const colDef = abstractColDef as ColGroupDef;\n                    if (columnCallback) {\n                        columnCallback(colDef);\n                    }\n                }\n            });\n        };\n\n        if (colDefs) {\n            searchForColDefs(colDefs);\n        }\n    }\n\n    // called from: setColumnState, setColumnDefs, setSecondaryColumns\n    private updateGridColumns(): void {\n        if (this.gridColsArePrimary) {\n            this.lastPrimaryOrder = this.gridColumns;\n        }\n\n        if (this.secondaryColumns && this.secondaryBalancedTree) {\n            this.gridBalancedTree = this.secondaryBalancedTree.slice();\n            this.gridHeaderRowCount = this.secondaryHeaderRowCount;\n            this.gridColumns = this.secondaryColumns.slice();\n            this.gridColsArePrimary = false;\n        } else {\n            this.gridBalancedTree = this.primaryColumnTree.slice();\n            this.gridHeaderRowCount = this.primaryHeaderRowCount;\n            this.gridColumns = this.primaryColumns.slice();\n            this.gridColsArePrimary = true;\n\n            // updateGridColumns gets called after user adds a row group. we want to maintain the order of the columns\n            // when this happens (eg if user moved a column) rather than revert back to the original column order.\n            // likewise if changing in/out of pivot mode, we want to maintain the order of the primary cols\n            this.orderGridColsLikeLastPrimary();\n        }\n\n        this.addAutoGroupToGridColumns();\n\n        this.autoRowHeightColumns = this.gridColumns.filter(col => col.getColDef().autoHeight);\n\n        this.putFixedColumnsFirst();\n        this.setupQuickFilterColumns();\n        this.clearDisplayedColumns();\n\n        this.colSpanActive = this.checkColSpanActiveInCols(this.gridColumns);\n\n        const event: GridColumnsChangedEvent = {\n            type: Events.EVENT_GRID_COLUMNS_CHANGED,\n            api: this.gridApi,\n            columnApi: this.columnApi\n        };\n\n        this.eventService.dispatchEvent(event);\n    }\n\n    private orderGridColsLikeLastPrimary(): void {\n        if (_.missing(this.lastPrimaryOrder)) { return; }\n\n        // only do the sort if at least one column is accounted for. columns will be not accounted for\n        // if changing from secondary to primary columns\n        let noColsFound = true;\n        this.gridColumns.forEach(col => {\n            if (this.lastPrimaryOrder.indexOf(col) >= 0) {\n                noColsFound = false;\n            }\n        });\n\n        if (noColsFound) { return; }\n\n        // order cols in the same order as before. we need to make sure that all\n        // cols still exists, so filter out any that no longer exist.\n        const oldColsOrdered = this.lastPrimaryOrder.filter(col => this.gridColumns.indexOf(col) >= 0);\n        const newColsOrdered = this.gridColumns.filter(col => oldColsOrdered.indexOf(col) < 0);\n\n        // add in the new columns, at the end (if no group), or at the end of the group (if a group)\n        const newGridColumns = oldColsOrdered.slice();\n\n        newColsOrdered.forEach(newCol => {\n            let parent = newCol.getOriginalParent();\n\n            // if no parent, means we are not grouping, so just add the column to the end\n            if (!parent) {\n                newGridColumns.push(newCol);\n                return;\n            }\n\n            // find the group the column belongs to. if no siblings at the current level (eg col in group on it's\n            // own) then go up one level and look for siblings there.\n            const siblings: Column[] = [];\n            while (!siblings.length && parent) {\n                const leafCols = parent.getLeafColumns();\n                leafCols.forEach(leafCol => {\n                    const presentInNewGriColumns = newGridColumns.indexOf(leafCol) >= 0;\n                    const noYetInSiblings = siblings.indexOf(leafCol) < 0;\n                    if (presentInNewGriColumns && noYetInSiblings) {\n                        siblings.push(leafCol);\n                    }\n                });\n                parent = parent.getOriginalParent();\n            }\n\n            // if no siblings exist at any level, this means the col is in a group (or parent groups) on it's own\n            if (!siblings.length) {\n                newGridColumns.push(newCol);\n                return;\n            }\n\n            // find index of last column in the group\n            const indexes = siblings.map(col => newGridColumns.indexOf(col));\n            const lastIndex = Math.max(...indexes);\n\n            _.insertIntoArray(newGridColumns, newCol, lastIndex + 1);\n        });\n\n        this.gridColumns = newGridColumns;\n    }\n\n    public isPrimaryColumnGroupsPresent(): boolean {\n        return this.primaryHeaderRowCount > 1;\n    }\n\n    // if we are using autoGroupCols, then they should be included for quick filter. this covers the\n    // following scenarios:\n    // a) user provides 'field' into autoGroupCol of normal grid, so now because a valid col to filter leafs on\n    // b) using tree data and user depends on autoGroupCol for first col, and we also want to filter on this\n    //    (tree data is a bit different, as parent rows can be filtered on, unlike row grouping)\n    private setupQuickFilterColumns(): void {\n        if (this.groupAutoColumns) {\n            this.columnsForQuickFilter = this.primaryColumns.concat(this.groupAutoColumns);\n        } else {\n            this.columnsForQuickFilter = this.primaryColumns;\n        }\n    }\n\n    private putFixedColumnsFirst(): void {\n        const locked = this.gridColumns.filter(c => c.getColDef().lockPosition);\n        const unlocked = this.gridColumns.filter(c => !c.getColDef().lockPosition);\n        this.gridColumns = locked.concat(unlocked);\n    }\n\n    private addAutoGroupToGridColumns(): void {\n        // add in auto-group here\n        this.createGroupAutoColumnsIfNeeded();\n\n        if (_.missing(this.groupAutoColumns)) { return; }\n\n        this.gridColumns = this.groupAutoColumns ? this.groupAutoColumns.concat(this.gridColumns) : this.gridColumns;\n\n        const autoColBalancedTree = this.columnFactory.createForAutoGroups(this.groupAutoColumns, this.gridBalancedTree);\n\n        this.gridBalancedTree = autoColBalancedTree.concat(this.gridBalancedTree);\n    }\n\n    // gets called after we copy down grid columns, to make sure any part of the gui\n    // that tries to draw, eg the header, it will get empty lists of columns rather\n    // than stale columns. for example, the header will received gridColumnsChanged\n    // event, so will try and draw, but it will draw successfully when it acts on the\n    // virtualColumnsChanged event\n    private clearDisplayedColumns(): void {\n        this.displayedLeftColumnTree = [];\n        this.displayedRightColumnTree = [];\n        this.displayedCentreColumnTree = [];\n\n        this.displayedLeftHeaderRows = {};\n        this.displayedRightHeaderRows = {};\n        this.displayedCentreHeaderRows = {};\n\n        this.displayedLeftColumns = [];\n        this.displayedRightColumns = [];\n        this.displayedCenterColumns = [];\n        this.allDisplayedColumns = [];\n        this.allDisplayedVirtualColumns = [];\n    }\n\n    private updateGroupsAndDisplayedColumns(source: ColumnEventType) {\n        this.updateOpenClosedVisibilityInColumnGroups();\n        this.updateDisplayedColumnsFromTrees(source);\n        this.updateVirtualSets();\n        this.updateBodyWidths();\n        // this event is picked up by the gui, headerRenderer and rowRenderer, to recalculate what columns to display\n\n        const event: DisplayedColumnsChangedEvent = {\n            type: Events.EVENT_DISPLAYED_COLUMNS_CHANGED,\n            api: this.gridApi,\n            columnApi: this.columnApi\n        };\n        this.eventService.dispatchEvent(event);\n    }\n\n    private updateDisplayedColumnsFromTrees(source: ColumnEventType): void {\n        this.addToDisplayedColumns(this.displayedLeftColumnTree, this.displayedLeftColumns);\n        this.addToDisplayedColumns(this.displayedCentreColumnTree, this.displayedCenterColumns);\n        this.addToDisplayedColumns(this.displayedRightColumnTree, this.displayedRightColumns);\n        this.setupAllDisplayedColumns();\n        this.setLeftValues(source);\n    }\n\n    private setupAllDisplayedColumns(): void {\n        if (this.gridOptionsWrapper.isEnableRtl()) {\n            this.allDisplayedColumns = this.displayedRightColumns\n                .concat(this.displayedCenterColumns)\n                .concat(this.displayedLeftColumns);\n        } else {\n            this.allDisplayedColumns = this.displayedLeftColumns\n                .concat(this.displayedCenterColumns)\n                .concat(this.displayedRightColumns);\n        }\n    }\n\n    // sets the left pixel position of each column\n    private setLeftValues(source: ColumnEventType): void {\n        this.setLeftValuesOfColumns(source);\n        this.setLeftValuesOfGroups();\n    }\n\n    private setLeftValuesOfColumns(source: ColumnEventType): void {\n        // go through each list of displayed columns\n        const allColumns = this.primaryColumns.slice(0);\n\n        // let totalColumnWidth = this.getWidthOfColsInList()\n        const doingRtl = this.gridOptionsWrapper.isEnableRtl();\n\n        [\n            this.displayedLeftColumns,\n            this.displayedRightColumns,\n            this.displayedCenterColumns\n        ].forEach(columns => {\n            if (doingRtl) {\n                // when doing RTL, we start at the top most pixel (ie RHS) and work backwards\n                let left = this.getWidthOfColsInList(columns);\n                columns.forEach(column => {\n                    left -= column.getActualWidth();\n                    column.setLeft(left, source);\n                });\n            } else {\n                // otherwise normal LTR, we start at zero\n                let left = 0;\n                columns.forEach(column => {\n                    column.setLeft(left, source);\n                    left += column.getActualWidth();\n                });\n            }\n            _.removeAllFromArray(allColumns, columns);\n        });\n\n        // items left in allColumns are columns not displayed, so remove the left position. this is\n        // important for the rows, as if a col is made visible, then taken out, then made visible again,\n        // we don't want the animation of the cell floating in from the old position, whatever that was.\n        allColumns.forEach((column: Column) => {\n            column.setLeft(null, source);\n        });\n    }\n\n    private setLeftValuesOfGroups(): void {\n        // a groups left value is the lest left value of it's children\n        [\n            this.displayedLeftColumnTree,\n            this.displayedRightColumnTree,\n            this.displayedCentreColumnTree\n        ].forEach(columns => {\n            columns.forEach(column => {\n                if (column instanceof ColumnGroup) {\n                    const columnGroup = column;\n                    columnGroup.checkLeft();\n                }\n            });\n        });\n    }\n\n    private addToDisplayedColumns(displayedColumnTree: ColumnGroupChild[], displayedColumns: Column[]): void {\n        displayedColumns.length = 0;\n        this.columnUtils.depthFirstDisplayedColumnTreeSearch(displayedColumnTree, (child: ColumnGroupChild) => {\n            if (child instanceof Column) {\n                displayedColumns.push(child);\n            }\n        });\n    }\n\n    private updateDisplayedCenterVirtualColumns(): { [key: string]: boolean } {\n        if (this.suppressColumnVirtualisation) {\n            // no virtualisation, so don't filter\n            this.allDisplayedCenterVirtualColumns = this.displayedCenterColumns;\n        } else {\n            // filter out what should be visible\n            this.allDisplayedCenterVirtualColumns = this.filterOutColumnsWithinViewport();\n        }\n\n        this.allDisplayedVirtualColumns = this.allDisplayedCenterVirtualColumns\n            .concat(this.displayedLeftColumns)\n            .concat(this.displayedRightColumns);\n\n        // return map of virtual col id's, for easy lookup when building the groups.\n        // the map will be colId=>true, ie col id's mapping to 'true'.\n        const result: any = {};\n\n        this.allDisplayedVirtualColumns.forEach((col: Column) => {\n            result[col.getId()] = true;\n        });\n\n        return result;\n    }\n\n    public getVirtualHeaderGroupRow(type: string, dept: number): ColumnGroupChild[] {\n        let result: ColumnGroupChild[];\n\n        switch (type) {\n            case Constants.PINNED_LEFT:\n                result = this.displayedLeftHeaderRows[dept];\n                break;\n            case Constants.PINNED_RIGHT:\n                result = this.displayedRightHeaderRows[dept];\n                break;\n            default:\n                result = this.displayedCentreHeaderRows[dept];\n                break;\n        }\n\n        if (_.missing(result)) {\n            result = [];\n        }\n\n        return result;\n    }\n\n    private updateDisplayedVirtualGroups(virtualColIds: any): void {\n        // go through each group, see if any of it's cols are displayed, and if yes,\n        // then this group is included\n        this.displayedLeftHeaderRows = {};\n        this.displayedRightHeaderRows = {};\n        this.displayedCentreHeaderRows = {};\n\n        const testGroup = (children: ColumnGroupChild[], result: { [row: number]: ColumnGroupChild[] }, dept: number): boolean => {\n            let returnValue = false;\n\n            for (let i = 0; i < children.length; i++) {\n                // see if this item is within viewport\n                const child = children[i];\n                let addThisItem: boolean;\n                if (child instanceof Column) {\n                    // for column, test if column is included\n                    addThisItem = virtualColIds[child.getId()] === true;\n                } else {\n                    // if group, base decision on children\n                    const columnGroup = child as ColumnGroup;\n                    addThisItem = testGroup(columnGroup.getDisplayedChildren(), result, dept + 1);\n                }\n\n                if (addThisItem) {\n                    returnValue = true;\n                    if (!result[dept]) {\n                        result[dept] = [];\n                    }\n                    result[dept].push(child);\n                }\n            }\n            return returnValue;\n        };\n\n        testGroup(this.displayedLeftColumnTree, this.displayedLeftHeaderRows, 0);\n        testGroup(this.displayedRightColumnTree, this.displayedRightHeaderRows, 0);\n        testGroup(this.displayedCentreColumnTree, this.displayedCentreHeaderRows, 0);\n    }\n\n    private updateVirtualSets(): void {\n        const virtualColIds = this.updateDisplayedCenterVirtualColumns();\n        this.updateDisplayedVirtualGroups(virtualColIds);\n    }\n\n    private filterOutColumnsWithinViewport(): Column[] {\n        return this.displayedCenterColumns.filter(this.isColumnInViewport.bind(this));\n    }\n\n    public refreshFlexedColumns(updatedFlexViewportWidth?: number, source: ColumnEventType = 'flex'): void {\n        if (!this.flexActive) { return; }\n\n        this.flexViewportWidth = updatedFlexViewportWidth || this.flexViewportWidth;\n        if (!this.flexViewportWidth) { return; }\n\n        // If the grid has left-over space, divide it between flexing columns in proportion to their flex value.\n        // A \"flexing column\" is one that has a 'flex' value set and is not currently being constrained by its\n        // minWidth or maxWidth rules.\n\n        const knownWidthColumns = this.displayedCenterColumns.filter(col => !col.getFlex());\n        const flexingColumns = this.displayedCenterColumns.filter(col => col.getFlex());\n        const flexingColumnSizes: number[] = [];\n        let spaceForFlexingColumns: number;\n\n        outer: while (true) {\n            const totalFlex = flexingColumns.reduce((count, col) => count + col.getFlex(), 0);\n            spaceForFlexingColumns = this.flexViewportWidth - this.getWidthOfColsInList(knownWidthColumns);\n            for (let i = 0; i < flexingColumns.length; i++) {\n                const col = flexingColumns[i];\n                const widthByFlexRule = spaceForFlexingColumns * col.getFlex() / totalFlex;\n                let constrainedWidth: number;\n                if (widthByFlexRule < col.getMinWidth()) {\n                    constrainedWidth = col.getMinWidth();\n                } else if (col.getMaxWidth() != null && widthByFlexRule > col.getMaxWidth()) {\n                    constrainedWidth = col.getMaxWidth();\n                }\n                if (constrainedWidth) {\n                    // This column is not in fact flexing as it is being constrained to a specific size\n                    // so remove it from the list of flexing columns and start again\n                    col.setActualWidth(constrainedWidth, source);\n                    _.removeFromArray(flexingColumns, col);\n                    knownWidthColumns.push(col);\n                    continue outer;\n                }\n                flexingColumnSizes[i] = Math.round(widthByFlexRule);\n            }\n            break;\n        }\n\n        let remainingSpace = spaceForFlexingColumns;\n        flexingColumns.forEach((col, i) => {\n            col.setActualWidth(Math.min(flexingColumnSizes[i], remainingSpace), source);\n            remainingSpace -= flexingColumnSizes[i];\n        });\n\n        this.setLeftValues(source);\n        this.updateBodyWidths();\n        this.fireResizedEventForColumns(flexingColumns, source);\n    }\n\n    // called from api\n    public sizeColumnsToFit(gridWidth: any, source: ColumnEventType = \"sizeColumnsToFit\", silent?: boolean): void {\n        // avoid divide by zero\n        const allDisplayedColumns = this.getAllDisplayedColumns();\n\n        if (gridWidth <= 0 || !allDisplayedColumns.length) { return; }\n\n        const colsToSpread: Column[] = [];\n        const colsToNotSpread: Column[] = [];\n\n        allDisplayedColumns.forEach(column => {\n            if (column.getColDef().suppressSizeToFit === true) {\n                colsToNotSpread.push(column);\n            } else {\n                colsToSpread.push(column);\n            }\n        });\n\n        // make a copy of the cols that are going to be resized\n        const colsToFireEventFor = colsToSpread.slice(0);\n        let finishedResizing = false;\n\n        const moveToNotSpread = (column: Column) => {\n            _.removeFromArray(colsToSpread, column);\n            colsToNotSpread.push(column);\n        };\n\n        while (!finishedResizing) {\n            finishedResizing = true;\n            const availablePixels = gridWidth - this.getWidthOfColsInList(colsToNotSpread);\n            if (availablePixels <= 0) {\n                // no width, set everything to minimum\n                colsToSpread.forEach((column: Column) => {\n                    column.setMinimum(source);\n                });\n            } else {\n                const scale = availablePixels / this.getWidthOfColsInList(colsToSpread);\n                // we set the pixels for the last col based on what's left, as otherwise\n                // we could be a pixel or two short or extra because of rounding errors.\n                let pixelsForLastCol = availablePixels;\n                // backwards through loop, as we are removing items as we go\n                for (let i = colsToSpread.length - 1; i >= 0; i--) {\n                    const column = colsToSpread[i];\n                    const newWidth = Math.round(column.getActualWidth() * scale);\n                    if (newWidth < column.getMinWidth()) {\n                        column.setMinimum(source);\n                        moveToNotSpread(column);\n                        finishedResizing = false;\n                    } else if (column.isGreaterThanMax(newWidth)) {\n                        column.setActualWidth(column.getMaxWidth(), source);\n                        moveToNotSpread(column);\n                        finishedResizing = false;\n                    } else {\n                        const onLastCol = i === 0;\n                        if (onLastCol) {\n                            column.setActualWidth(pixelsForLastCol, source);\n                        } else {\n                            column.setActualWidth(newWidth, source);\n                        }\n                    }\n                    pixelsForLastCol -= newWidth;\n                }\n            }\n        }\n\n        this.setLeftValues(source);\n        this.updateBodyWidths();\n\n        if (silent) { return; }\n\n        this.fireResizedEventForColumns(colsToFireEventFor, source);\n    }\n\n    private fireResizedEventForColumns(columns: Column[], source: ColumnEventType) {\n        columns.forEach((column: Column) => {\n            const event: ColumnResizedEvent = {\n                type: Events.EVENT_COLUMN_RESIZED,\n                column: column,\n                columns: [column],\n                finished: true,\n                api: this.gridApi,\n                columnApi: this.columnApi,\n                source\n            };\n            this.eventService.dispatchEvent(event);\n        });\n    }\n\n    private buildDisplayedTrees(visibleColumns: Column[]) {\n        const leftVisibleColumns: Column[] = [];\n        const rightVisibleColumns: Column[] = [];\n        const centerVisibleColumns: Column[] = [];\n\n        visibleColumns.forEach(column => {\n            switch (column.getPinned()) {\n                case \"left\":\n                    leftVisibleColumns.push(column);\n                    break;\n                case \"right\":\n                    rightVisibleColumns.push(column);\n                    break;\n                default:\n                    centerVisibleColumns.push(column);\n                    break;\n            }\n        });\n\n        const groupInstanceIdCreator = new GroupInstanceIdCreator();\n\n        this.displayedLeftColumnTree = this.displayedGroupCreator.createDisplayedGroups(\n            leftVisibleColumns, this.gridBalancedTree, groupInstanceIdCreator, Constants.PINNED_LEFT, this.displayedLeftColumnTree);\n        this.displayedRightColumnTree = this.displayedGroupCreator.createDisplayedGroups(\n            rightVisibleColumns, this.gridBalancedTree, groupInstanceIdCreator, Constants.PINNED_RIGHT, this.displayedRightColumnTree);\n        this.displayedCentreColumnTree = this.displayedGroupCreator.createDisplayedGroups(\n            centerVisibleColumns, this.gridBalancedTree, groupInstanceIdCreator, null, this.displayedCentreColumnTree);\n    }\n\n    private updateOpenClosedVisibilityInColumnGroups(): void {\n        const allColumnGroups = this.getAllDisplayedColumnGroups();\n\n        this.columnUtils.depthFirstAllColumnTreeSearch(allColumnGroups, child => {\n            if (child instanceof ColumnGroup) {\n                const columnGroup = child;\n                columnGroup.calculateDisplayedColumns();\n            }\n        });\n    }\n\n    public getGroupAutoColumns(): Column[] | null {\n        return this.groupAutoColumns;\n    }\n\n    private createGroupAutoColumnsIfNeeded(): void {\n        if (!this.autoGroupsNeedBuilding) { return; }\n\n        this.autoGroupsNeedBuilding = false;\n\n        const groupFullWidthRow = this.gridOptionsWrapper.isGroupUseEntireRow(this.pivotMode);\n        // we never suppress auto col for pivot mode, as there is no way for user to provide group columns\n        // in pivot mode. pivot mode has auto group column (provide by grid) and value columns (provided by\n        // pivot feature in the grid).\n        const groupSuppressAutoColumn = this.gridOptionsWrapper.isGroupSuppressAutoColumn() && !this.pivotMode;\n        const groupSuppressRow = this.gridOptionsWrapper.isGroupSuppressRow();\n        const groupingActive = this.rowGroupColumns.length > 0 || this.usingTreeData;\n        const needAutoColumns = groupingActive && !groupSuppressAutoColumn && !groupFullWidthRow && !groupSuppressRow;\n\n        if (needAutoColumns) {\n            const newAutoGroupCols = this.autoGroupColService.createAutoGroupColumns(this.rowGroupColumns);\n            const autoColsDifferent = !this.autoColsEqual(newAutoGroupCols, this.groupAutoColumns);\n            if (autoColsDifferent) {\n                this.groupAutoColumns = newAutoGroupCols;\n            }\n        } else {\n            this.groupAutoColumns = null;\n        }\n    }\n\n    private autoColsEqual(colsA: Column[], colsB: Column[]): boolean {\n        const bothMissing = !colsA && !colsB;\n\n        if (bothMissing) { return true; }\n\n        const atLeastOneListMissing = !colsA || !colsB;\n\n        if (atLeastOneListMissing || colsA.length !== colsB.length) { return false; }\n\n        for (let i = 0; i < colsA.length; i++) {\n            const colA = colsA[i];\n            const colB = colsB[i];\n            if (colA.getColId() !== colB.getColId()) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    private getWidthOfColsInList(columnList: Column[]) {\n        return columnList.reduce((width, col) => width + col.getActualWidth(), 0);\n    }\n\n    public getGridBalancedTree(): OriginalColumnGroupChild[] {\n        return this.gridBalancedTree;\n    }\n}\n"]}