{"version":3,"sources":["../../src/ts/columnController/columnUtils.ts"],"names":[],"mappings":"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","file":"columnUtils.js","sourcesContent":["import { GridOptionsWrapper } from \"../gridOptionsWrapper\";\nimport { ColumnGroupChild } from \"../entities/columnGroupChild\";\nimport { ColumnGroup } from \"../entities/columnGroup\";\nimport { OriginalColumnGroupChild } from \"../entities/originalColumnGroupChild\";\nimport { OriginalColumnGroup } from \"../entities/originalColumnGroup\";\nimport { Column } from \"../entities/column\";\nimport { Bean } from \"../context/context\";\nimport { Autowired } from \"../context/context\";\nimport { _ } from \"../utils\";\n\n// takes in a list of columns, as specified by the column definitions, and returns column groups\n@Bean('columnUtils')\nexport class ColumnUtils {\n\n    @Autowired('gridOptionsWrapper') private gridOptionsWrapper: GridOptionsWrapper;\n\n    public calculateColInitialWidth(colDef: any): number {\n        const optionsWrapper = this.gridOptionsWrapper;\n        const minColWidth = colDef.minWidth != null ? colDef.minWidth : optionsWrapper.getMinColWidth();\n        const maxColWidth = colDef.maxWidth != null ? colDef.maxWidth : (optionsWrapper.getMaxColWidth() || _.getMaxSafeInteger());\n        const width = colDef.width != null ? colDef.width : optionsWrapper.getColWidth();\n\n        return Math.max(Math.min(width, maxColWidth), minColWidth);\n    }\n\n    public getOriginalPathForColumn(column: Column, originalBalancedTree: OriginalColumnGroupChild[]): OriginalColumnGroup[] {\n        const result: OriginalColumnGroup[] = [];\n        let found = false;\n\n        const recursePath = (balancedColumnTree: OriginalColumnGroupChild[], dept: number): void => {\n            for (let i = 0; i < balancedColumnTree.length; i++) {\n                if (found) { return; }\n                    // quit the search, so 'result' is kept with the found result\n\n                const node = balancedColumnTree[i];\n                if (node instanceof OriginalColumnGroup) {\n                    const nextNode = node;\n                    recursePath(nextNode.getChildren(), dept + 1);\n                    result[dept] = node;\n                } else if (node === column) {\n                    found = true;\n                }\n            }\n        };\n\n        recursePath(originalBalancedTree, 0);\n\n        // we should always find the path, but in case there is a bug somewhere, returning null\n        // will make it fail rather than provide a 'hard to track down' bug\n        return found ? result : null;\n    }\n\n/*    public getPathForColumn(column: Column, allDisplayedColumnGroups: ColumnGroupChild[]): ColumnGroup[] {\n        let result: ColumnGroup[] = [];\n        let found = false;\n\n        recursePath(allDisplayedColumnGroups, 0);\n\n        // we should always find the path, but in case there is a bug somewhere, returning null\n        // will make it fail rather than provide a 'hard to track down' bug\n        if (found) {\n            return result;\n        } else {\n            return null;\n        }\n\n        function recursePath(balancedColumnTree: ColumnGroupChild[], dept: number): void {\n\n            for (let i = 0; i<balancedColumnTree.length; i++) {\n                if (found) {\n                    // quit the search, so 'result' is kept with the found result\n                    return;\n                }\n                let node = balancedColumnTree[i];\n                if (node instanceof ColumnGroup) {\n                    let nextNode = <ColumnGroup> node;\n                    recursePath(nextNode.getChildren(), dept+1);\n                    result[dept] = node;\n                } else {\n                    if (node === column) {\n                        found = true;\n                    }\n                }\n            }\n        }\n    }*/\n\n    public depthFirstOriginalTreeSearch(parent: OriginalColumnGroup | null, tree: OriginalColumnGroupChild[], callback: (treeNode: OriginalColumnGroupChild, parent: OriginalColumnGroup) => void): void {\n        if (!tree) { return; }\n\n        tree.forEach((child: OriginalColumnGroupChild) => {\n            if (child instanceof OriginalColumnGroup) {\n                this.depthFirstOriginalTreeSearch(child, child.getChildren(), callback);\n            }\n            callback(child, parent);\n        });\n\n    }\n\n    public depthFirstAllColumnTreeSearch(tree: ColumnGroupChild[] | null, callback: (treeNode: ColumnGroupChild) => void): void {\n        if (!tree) { return; }\n\n        tree.forEach((child: ColumnGroupChild) => {\n            if (child instanceof ColumnGroup) {\n                this.depthFirstAllColumnTreeSearch(child.getChildren(), callback);\n            }\n            callback(child);\n        });\n\n    }\n\n    public depthFirstDisplayedColumnTreeSearch(tree: ColumnGroupChild[], callback: (treeNode: ColumnGroupChild) => void): void {\n        if (!tree) { return; }\n\n        tree.forEach((child: ColumnGroupChild) => {\n            if (child instanceof ColumnGroup) {\n                this.depthFirstDisplayedColumnTreeSearch(child.getDisplayedChildren(), callback);\n            }\n            callback(child);\n        });\n    }\n}"]}