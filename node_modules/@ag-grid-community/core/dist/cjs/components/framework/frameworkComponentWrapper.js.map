{"version":3,"sources":["../../src/ts/components/framework/frameworkComponentWrapper.ts"],"names":[],"mappings":";;;;;;;;AAsBA;IAAA;IAqCA,CAAC;IApCG,mCAAI,GAAJ,UAAgC,mBAAmC,EACnC,mBAA6B,EAC7B,kBAAiC,EACjC,aAAsB;QAHtD,iBAgBC;QAd+B,mCAAA,EAAA,uBAAiC;QAE7D,IAAM,OAAO,GAAM,IAAI,CAAC,aAAa,CAAC,mBAAmB,EAAE,aAAa,CAAC,CAAC;QAE1E,mBAAmB,CAAC,OAAO,CAAC,CAAC,UAAA,UAAU;YACnC,KAAI,CAAC,YAAY,CAAC,OAAO,EAAE,UAAU,EAAE,IAAI,CAAC,CAAC;QACjD,CAAC,CAAC,CAAC,CAAC;QAEJ,kBAAkB,CAAC,OAAO,CAAC,CAAC,UAAA,UAAU;YAClC,KAAI,CAAC,YAAY,CAAC,OAAO,EAAE,UAAU,EAAE,KAAK,CAAC,CAAC;QAClD,CAAC,CAAC,CAAC,CAAC;QAEJ,OAAO,OAAmB,CAAC;IAE/B,CAAC;IAIO,2CAAY,GAApB,UAAqB,OAAU,EAAE,UAAkB,EAAE,SAAkB;QACnE,OAAO,CAAC,SAAS,CAAC,UAAU,EAAE,IAAI,CAAC,iBAAiB,CAAC,OAAO,EAAE,UAAU,EAAE,SAAS,CAAC,CAAC,CAAC;IAC1F,CAAC;IAES,gDAAiB,GAA3B,UAA4B,OAAU,EAAE,UAAkB,EAAE,SAAkB;QAC1E,OAAO;YACH,IAAI,OAAO,CAAC,SAAS,CAAC,UAAU,CAAC,EAAE;gBAC/B,OAAO,OAAO,CAAC,UAAU,CAAC,UAAU,EAAE,SAAS,CAAC,CAAC;aACpD;YAED,IAAI,SAAS,EAAE;gBACX,OAAO,CAAC,IAAI,CAAC,qDAAqD,GAAG,UAAU,GAAG,IAAI,CAAC,CAAC;aAC3F;YACD,OAAO,IAAI,CAAC;QAChB,CAAC,CAAC;IACN,CAAC;IACL,2BAAC;AAAD,CArCA,AAqCC,IAAA;AArCqB,oDAAoB","file":"frameworkComponentWrapper.js","sourcesContent":["import { IComponent } from \"../../interfaces/iComponent\";\n\n/**\n * B the business interface (ie IHeader)\n * A the agGridComponent interface (ie IHeaderComp). The final object acceptable by ag-grid\n */\nexport interface FrameworkComponentWrapper {\n    wrap<A extends IComponent<any>>(frameworkComponent: { new(): any },\n                                    methodList: string[],\n                                    optionalMethodList: string[],\n                                    componentName?: string\n    ): A;\n}\n\nexport interface WrapableInterface {\n    hasMethod(name: string): boolean;\n\n    callMethod(name: string, args: IArguments): void;\n\n    addMethod(name: string, callback: Function): void;\n}\n\nexport abstract class BaseComponentWrapper<F extends WrapableInterface> implements FrameworkComponentWrapper {\n    wrap<A extends IComponent<any>>(OriginalConstructor: { new(): any },\n                                    mandatoryMethodList: string[],\n                                    optionalMethodList: string[] = [],\n                                    componentName?: string): A {\n        const wrapper: F = this.createWrapper(OriginalConstructor, componentName);\n\n        mandatoryMethodList.forEach((methodName => {\n            this.createMethod(wrapper, methodName, true);\n        }));\n\n        optionalMethodList.forEach((methodName => {\n            this.createMethod(wrapper, methodName, false);\n        }));\n\n        return wrapper as any as A;\n\n    }\n\n    abstract createWrapper(OriginalConstructor: { new(): any }, componentName?: string): F;\n\n    private createMethod(wrapper: F, methodName: string, mandatory: boolean): void {\n        wrapper.addMethod(methodName, this.createMethodProxy(wrapper, methodName, mandatory));\n    }\n\n    protected createMethodProxy(wrapper: F, methodName: string, mandatory: boolean): Function {\n        return function() {\n            if (wrapper.hasMethod(methodName)) {\n                return wrapper.callMethod(methodName, arguments);\n            }\n\n            if (mandatory) {\n                console.warn('ag-Grid: Framework component is missing the method ' + methodName + '()');\n            }\n            return null;\n        };\n    }\n}"]}