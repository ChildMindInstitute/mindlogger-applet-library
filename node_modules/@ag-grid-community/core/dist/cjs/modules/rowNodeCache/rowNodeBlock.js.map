{"version":3,"sources":["../../src/ts/modules/rowNodeCache/rowNodeBlock.ts"],"names":[],"mappings":"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","file":"rowNodeBlock.js","sourcesContent":["import { NumberSequence, _ } from \"../../utils\";\nimport { RowNode } from \"../../entities/rowNode\";\nimport { Context } from \"../../context/context\";\nimport { BeanStub } from \"../../context/beanStub\";\nimport { RowNodeCacheParams } from \"./rowNodeCache\";\nimport { RowRenderer } from \"../../rendering/rowRenderer\";\nimport { AgEvent } from \"../../events\";\nimport {IRowNodeBlock} from \"../../interfaces/iRowNodeBlock\";\n\nexport interface RowNodeBlockBeans {\n    context: Context;\n    rowRenderer: RowRenderer;\n}\n\nexport interface LoadCompleteEvent extends AgEvent {\n    success: boolean;\n    page: RowNodeBlock;\n    lastRow: number;\n}\n\nexport abstract class RowNodeBlock extends BeanStub implements IRowNodeBlock {\n\n    public static EVENT_LOAD_COMPLETE = 'loadComplete';\n\n    public static STATE_DIRTY = 'dirty';\n    public static STATE_LOADING = 'loading';\n    public static STATE_LOADED = 'loaded';\n    public static STATE_FAILED = 'failed';\n\n    private version = 0;\n    private state = RowNodeBlock.STATE_DIRTY;\n\n    private lastAccessed: number;\n\n    private readonly blockNumber: number;\n    private readonly startRow: number;\n    private readonly endRow: number;\n    public rowNodes: RowNode[];\n\n    // because the framework cannot wire beans in parent classes, this is a hack\n    // to pass bean references up. give out to niall for not getting an IoC context\n    // that can do this yet\n    private beans: RowNodeBlockBeans;\n\n    private rowNodeCacheParams: RowNodeCacheParams;\n\n    // gets base class to load, based on what the datasource type is\n    protected abstract loadFromDatasource(): void;\n\n    // how we set the data and id is also dependent ton the base class, as the server side row model\n    // is concerned with groups (so has to set keys for the group)\n    protected abstract setDataAndId(rowNode: RowNode, data: any, index: number): void;\n\n    // this gets the row using display indexes. for infinite scrolling, the\n    // local index is the same as the display index, so the override just calls\n    // getRowUsingLocalIndex(). however for server side row model, they are different, hence\n    // server side row model does logic before calling getRowUsingLocalIndex().\n    public abstract getRow(displayIndex: number): RowNode | null;\n\n    // returns the node id prefix, which is essentially the id of the cache\n    // that the block belongs to. this is used for debugging purposes, where the\n    // user can get the state of the cache, it lets us include what cache the block\n    // belongs to\n    public abstract getNodeIdPrefix(): string;\n\n    protected constructor(blockNumber: number, rowNodeCacheParams: RowNodeCacheParams) {\n        super();\n\n        this.rowNodeCacheParams = rowNodeCacheParams;\n        this.blockNumber = blockNumber;\n\n        // we don't need to calculate these now, as the inputs don't change,\n        // however it makes the code easier to read if we work them out up front\n        this.startRow = blockNumber * rowNodeCacheParams.blockSize;\n        this.endRow = this.startRow + rowNodeCacheParams.blockSize;\n    }\n\n    public isAnyNodeOpen(rowCount: number): boolean {\n        let result = false;\n        this.forEachNodeCallback((rowNode: RowNode) => {\n            if (rowNode.expanded) {\n                result = true;\n            }\n        }, rowCount);\n        return result;\n    }\n\n    private forEachNodeCallback(callback: (rowNode: RowNode, index: number) => void, rowCount: number): void {\n        for (let rowIndex = this.startRow; rowIndex < this.endRow; rowIndex++) {\n            // we check against rowCount as this page may be the last one, and if it is, then\n            // the last rows are not part of the set\n            if (rowIndex < rowCount) {\n                const rowNode = this.getRowUsingLocalIndex(rowIndex);\n                callback(rowNode, rowIndex);\n            }\n        }\n    }\n\n    private forEachNode(callback: (rowNode: RowNode, index: number) => void, sequence: NumberSequence, rowCount: number, deep: boolean): void {\n        this.forEachNodeCallback((rowNode: RowNode) => {\n            callback(rowNode, sequence.next());\n            // this will only every happen for server side row model, as infinite\n            // row model doesn't have groups\n            if (deep && rowNode.childrenCache) {\n                rowNode.childrenCache.forEachNodeDeep(callback, sequence);\n            }\n        }, rowCount);\n    }\n\n    public forEachNodeDeep(callback: (rowNode: RowNode, index: number) => void, sequence: NumberSequence, rowCount: number): void {\n        this.forEachNode(callback, sequence, rowCount, true);\n    }\n\n    public forEachNodeShallow(callback: (rowNode: RowNode, index: number) => void, sequence: NumberSequence, rowCount: number): void {\n        this.forEachNode(callback, sequence, rowCount, false);\n    }\n\n    public getVersion(): number {\n        return this.version;\n    }\n\n    public getLastAccessed(): number {\n        return this.lastAccessed;\n    }\n\n    public getRowUsingLocalIndex(rowIndex: number, dontTouchLastAccessed = false): RowNode {\n        if (!dontTouchLastAccessed) {\n            this.lastAccessed = this.rowNodeCacheParams.lastAccessedSequence.next();\n        }\n        const localIndex = rowIndex - this.startRow;\n        return this.rowNodes[localIndex];\n    }\n\n    protected init(beans: RowNodeBlockBeans): void {\n        this.beans = beans;\n        this.createRowNodes();\n    }\n\n    public getStartRow(): number {\n        return this.startRow;\n    }\n\n    public getEndRow(): number {\n        return this.endRow;\n    }\n\n    public getBlockNumber(): number {\n        return this.blockNumber;\n    }\n\n    public setDirty(): void {\n        // in case any current loads in progress, this will have their results ignored\n        this.version++;\n        this.state = RowNodeBlock.STATE_DIRTY;\n    }\n\n    public setDirtyAndPurge(): void {\n        this.setDirty();\n        this.rowNodes.forEach(rowNode => {\n            rowNode.setData(null);\n        });\n    }\n\n    public getState(): string {\n        return this.state;\n    }\n\n    public setRowNode(rowIndex: number, rowNode: RowNode): void {\n        const localIndex = rowIndex - this.startRow;\n        this.rowNodes[localIndex] = rowNode;\n    }\n\n    public setBlankRowNode(rowIndex: number): RowNode {\n        const localIndex = rowIndex - this.startRow;\n        const newRowNode = this.createBlankRowNode(rowIndex);\n        this.rowNodes[localIndex] = newRowNode;\n        return newRowNode;\n    }\n\n    public setNewData(rowIndex: number, dataItem: any): RowNode {\n        const newRowNode = this.setBlankRowNode(rowIndex);\n        this.setDataAndId(newRowNode, dataItem, this.startRow + rowIndex);\n        return newRowNode;\n    }\n\n    protected createBlankRowNode(rowIndex: number): RowNode {\n        const rowNode = new RowNode();\n        this.beans.context.wireBean(rowNode);\n        rowNode.setRowHeight(this.rowNodeCacheParams.rowHeight);\n        return rowNode;\n    }\n\n    // creates empty row nodes, data is missing as not loaded yet\n    protected createRowNodes(): void {\n        this.rowNodes = [];\n        for (let i = 0; i < this.rowNodeCacheParams.blockSize; i++) {\n            const rowIndex = this.startRow + i;\n            const rowNode = this.createBlankRowNode(rowIndex);\n            this.rowNodes.push(rowNode);\n        }\n    }\n\n    public load(): void {\n        this.state = RowNodeBlock.STATE_LOADING;\n        this.loadFromDatasource();\n    }\n\n    protected pageLoadFailed() {\n        this.state = RowNodeBlock.STATE_FAILED;\n        const event: LoadCompleteEvent = {\n            type: RowNodeBlock.EVENT_LOAD_COMPLETE,\n            success: false,\n            page: this,\n            lastRow: null\n        };\n        this.dispatchEvent(event);\n    }\n\n    private populateWithRowData(rows: any[]): void {\n        const rowNodesToRefresh: RowNode[] = [];\n        this.rowNodes.forEach((rowNode: RowNode, index: number) => {\n            const data = rows[index];\n            if (rowNode.stub) {\n                rowNodesToRefresh.push(rowNode);\n            }\n            this.setDataAndId(rowNode, data, this.startRow + index);\n        });\n        if (rowNodesToRefresh.length > 0) {\n            this.beans.rowRenderer.redrawRows(rowNodesToRefresh);\n        }\n    }\n\n    public destroy(): void {\n        super.destroy();\n        this.rowNodes.forEach(rowNode => {\n            if (rowNode.childrenCache) {\n                rowNode.childrenCache.destroy();\n                rowNode.childrenCache = null;\n            }\n            // this is needed, so row render knows to fade out the row, otherwise it\n            // sees row top is present, and thinks the row should be shown. maybe\n            // rowNode should have a flag on whether it is visible???\n            rowNode.clearRowTop();\n        });\n    }\n\n    protected pageLoaded(version: number, rows: any[], lastRow: number) {\n        // we need to check the version, in case there was an old request\n        // from the server that was sent before we refreshed the cache,\n        // if the load was done as a result of a cache refresh\n        if (version === this.version) {\n            this.state = RowNodeBlock.STATE_LOADED;\n            this.populateWithRowData(rows);\n        }\n\n        lastRow = _.cleanNumber(lastRow);\n\n        // check here if lastRow should be set\n        const event: LoadCompleteEvent = {\n            type: RowNodeBlock.EVENT_LOAD_COMPLETE,\n            success: true,\n            page: this,\n            lastRow: lastRow\n        };\n\n        this.dispatchEvent(event);\n    }\n\n}\n"]}