{"version":3,"sources":["../../src/ts/modules/rowNodeCache/rowNodeCache.ts"],"names":[],"mappings":"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","file":"rowNodeCache.js","sourcesContent":["import { RowNode } from \"../../entities/rowNode\";\nimport { BeanStub } from \"../../context/beanStub\";\nimport { RowNodeBlock } from \"./rowNodeBlock\";\nimport { Logger } from \"../../logger\";\nimport { RowNodeBlockLoader } from \"./rowNodeBlockLoader\";\nimport { AgEvent } from \"../../events\";\nimport { NumberSequence,  _ } from \"../../utils\";\nimport {IRowNodeBlock} from \"../../interfaces/iRowNodeBlock\";\n\nexport interface RowNodeCacheParams {\n    initialRowCount: number;\n    blockSize?: number;\n    overflowSize: number;\n    sortModel: any;\n    filterModel: any;\n    maxBlocksInCache?: number;\n    rowHeight: number;\n    lastAccessedSequence: NumberSequence;\n    maxConcurrentRequests?: number;\n    rowNodeBlockLoader?: RowNodeBlockLoader;\n    dynamicRowHeight: boolean;\n}\n\nexport interface CacheUpdatedEvent extends AgEvent {\n\n}\n\nexport abstract class RowNodeCache<T extends IRowNodeBlock, P extends RowNodeCacheParams> extends BeanStub {\n\n    public static EVENT_CACHE_UPDATED = 'cacheUpdated';\n\n    // this property says how many empty blocks should be in a cache, eg if scrolls down fast and creates 10\n    // blocks all for loading, the grid will only load the last 2 - it will assume the blocks the user quickly\n    // scrolled over are not needed to be loaded.\n    private static MAX_EMPTY_BLOCKS_TO_KEEP = 2;\n\n    private virtualRowCount: number;\n    private maxRowFound = false;\n\n    protected cacheParams: P;\n\n    private active: boolean;\n\n    public blocks: {[blockNumber: string]: T} = {};\n    private blockCount = 0;\n\n    protected logger: Logger;\n\n    public abstract getRow(rowIndex: number): RowNode | null;\n\n    protected constructor(cacheParams: P) {\n        super();\n        this.virtualRowCount = cacheParams.initialRowCount;\n        this.cacheParams = cacheParams;\n    }\n\n    public destroy(): void {\n        super.destroy();\n        this.forEachBlockInOrder(block => this.destroyBlock(block));\n    }\n\n    protected init(): void {\n        this.active = true;\n        this.addDestroyFunc(() => this.active = false);\n    }\n\n    public isActive(): boolean {\n        return this.active;\n    }\n\n    public getVirtualRowCount(): number {\n        return this.virtualRowCount;\n    }\n\n    public hack_setVirtualRowCount(virtualRowCount: number): void {\n        this.virtualRowCount = virtualRowCount;\n    }\n\n    public isMaxRowFound(): boolean {\n        return this.maxRowFound;\n    }\n\n    // listener on EVENT_LOAD_COMPLETE\n    protected onPageLoaded(event: any): void {\n        this.cacheParams.rowNodeBlockLoader.loadComplete();\n        this.checkBlockToLoad();\n\n        // if we are not active, then we ignore all events, otherwise we could end up getting the\n        // grid to refresh even though we are no longer the active cache\n        if (!this.isActive()) {\n            return;\n        }\n\n        this.logger.log(`onPageLoaded: page = ${event.page.getBlockNumber()}, lastRow = ${event.lastRow}`);\n\n        if (event.success) {\n            this.checkVirtualRowCount(event.page, event.lastRow);\n        }\n    }\n\n    private purgeBlocksIfNeeded(blockToExclude: T): void {\n        // put all candidate blocks into a list for sorting\n        const blocksForPurging: T[] = [];\n        this.forEachBlockInOrder((block: T) => {\n            // we exclude checking for the page just created, as this has yet to be accessed and hence\n            // the lastAccessed stamp will not be updated for the first time yet\n            if (block === blockToExclude) {\n                return;\n            }\n\n            blocksForPurging.push(block);\n        });\n\n        // note: need to verify that this sorts items in the right order\n        blocksForPurging.sort((a: T, b: T) => b.getLastAccessed() - a.getLastAccessed());\n\n        // we remove (maxBlocksInCache - 1) as we already excluded the 'just created' page.\n        // in other words, after the splice operation below, we have taken out the blocks\n        // we want to keep, which means we are left with blocks that we can potentially purge\n        const maxBlocksProvided = this.cacheParams.maxBlocksInCache > 0;\n        const blocksToKeep = maxBlocksProvided ? this.cacheParams.maxBlocksInCache - 1 : null;\n        const emptyBlocksToKeep = RowNodeCache.MAX_EMPTY_BLOCKS_TO_KEEP - 1;\n\n        blocksForPurging.forEach((block: T, index: number) => {\n\n            const purgeBecauseBlockEmpty = block.getState() === RowNodeBlock.STATE_DIRTY && index >= emptyBlocksToKeep;\n\n            const purgeBecauseCacheFull = maxBlocksProvided ? index >= blocksToKeep : false;\n\n            if (purgeBecauseBlockEmpty || purgeBecauseCacheFull) {\n\n                // we never purge blocks if they are open, as purging them would mess up with\n                // our indexes, it would be very messy to restore the purged block to it's\n                // previous state if it had open children (and what if open children of open\n                // children, jeeeesus, just thinking about it freaks me out) so best is have a\n                // rule, if block is open, we never purge.\n                if (block.isAnyNodeOpen(this.virtualRowCount)) { return; }\n                // at this point, block is not needed, and no open nodes, so burn baby burn\n                this.removeBlockFromCache(block);\n\n            }\n\n        });\n    }\n\n    protected postCreateBlock(newBlock: T): void {\n        newBlock.addEventListener(RowNodeBlock.EVENT_LOAD_COMPLETE, this.onPageLoaded.bind(this));\n        this.setBlock(newBlock.getBlockNumber(), newBlock);\n        this.purgeBlocksIfNeeded(newBlock);\n        this.checkBlockToLoad();\n    }\n\n    protected removeBlockFromCache(blockToRemove: T): void {\n        if (!blockToRemove) {\n            return;\n        }\n\n        this.destroyBlock(blockToRemove);\n\n        // we do not want to remove the 'loaded' event listener, as the\n        // concurrent loads count needs to be updated when the load is complete\n        // if the purged page is in loading state\n    }\n\n    // gets called after: 1) block loaded 2) block created 3) cache refresh\n    protected checkBlockToLoad() {\n        this.cacheParams.rowNodeBlockLoader.checkBlockToLoad();\n    }\n\n    protected checkVirtualRowCount(block: T, lastRow: any): void {\n        // if client provided a last row, we always use it, as it could change between server calls\n        // if user deleted data and then called refresh on the grid.\n        if (typeof lastRow === 'number' && lastRow >= 0) {\n            this.virtualRowCount = lastRow;\n            this.maxRowFound = true;\n            this.onCacheUpdated();\n        } else if (!this.maxRowFound) {\n            // otherwise, see if we need to add some virtual rows\n            const lastRowIndex = (block.getBlockNumber() + 1) * this.cacheParams.blockSize;\n            const lastRowIndexPlusOverflow = lastRowIndex + this.cacheParams.overflowSize;\n\n            if (this.virtualRowCount < lastRowIndexPlusOverflow) {\n                this.virtualRowCount = lastRowIndexPlusOverflow;\n                this.onCacheUpdated();\n            } else if (this.cacheParams.dynamicRowHeight) {\n                // the only other time is if dynamic row height, as loading rows\n                // will change the height of the block, given the height of the rows\n                // is only known after the row is loaded.\n                this.onCacheUpdated();\n            }\n        }\n    }\n\n    public setVirtualRowCount(rowCount: number, maxRowFound?: boolean): void {\n        this.virtualRowCount = rowCount;\n        // if undefined is passed, we do not set this value, if one of {true,false}\n        // is passed, we do set the value.\n        if (_.exists(maxRowFound)) {\n            this.maxRowFound = maxRowFound;\n        }\n\n        // if we are still searching, then the row count must not end at the end\n        // of a particular page, otherwise the searching will not pop into the\n        // next page\n        if (!this.maxRowFound) {\n            if (this.virtualRowCount % this.cacheParams.blockSize === 0) {\n                this.virtualRowCount++;\n            }\n        }\n\n        this.onCacheUpdated();\n    }\n\n    public forEachNodeDeep(callback: (rowNode: RowNode, index: number) => void, sequence = new NumberSequence()): void {\n        this.forEachBlockInOrder(block => {\n            block.forEachNodeDeep(callback, sequence, this.virtualRowCount);\n        });\n    }\n\n    public forEachBlockInOrder(callback: (block: T, id: number) => void): void {\n        const ids = this.getBlockIdsSorted();\n        this.forEachBlockId(ids, callback);\n    }\n\n    protected forEachBlockInReverseOrder(callback: (block: T, id: number) => void): void {\n        const ids = this.getBlockIdsSorted().reverse();\n        this.forEachBlockId(ids, callback);\n    }\n\n    private forEachBlockId(ids: number[], callback: (block: T, id: number) => void): void {\n        ids.forEach(id => {\n            const block = this.blocks[id];\n            callback(block, id);\n        });\n    }\n\n    protected getBlockIdsSorted(): number[] {\n        // get all page id's as NUMBERS (not strings, as we need to sort as numbers) and in descending order\n        const numberComparator = (a: number, b: number) => a - b; // default comparator for array is string comparison\n        const blockIds = Object.keys(this.blocks).map(idStr => parseInt(idStr, 10)).sort(numberComparator);\n        return blockIds;\n    }\n\n    protected getBlock(blockId: string | number): T {\n        return this.blocks[blockId];\n    }\n\n    protected setBlock(id: number, block: T): void {\n        this.blocks[id] = block;\n        this.blockCount++;\n        this.cacheParams.rowNodeBlockLoader.addBlock(block);\n    }\n\n    protected destroyBlock(block: T): void {\n        delete this.blocks[block.getBlockNumber()];\n        block.destroy();\n        this.blockCount--;\n        this.cacheParams.rowNodeBlockLoader.removeBlock(block);\n    }\n\n    // gets called 1) row count changed 2) cache purged 3) items inserted\n    protected onCacheUpdated(): void {\n        if (this.isActive()) {\n            // this results in both row models (infinite and server side) firing ModelUpdated,\n            // however server side row model also updates the row indexes first\n            const event: CacheUpdatedEvent = {\n                type: RowNodeCache.EVENT_CACHE_UPDATED\n            };\n            this.dispatchEvent(event);\n        }\n    }\n\n    public purgeCache(): void {\n        this.forEachBlockInOrder(block => this.removeBlockFromCache(block));\n\n        if (this.virtualRowCount === 0) {\n            // re-initialise cache - this ensures a cache with no rows can reload when purged!\n            this.virtualRowCount = this.cacheParams.initialRowCount;\n            this.maxRowFound = false;\n        }\n\n        this.onCacheUpdated();\n    }\n\n    public getRowNodesInRange(firstInRange: RowNode, lastInRange: RowNode): RowNode[] {\n        const result: RowNode[] = [];\n\n        let lastBlockId = -1;\n        let inActiveRange = false;\n        const numberSequence: NumberSequence = new NumberSequence();\n\n        // if only one node passed, we start the selection at the top\n        if (_.missing(firstInRange)) {\n            inActiveRange = true;\n        }\n\n        let foundGapInSelection = false;\n\n        this.forEachBlockInOrder((block: IRowNodeBlock, id: number) => {\n            if (foundGapInSelection) { return; }\n\n            if (inActiveRange && (lastBlockId + 1 !== id)) {\n                foundGapInSelection = true;\n                return;\n            }\n\n            lastBlockId = id;\n\n            block.forEachNodeShallow(rowNode => {\n                const hitFirstOrLast = rowNode === firstInRange || rowNode === lastInRange;\n                if (inActiveRange || hitFirstOrLast) {\n                    result.push(rowNode);\n                }\n\n                if (hitFirstOrLast) {\n                    inActiveRange = !inActiveRange;\n                }\n\n            }, numberSequence, this.virtualRowCount);\n        });\n\n        // inActiveRange will be still true if we never hit the second rowNode\n        const invalidRange = foundGapInSelection || inActiveRange;\n        return invalidRange ? [] : result;\n    }\n}\n"]}