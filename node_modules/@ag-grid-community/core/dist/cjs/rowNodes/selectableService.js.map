{"version":3,"sources":["../../src/ts/rowNodes/selectableService.ts"],"names":[],"mappings":";;;;;;;;;;;;;;AACA,8CAAoE;AAGpE,kCAA6B;AAG7B;IAAA;IAmDA,CAAC;IA3CU,gCAAI,GAAX;QACI,IAAI,CAAC,oBAAoB,GAAG,IAAI,CAAC,kBAAkB,CAAC,sBAAsB,EAAE,CAAC;QAC7E,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC,kBAAkB,CAAC,sBAAsB,EAAE,CAAC;IAChF,CAAC;IAEM,yDAA6B,GAApC,UAAqC,OAAgB;QACjD,IAAI,IAAI,CAAC,mBAAmB,EAAE;YAC1B,IAAM,gBAAgB,GAAG,UAAC,OAAgB,IAAK,OAAA,OAAO,CAAC,kBAAkB,EAA1B,CAA0B,CAAC;YAC1E,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,kBAAkB,EAAE,gBAAgB,CAAC,CAAC;SAClE;IACL,CAAC;IAEM,0DAA8B,GAArC,UAAsC,OAAgB;QAClD,IAAI,IAAI,CAAC,mBAAmB,EAAE;YAC1B,IAAM,gBAAgB,GAAG,UAAC,OAAgB,IAAK,OAAA,OAAO,CAAC,mBAAmB,EAA3B,CAA2B,CAAC;YAC3E,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,kBAAkB,EAAE,gBAAgB,CAAC,CAAC;SAClE;IACL,CAAC;IAEO,uCAAW,GAAnB,UAAoB,QAAmB,EAAE,gBAAiD;QAA1F,iBAsBC;QArBG,QAAQ,CAAC,OAAO,CAAC,UAAC,KAAc;YAE5B,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE;gBAAE,OAAO;aAAE,CAAC,4BAA4B;YAE1D,IAAI,KAAK,CAAC,WAAW,EAAE,EAAE;gBACrB,KAAI,CAAC,WAAW,CAAC,gBAAgB,CAAC,KAAK,CAAC,EAAE,gBAAgB,CAAC,CAAC;aAC/D;YAED,IAAI,aAAsB,CAAC;YAE3B,IAAI,KAAI,CAAC,oBAAoB,EAAE;gBAC3B,wEAAwE;gBACxE,IAAM,eAAe,GAAG,SAAC,CAAC,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC,EAAE,YAAY,EAAE,IAAI,CAAC,CAAC;gBAC5E,aAAa,GAAG,SAAC,CAAC,MAAM,CAAC,eAAe,CAAC,CAAC;aAC7C;iBAAM;gBACH,wDAAwD;gBACxD,aAAa,GAAG,KAAI,CAAC,mBAAmB,CAAC,CAAC,CAAC,KAAI,CAAC,mBAAmB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;aACtF;YAED,KAAK,CAAC,gBAAgB,CAAC,aAAa,CAAC,CAAC;QAC1C,CAAC,CAAC,CAAC;IACP,CAAC;IA/CgC;QAAhC,mBAAS,CAAC,oBAAoB,CAAC;iEAAgD;IAMhF;QADC,uBAAa;iDAIb;IAXQ,iBAAiB;QAD7B,cAAI,CAAC,mBAAmB,CAAC;OACb,iBAAiB,CAmD7B;IAAD,wBAAC;CAnDD,AAmDC,IAAA;AAnDY,8CAAiB","file":"selectableService.js","sourcesContent":["import { RowNode } from \"../entities/rowNode\";\nimport { Autowired, Bean, PostConstruct } from \"../context/context\";\nimport { GridOptionsWrapper } from \"../gridOptionsWrapper\";\nimport { IsRowSelectable } from \"../entities/gridOptions\";\nimport { _ } from \"../utils\";\n\n@Bean('selectableService')\nexport class SelectableService {\n\n    @Autowired('gridOptionsWrapper') private gridOptionsWrapper: GridOptionsWrapper;\n\n    private groupSelectsChildren: boolean;\n    private isRowSelectableFunc?: IsRowSelectable;\n\n    @PostConstruct\n    public init(): void {\n        this.groupSelectsChildren = this.gridOptionsWrapper.isGroupSelectsChildren();\n        this.isRowSelectableFunc = this.gridOptionsWrapper.getIsRowSelectableFunc();\n    }\n\n    public updateSelectableAfterGrouping(rowNode: RowNode): void {\n        if (this.isRowSelectableFunc) {\n            const nextChildrenFunc = (rowNode: RowNode) => rowNode.childrenAfterGroup;\n            this.recurseDown(rowNode.childrenAfterGroup, nextChildrenFunc);\n        }\n    }\n\n    public updateSelectableAfterFiltering(rowNode: RowNode): void {\n        if (this.isRowSelectableFunc) {\n            const nextChildrenFunc = (rowNode: RowNode) => rowNode.childrenAfterFilter;\n            this.recurseDown(rowNode.childrenAfterGroup, nextChildrenFunc);\n        }\n    }\n\n    private recurseDown(children: RowNode[], nextChildrenFunc: (rowNode: RowNode) => RowNode[]): void {\n        children.forEach((child: RowNode) => {\n\n            if (!child.group) { return; } // only interested in groups\n\n            if (child.hasChildren()) {\n                this.recurseDown(nextChildrenFunc(child), nextChildrenFunc);\n            }\n\n            let rowSelectable: boolean;\n\n            if (this.groupSelectsChildren) {\n                // have this group selectable if at least one direct child is selectable\n                const firstSelectable = _.find(nextChildrenFunc(child), 'selectable', true);\n                rowSelectable = _.exists(firstSelectable);\n            } else {\n                // directly retrieve selectable value from user callback\n                rowSelectable = this.isRowSelectableFunc ? this.isRowSelectableFunc(child) : false;\n            }\n\n            child.setRowSelectable(rowSelectable);\n        });\n    }\n\n}"]}