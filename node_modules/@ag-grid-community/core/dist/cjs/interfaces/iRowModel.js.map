{"version":3,"sources":["../../src/ts/interfaces/iRowModel.ts"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA","file":"iRowModel.js","sourcesContent":["import { RowNode } from \"../entities/rowNode\";\n\nexport interface RowBounds {\n    rowTop: number;\n    rowHeight: number;\n    rowIndex?: number;\n}\n\nexport interface IRowModel {\n\n    /** Returns the rowNode at the given index. */\n    getRow(index: number): RowNode | null;\n\n    /** Returns the rowNode for given id. */\n    getRowNode(id: string): RowNode | null;\n\n    /** This is legacy, not used by ag-Grid, but keeping for backward compatibility */\n    getRowCount(): number;\n\n    getTopLevelRowCount(): number;\n    getTopLevelRowDisplayedIndex(topLevelIndex: number): number;\n\n    /** Returns the row index at the given pixel */\n    getRowIndexAtPixel(pixel: number): number;\n    /** Returns total height of all the rows - used to size the height of the grid div that contains the rows */\n    getCurrentPageHeight(): number;\n    /** Returns true if the provided rowNode is in the list of rows to render */\n    isRowPresent(rowNode: RowNode): boolean;\n    /** Returns row top and bottom for a given row */\n    getRowBounds(index: number): RowBounds | null;\n\n    /** Returns true if this model has no rows, regardless of model filter. EG if rows present, but filtered\n     * out, this still returns false. If it returns true, then the grid shows the 'no rows' overlay - but we\n     * don't show that overlay if the rows are just filtered out. */\n    isEmpty(): boolean;\n    /** Returns true if no rows (either no rows at all, or the rows are filtered out). This is what the grid\n     * uses to know if there are rows to render or not. */\n    isRowsToRender(): boolean;\n\n    /** Returns all rows in range that should be selected. If there is a gap in range (non ClientSideRowModel) then\n     *  then no rows should be returned  */\n    getNodesInRangeForSelection(first: RowNode, last: RowNode): RowNode[];\n\n    /** Iterate through each node. What this does depends on the model type. For clientSide, goes through\n     * all nodes. For pagination, goes through current page. For virtualPage, goes through what's loaded in memory. */\n    forEachNode(callback: (rowNode: RowNode, index: number) => void): void;\n\n    /** The base class returns the type. We use this instead of 'instanceof' as the client might provide\n     * their own implementation of the models in the future. */\n    getType(): string;\n    /**\n     * It tells us if this row model knows about the last row that it can produce. This is used by the\n     * PaginationPanel, if last row is not found, then the 'last' button is disabled and the last page is\n     * not shown. This is always true for ClientSideRowModel. It toggles for InfiniteRowModel.\n     */\n    isLastRowFound(): boolean;\n\n    /** Used by CSRM only - is makes sure there are now estimated row heights within the range. */\n    ensureRowHeightsValid(startPixel: number, endPixel: number, startLimitIndex: number, endLimitIndex: number): boolean;\n\n    /** Gets called after grid is initialised. What happens depends on row model. Client Side will take rowData\n     * from gridOptions, the other row models will start calling their datasources. */\n    start(): void;\n}"]}