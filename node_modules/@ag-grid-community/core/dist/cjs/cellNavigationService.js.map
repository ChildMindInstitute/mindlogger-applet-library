{"version":3,"sources":["../../src/ts/cellNavigationService.ts"],"names":[],"mappings":"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","file":"cellNavigationService.js","sourcesContent":["import { Autowired, Bean } from \"./context/context\";\nimport { Constants } from \"./constants\";\nimport { ColumnController } from \"./columnController/columnController\";\nimport { IRowModel } from \"./interfaces/iRowModel\";\nimport { CellPosition } from \"./entities/cellPosition\";\nimport { GridOptionsWrapper } from \"./gridOptionsWrapper\";\nimport { RowNode } from \"./entities/rowNode\";\nimport { Column } from \"./entities/column\";\nimport { _ } from \"./utils\";\nimport { RowPosition } from \"./entities/rowPosition\";\nimport {PinnedRowModel} from \"./pinnedRowModel/pinnedRowModel\";\n\n@Bean('cellNavigationService')\nexport class CellNavigationService {\n\n    @Autowired('columnController') private columnController: ColumnController;\n    @Autowired('rowModel') private rowModel: IRowModel;\n    @Autowired('pinnedRowModel') private pinnedRowModel: PinnedRowModel;\n    @Autowired('gridOptionsWrapper') private gridOptionsWrapper: GridOptionsWrapper;\n\n    // returns null if no cell to focus on, ie at the end of the grid\n    public getNextCellToFocus(key: any, lastCellToFocus: CellPosition): CellPosition | null {\n\n        // starting with the provided cell, we keep moving until we find a cell we can\n        // focus on.\n        let pointer: CellPosition | null = lastCellToFocus;\n        let finished = false;\n\n        // finished will be true when either:\n        // a) cell found that we can focus on\n        // b) run out of cells (ie the method returns null)\n        while (!finished) {\n\n            switch (key) {\n                case Constants.KEY_UP :\n                    pointer = this.getCellAbove(pointer);\n                    break;\n                case Constants.KEY_DOWN :\n                    pointer = this.getCellBelow(pointer);\n                    break;\n                case Constants.KEY_RIGHT :\n                    if (this.gridOptionsWrapper.isEnableRtl()) {\n                        pointer = this.getCellToLeft(pointer);\n                    } else {\n                        pointer = this.getCellToRight(pointer);\n                    }\n                    break;\n                case Constants.KEY_LEFT :\n                    if (this.gridOptionsWrapper.isEnableRtl()) {\n                        pointer = this.getCellToRight(pointer);\n                    } else {\n                        pointer = this.getCellToLeft(pointer);\n                    }\n                    break;\n                default :\n                    pointer = null;\n                    console.warn('ag-Grid: unknown key for navigation ' + key);\n                    break;\n            }\n\n            if (pointer) {\n                finished = this.isCellGoodToFocusOn(pointer);\n            } else {\n                finished = true;\n            }\n        }\n\n        return pointer;\n    }\n\n    private isCellGoodToFocusOn(gridCell: CellPosition): boolean {\n        const column: Column = gridCell.column;\n        let rowNode: RowNode;\n\n        switch (gridCell.rowPinned) {\n            case Constants.PINNED_TOP:\n                rowNode = this.pinnedRowModel.getPinnedTopRow(gridCell.rowIndex);\n                break;\n            case Constants.PINNED_BOTTOM:\n                rowNode = this.pinnedRowModel.getPinnedBottomRow(gridCell.rowIndex);\n                break;\n            default:\n                rowNode = this.rowModel.getRow(gridCell.rowIndex);\n                break;\n        }\n\n        const suppressNavigable = column.isSuppressNavigable(rowNode);\n        return !suppressNavigable;\n    }\n\n    private getCellToLeft(lastCell: CellPosition | null): CellPosition | null {\n        if (!lastCell) {\n            return null;\n        }\n\n        const colToLeft = this.columnController.getDisplayedColBefore(lastCell.column);\n        if (!colToLeft) {\n            return null;\n        }\n\n        return {\n            rowIndex: lastCell.rowIndex,\n            column: colToLeft,\n            rowPinned: lastCell.rowPinned\n        } as CellPosition;\n    }\n\n    private getCellToRight(lastCell: CellPosition | null): CellPosition | null {\n        if (!lastCell) {\n            return null;\n        }\n\n        const colToRight = this.columnController.getDisplayedColAfter(lastCell.column);\n        // if already on right, do nothing\n        if (!colToRight) {\n            return null;\n        }\n\n        return {\n            rowIndex: lastCell.rowIndex,\n            column: colToRight,\n            rowPinned: lastCell.rowPinned\n        } as CellPosition;\n    }\n\n    public getRowBelow(rowPosition: RowPosition): RowPosition | null {\n        // if already on top row, do nothing\n        const index = rowPosition.rowIndex;\n        const pinned = rowPosition.rowPinned;\n        if (this.isLastRowInContainer(rowPosition)) {\n            switch (pinned) {\n                case Constants.PINNED_BOTTOM:\n                    // never any rows after pinned bottom\n                    return null;\n                case Constants.PINNED_TOP:\n                    // if on last row of pinned top, then next row is main body (if rows exist),\n                    // otherwise it's the pinned bottom\n                    if (this.rowModel.isRowsToRender()) {\n                        return {rowIndex: 0, rowPinned: null} as RowPosition;\n                    } else if (this.pinnedRowModel.isRowsToRender(Constants.PINNED_BOTTOM)) {\n                        return {rowIndex: 0, rowPinned: Constants.PINNED_BOTTOM} as RowPosition;\n                    }\n\n                    return null;\n                default:\n                    // if in the main body, then try pinned bottom, otherwise return nothing\n                    if (this.pinnedRowModel.isRowsToRender(Constants.PINNED_BOTTOM)) {\n                        return {rowIndex: 0, rowPinned: Constants.PINNED_BOTTOM} as RowPosition;\n                    }\n                    return null;\n            }\n        }\n\n        return {rowIndex: index + 1, rowPinned: pinned} as RowPosition;\n    }\n\n    private getCellBelow(lastCell: CellPosition | null): CellPosition | null {\n        if (!lastCell) {\n            return null;\n        }\n\n        const rowBelow = this.getRowBelow(lastCell);\n        if (rowBelow) {\n            return {\n                rowIndex: rowBelow.rowIndex,\n                column: lastCell.column,\n                rowPinned: rowBelow.rowPinned\n            } as CellPosition;\n        }\n\n        return null;\n    }\n\n    private isLastRowInContainer(rowPosition: RowPosition): boolean {\n        const pinned = rowPosition.rowPinned;\n        const index = rowPosition.rowIndex;\n\n        if (pinned === Constants.PINNED_TOP) {\n            const lastTopIndex = this.pinnedRowModel.getPinnedTopRowData().length - 1;\n            return lastTopIndex <= index;\n        } else if (pinned === Constants.PINNED_BOTTOM) {\n            const lastBottomIndex = this.pinnedRowModel.getPinnedBottomRowData().length - 1;\n            return lastBottomIndex <= index;\n        }\n\n        const lastBodyIndex = this.rowModel.getRowCount() - 1;\n        return lastBodyIndex <= index;\n    }\n\n    public getRowAbove(rowPosition: RowPosition): RowPosition | null {\n            // if already on top row, do nothing\n            const index = rowPosition.rowIndex;\n            const pinned = rowPosition.rowPinned;\n        // if already on top row, do nothing\n        if (index === 0) {\n            if (pinned === Constants.PINNED_TOP) {\n                return null;\n            } else if (!pinned) {\n                if (this.pinnedRowModel.isRowsToRender(Constants.PINNED_TOP)) {\n                    return this.getLastFloatingTopRow();\n                }\n                return null;\n            } else {\n                // last floating bottom\n                if (this.rowModel.isRowsToRender()) {\n                    return this.getLastBodyCell();\n                } else if (this.pinnedRowModel.isRowsToRender(Constants.PINNED_TOP)) {\n                    return this.getLastFloatingTopRow();\n                }\n                return null;\n            }\n        }\n\n        return {rowIndex: index - 1, rowPinned: pinned} as RowPosition;\n    }\n\n    private getCellAbove(lastCell: CellPosition | null): CellPosition | null {\n        if (!lastCell) {\n            return null;\n        }\n\n        const rowAbove = this.getRowAbove({ rowIndex: lastCell.rowIndex, rowPinned: lastCell.rowPinned });\n        if (rowAbove) {\n            return {\n                rowIndex: rowAbove.rowIndex,\n                column: lastCell.column,\n                rowPinned: rowAbove.rowPinned\n            } as CellPosition;\n        }\n\n        return null;\n    }\n\n    private getLastBodyCell(): RowPosition {\n        const lastBodyRow = this.rowModel.getRowCount() - 1;\n        return {rowIndex: lastBodyRow, rowPinned: null} as RowPosition;\n    }\n\n    private getLastFloatingTopRow(): RowPosition {\n        const lastFloatingRow = this.pinnedRowModel.getPinnedTopRowData().length - 1;\n        return {rowIndex: lastFloatingRow, rowPinned: Constants.PINNED_TOP} as RowPosition;\n    }\n\n    public getNextTabbedCell(gridCell: CellPosition, backwards: boolean): CellPosition | null {\n        if (backwards) {\n            return this.getNextTabbedCellBackwards(gridCell);\n        }\n\n        return this.getNextTabbedCellForwards(gridCell);\n    }\n\n    public getNextTabbedCellForwards(gridCell: CellPosition): CellPosition | null {\n        const displayedColumns = this.columnController.getAllDisplayedColumns();\n\n        let newRowIndex: number | null = gridCell.rowIndex;\n        let newFloating: string | null = gridCell.rowPinned;\n\n        // move along to the next cell\n        let newColumn = this.columnController.getDisplayedColAfter(gridCell.column);\n\n        // check if end of the row, and if so, go forward a row\n        if (!newColumn) {\n            newColumn = displayedColumns[0];\n\n            const rowBelow = this.getRowBelow(gridCell);\n            if (_.missing(rowBelow)) {\n                return null;\n            }\n            newRowIndex = rowBelow ? rowBelow.rowIndex : null;\n            newFloating = rowBelow ? rowBelow.rowPinned : null;\n        }\n\n        return {rowIndex: newRowIndex, column: newColumn, rowPinned: newFloating} as CellPosition;\n    }\n\n    public getNextTabbedCellBackwards(gridCell: CellPosition): CellPosition | null {\n\n        const displayedColumns = this.columnController.getAllDisplayedColumns();\n\n        let newRowIndex: number | null = gridCell.rowIndex;\n        let newFloating: string | null = gridCell.rowPinned;\n\n        // move along to the next cell\n        let newColumn = this.columnController.getDisplayedColBefore(gridCell.column);\n\n        // check if end of the row, and if so, go forward a row\n        if (!newColumn) {\n            newColumn = _.last(displayedColumns);\n\n            const rowAbove = this.getRowAbove({ rowIndex: gridCell.rowIndex, rowPinned: gridCell.rowPinned });\n            if (_.missing(rowAbove)) {\n                return null;\n            }\n            newRowIndex = rowAbove ? rowAbove.rowIndex : null;\n            newFloating = rowAbove ? rowAbove.rowPinned : null;\n        }\n\n        return {rowIndex: newRowIndex, column: newColumn, rowPinned: newFloating} as CellPosition;\n    }\n\n}"]}