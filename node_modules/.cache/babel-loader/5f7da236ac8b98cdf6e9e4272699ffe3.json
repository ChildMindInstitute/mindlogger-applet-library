{"remainingRequest":"/Volumes/Disk1/work/work/mindlogger/mindlogger-applet-library/node_modules/@vue/cli-plugin-babel/node_modules/babel-loader/lib/index.js!/Volumes/Disk1/work/work/mindlogger/mindlogger-applet-library/node_modules/vuetify/lib/components/VCalendar/modes/stack.js","dependencies":[{"path":"/Volumes/Disk1/work/work/mindlogger/mindlogger-applet-library/node_modules/vuetify/lib/components/VCalendar/modes/stack.js","mtime":499162500000},{"path":"/Volumes/Disk1/work/work/mindlogger/mindlogger-applet-library/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Volumes/Disk1/work/work/mindlogger/mindlogger-applet-library/node_modules/@vue/cli-plugin-babel/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import _slicedToArray from \"/Volumes/Disk1/work/work/mindlogger/mindlogger-applet-library/node_modules/@babel/runtime-corejs2/helpers/esm/slicedToArray\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.array.sort\";\nimport { getOverlapGroupHandler, getVisuals, hasOverlap, getNormalizedRange } from \"./common\";\nimport { getTimestampIdentifier } from \"../util/timestamp\";\nvar FULL_WIDTH = 100;\nvar DEFAULT_OFFSET = 5;\nvar WIDTH_MULTIPLIER = 1.7;\n/**\n * Variation of column mode where events can be stacked. The priority of this\n * mode is to stack events together taking up the least amount of space while\n * trying to ensure the content of the event is always visible as well as its\n * start and end. A sibling column has intersecting event content and must be\n * placed beside each other. Non-sibling columns are offset by 5% from the\n * previous column. The width is scaled by 1.7 so the events overlap and\n * whitespace is reduced. If there is a hole in columns the event width is\n * scaled up so it intersects with the next column. The columns have equal\n * width in the space they are given. If the event doesn't have any to the\n * right of it that intersect with it's content it's right side is extended\n * to the right side.\n */\n\nexport var stack = function stack(events, firstWeekday, overlapThreshold) {\n  var handler = getOverlapGroupHandler(firstWeekday); // eslint-disable-next-line max-statements\n\n  return function (day, dayEvents, timed) {\n    if (!timed) {\n      return handler.getVisuals(day, dayEvents, timed);\n    }\n\n    var dayStart = getTimestampIdentifier(day);\n    var visuals = getVisuals(dayEvents, dayStart);\n    var groups = getGroups(visuals, dayStart);\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = groups[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var group = _step.value;\n        var nodes = [];\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = group.visuals[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var visual = _step2.value;\n            var child = getNode(visual, dayStart);\n            var index = getNextIndex(child, nodes);\n\n            if (index === false) {\n              var parent = getParent(child, nodes);\n\n              if (parent) {\n                child.parent = parent;\n                child.sibling = hasOverlap(child.start, child.end, parent.start, addTime(parent.start, overlapThreshold));\n                child.index = parent.index + 1;\n                parent.children.push(child);\n              }\n            } else {\n              var _getOverlappingRange = getOverlappingRange(child, nodes, index - 1, index - 1),\n                  _getOverlappingRange2 = _slicedToArray(_getOverlappingRange, 1),\n                  _parent = _getOverlappingRange2[0];\n\n              var children = getOverlappingRange(child, nodes, index + 1, index + nodes.length, true);\n              child.children = children;\n              child.index = index;\n\n              if (_parent) {\n                child.parent = _parent;\n                child.sibling = hasOverlap(child.start, child.end, _parent.start, addTime(_parent.start, overlapThreshold));\n\n                _parent.children.push(child);\n              }\n\n              var _iteratorNormalCompletion3 = true;\n              var _didIteratorError3 = false;\n              var _iteratorError3 = undefined;\n\n              try {\n                for (var _iterator3 = children[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                  var grand = _step3.value;\n\n                  if (grand.parent === _parent) {\n                    grand.parent = child;\n                  }\n\n                  var grandNext = grand.index - child.index <= 1;\n\n                  if (grandNext && child.sibling && hasOverlap(child.start, addTime(child.start, overlapThreshold), grand.start, grand.end)) {\n                    grand.sibling = true;\n                  }\n                }\n              } catch (err) {\n                _didIteratorError3 = true;\n                _iteratorError3 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n                    _iterator3.return();\n                  }\n                } finally {\n                  if (_didIteratorError3) {\n                    throw _iteratorError3;\n                  }\n                }\n              }\n            }\n\n            nodes.push(child);\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n\n        calculateBounds(nodes, overlapThreshold);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    visuals.sort(function (a, b) {\n      return a.left - b.left || a.event.startTimestampIdentifier - b.event.startTimestampIdentifier;\n    });\n    return visuals;\n  };\n};\n\nfunction calculateBounds(nodes, overlapThreshold) {\n  var _iteratorNormalCompletion4 = true;\n  var _didIteratorError4 = false;\n  var _iteratorError4 = undefined;\n\n  try {\n    for (var _iterator4 = nodes[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n      var node = _step4.value;\n      var visual = node.visual,\n          parent = node.parent;\n      var columns = getMaxChildIndex(node) + 1;\n      var spaceLeft = parent ? parent.visual.left : 0;\n      var spaceWidth = FULL_WIDTH - spaceLeft;\n      var offset = Math.min(DEFAULT_OFFSET, FULL_WIDTH / columns);\n      var columnWidthMultiplier = getColumnWidthMultiplier(node, nodes);\n      var columnOffset = spaceWidth / (columns - node.index + 1);\n      var columnWidth = spaceWidth / (columns - node.index + (node.sibling ? 1 : 0)) * columnWidthMultiplier;\n\n      if (parent) {\n        visual.left = node.sibling ? spaceLeft + columnOffset : spaceLeft + offset;\n      }\n\n      visual.width = hasFullWidth(node, nodes, overlapThreshold) ? FULL_WIDTH - visual.left : Math.min(FULL_WIDTH - visual.left, columnWidth * WIDTH_MULTIPLIER);\n    }\n  } catch (err) {\n    _didIteratorError4 = true;\n    _iteratorError4 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n        _iterator4.return();\n      }\n    } finally {\n      if (_didIteratorError4) {\n        throw _iteratorError4;\n      }\n    }\n  }\n}\n\nfunction getColumnWidthMultiplier(node, nodes) {\n  if (!node.children.length) {\n    return 1;\n  }\n\n  var maxColumn = node.index + nodes.length;\n  var minColumn = node.children.reduce(function (min, c) {\n    return Math.min(min, c.index);\n  }, maxColumn);\n  return minColumn - node.index;\n}\n\nfunction getOverlappingIndices(node, nodes) {\n  var indices = [];\n  var _iteratorNormalCompletion5 = true;\n  var _didIteratorError5 = false;\n  var _iteratorError5 = undefined;\n\n  try {\n    for (var _iterator5 = nodes[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n      var other = _step5.value;\n\n      if (hasOverlap(node.start, node.end, other.start, other.end)) {\n        indices.push(other.index);\n      }\n    }\n  } catch (err) {\n    _didIteratorError5 = true;\n    _iteratorError5 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n        _iterator5.return();\n      }\n    } finally {\n      if (_didIteratorError5) {\n        throw _iteratorError5;\n      }\n    }\n  }\n\n  return indices;\n}\n\nfunction getNextIndex(node, nodes) {\n  var indices = getOverlappingIndices(node, nodes);\n  indices.sort();\n\n  for (var i = 0; i < indices.length; i++) {\n    if (i < indices[i]) {\n      return i;\n    }\n  }\n\n  return false;\n}\n\nfunction getOverlappingRange(node, nodes, indexMin, indexMax) {\n  var returnFirstColumn = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var overlapping = [];\n  var _iteratorNormalCompletion6 = true;\n  var _didIteratorError6 = false;\n  var _iteratorError6 = undefined;\n\n  try {\n    for (var _iterator6 = nodes[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n      var other = _step6.value;\n\n      if (other.index >= indexMin && other.index <= indexMax && hasOverlap(node.start, node.end, other.start, other.end)) {\n        overlapping.push(other);\n      }\n    }\n  } catch (err) {\n    _didIteratorError6 = true;\n    _iteratorError6 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n        _iterator6.return();\n      }\n    } finally {\n      if (_didIteratorError6) {\n        throw _iteratorError6;\n      }\n    }\n  }\n\n  if (returnFirstColumn && overlapping.length > 0) {\n    var first = overlapping.reduce(function (min, n) {\n      return Math.min(min, n.index);\n    }, overlapping[0].index);\n    return overlapping.filter(function (n) {\n      return n.index === first;\n    });\n  }\n\n  return overlapping;\n}\n\nfunction getParent(node, nodes) {\n  var parent = null;\n  var _iteratorNormalCompletion7 = true;\n  var _didIteratorError7 = false;\n  var _iteratorError7 = undefined;\n\n  try {\n    for (var _iterator7 = nodes[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n      var other = _step7.value;\n\n      if (hasOverlap(node.start, node.end, other.start, other.end) && (parent === null || other.index > parent.index)) {\n        parent = other;\n      }\n    }\n  } catch (err) {\n    _didIteratorError7 = true;\n    _iteratorError7 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n        _iterator7.return();\n      }\n    } finally {\n      if (_didIteratorError7) {\n        throw _iteratorError7;\n      }\n    }\n  }\n\n  return parent;\n}\n\nfunction hasFullWidth(node, nodes, overlapThreshold) {\n  var _iteratorNormalCompletion8 = true;\n  var _didIteratorError8 = false;\n  var _iteratorError8 = undefined;\n\n  try {\n    for (var _iterator8 = nodes[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n      var other = _step8.value;\n\n      if (other !== node && other.index > node.index && hasOverlap(node.start, addTime(node.start, overlapThreshold), other.start, other.end)) {\n        return false;\n      }\n    }\n  } catch (err) {\n    _didIteratorError8 = true;\n    _iteratorError8 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n        _iterator8.return();\n      }\n    } finally {\n      if (_didIteratorError8) {\n        throw _iteratorError8;\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction getGroups(visuals, dayStart) {\n  var groups = [];\n  var _iteratorNormalCompletion9 = true;\n  var _didIteratorError9 = false;\n  var _iteratorError9 = undefined;\n\n  try {\n    for (var _iterator9 = visuals[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n      var visual = _step9.value;\n\n      var _getNormalizedRange = getNormalizedRange(visual.event, dayStart),\n          _getNormalizedRange2 = _slicedToArray(_getNormalizedRange, 2),\n          start = _getNormalizedRange2[0],\n          end = _getNormalizedRange2[1];\n\n      var added = false;\n      var _iteratorNormalCompletion10 = true;\n      var _didIteratorError10 = false;\n      var _iteratorError10 = undefined;\n\n      try {\n        for (var _iterator10 = groups[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n          var group = _step10.value;\n\n          if (hasOverlap(start, end, group.start, group.end)) {\n            group.visuals.push(visual);\n            group.end = Math.max(group.end, end);\n            added = true;\n            break;\n          }\n        }\n      } catch (err) {\n        _didIteratorError10 = true;\n        _iteratorError10 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion10 && _iterator10.return != null) {\n            _iterator10.return();\n          }\n        } finally {\n          if (_didIteratorError10) {\n            throw _iteratorError10;\n          }\n        }\n      }\n\n      if (!added) {\n        groups.push({\n          start: start,\n          end: end,\n          visuals: [visual]\n        });\n      }\n    }\n  } catch (err) {\n    _didIteratorError9 = true;\n    _iteratorError9 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n        _iterator9.return();\n      }\n    } finally {\n      if (_didIteratorError9) {\n        throw _iteratorError9;\n      }\n    }\n  }\n\n  return groups;\n}\n\nfunction getNode(visual, dayStart) {\n  var _getNormalizedRange3 = getNormalizedRange(visual.event, dayStart),\n      _getNormalizedRange4 = _slicedToArray(_getNormalizedRange3, 2),\n      start = _getNormalizedRange4[0],\n      end = _getNormalizedRange4[1];\n\n  return {\n    parent: null,\n    sibling: true,\n    index: 0,\n    visual: visual,\n    start: start,\n    end: end,\n    children: []\n  };\n}\n\nfunction getMaxChildIndex(node) {\n  var max = node.index;\n  var _iteratorNormalCompletion11 = true;\n  var _didIteratorError11 = false;\n  var _iteratorError11 = undefined;\n\n  try {\n    for (var _iterator11 = node.children[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n      var child = _step11.value;\n      var childMax = getMaxChildIndex(child);\n\n      if (childMax > max) {\n        max = childMax;\n      }\n    }\n  } catch (err) {\n    _didIteratorError11 = true;\n    _iteratorError11 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion11 && _iterator11.return != null) {\n        _iterator11.return();\n      }\n    } finally {\n      if (_didIteratorError11) {\n        throw _iteratorError11;\n      }\n    }\n  }\n\n  return max;\n}\n\nfunction addTime(identifier, minutes) {\n  var removeMinutes = identifier % 100;\n  var totalMinutes = removeMinutes + minutes;\n  var addHours = Math.floor(totalMinutes / 60);\n  var addMinutes = totalMinutes % 60;\n  return identifier - removeMinutes + addHours * 100 + addMinutes;\n}",{"version":3,"sources":["/Volumes/Disk1/work/work/mindlogger/mindlogger-applet-library/node_modules/vuetify/lib/components/VCalendar/modes/stack.js"],"names":["getOverlapGroupHandler","getVisuals","hasOverlap","getNormalizedRange","getTimestampIdentifier","FULL_WIDTH","DEFAULT_OFFSET","WIDTH_MULTIPLIER","stack","events","firstWeekday","overlapThreshold","handler","day","dayEvents","timed","dayStart","visuals","groups","getGroups","group","nodes","visual","child","getNode","index","getNextIndex","parent","getParent","sibling","start","end","addTime","children","push","getOverlappingRange","length","grand","grandNext","calculateBounds","sort","a","b","left","event","startTimestampIdentifier","node","columns","getMaxChildIndex","spaceLeft","spaceWidth","offset","Math","min","columnWidthMultiplier","getColumnWidthMultiplier","columnOffset","columnWidth","width","hasFullWidth","maxColumn","minColumn","reduce","c","getOverlappingIndices","indices","other","i","indexMin","indexMax","returnFirstColumn","overlapping","first","n","filter","added","max","childMax","identifier","minutes","removeMinutes","totalMinutes","addHours","floor","addMinutes"],"mappings":"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","sourcesContent":["import { getOverlapGroupHandler, getVisuals, hasOverlap, getNormalizedRange } from './common';\nimport { getTimestampIdentifier } from '../util/timestamp';\nconst FULL_WIDTH = 100;\nconst DEFAULT_OFFSET = 5;\nconst WIDTH_MULTIPLIER = 1.7;\n/**\n * Variation of column mode where events can be stacked. The priority of this\n * mode is to stack events together taking up the least amount of space while\n * trying to ensure the content of the event is always visible as well as its\n * start and end. A sibling column has intersecting event content and must be\n * placed beside each other. Non-sibling columns are offset by 5% from the\n * previous column. The width is scaled by 1.7 so the events overlap and\n * whitespace is reduced. If there is a hole in columns the event width is\n * scaled up so it intersects with the next column. The columns have equal\n * width in the space they are given. If the event doesn't have any to the\n * right of it that intersect with it's content it's right side is extended\n * to the right side.\n */\n\nexport const stack = (events, firstWeekday, overlapThreshold) => {\n  const handler = getOverlapGroupHandler(firstWeekday); // eslint-disable-next-line max-statements\n\n  return (day, dayEvents, timed) => {\n    if (!timed) {\n      return handler.getVisuals(day, dayEvents, timed);\n    }\n\n    const dayStart = getTimestampIdentifier(day);\n    const visuals = getVisuals(dayEvents, dayStart);\n    const groups = getGroups(visuals, dayStart);\n\n    for (const group of groups) {\n      const nodes = [];\n\n      for (const visual of group.visuals) {\n        const child = getNode(visual, dayStart);\n        const index = getNextIndex(child, nodes);\n\n        if (index === false) {\n          const parent = getParent(child, nodes);\n\n          if (parent) {\n            child.parent = parent;\n            child.sibling = hasOverlap(child.start, child.end, parent.start, addTime(parent.start, overlapThreshold));\n            child.index = parent.index + 1;\n            parent.children.push(child);\n          }\n        } else {\n          const [parent] = getOverlappingRange(child, nodes, index - 1, index - 1);\n          const children = getOverlappingRange(child, nodes, index + 1, index + nodes.length, true);\n          child.children = children;\n          child.index = index;\n\n          if (parent) {\n            child.parent = parent;\n            child.sibling = hasOverlap(child.start, child.end, parent.start, addTime(parent.start, overlapThreshold));\n            parent.children.push(child);\n          }\n\n          for (const grand of children) {\n            if (grand.parent === parent) {\n              grand.parent = child;\n            }\n\n            const grandNext = grand.index - child.index <= 1;\n\n            if (grandNext && child.sibling && hasOverlap(child.start, addTime(child.start, overlapThreshold), grand.start, grand.end)) {\n              grand.sibling = true;\n            }\n          }\n        }\n\n        nodes.push(child);\n      }\n\n      calculateBounds(nodes, overlapThreshold);\n    }\n\n    visuals.sort((a, b) => a.left - b.left || a.event.startTimestampIdentifier - b.event.startTimestampIdentifier);\n    return visuals;\n  };\n};\n\nfunction calculateBounds(nodes, overlapThreshold) {\n  for (const node of nodes) {\n    const {\n      visual,\n      parent\n    } = node;\n    const columns = getMaxChildIndex(node) + 1;\n    const spaceLeft = parent ? parent.visual.left : 0;\n    const spaceWidth = FULL_WIDTH - spaceLeft;\n    const offset = Math.min(DEFAULT_OFFSET, FULL_WIDTH / columns);\n    const columnWidthMultiplier = getColumnWidthMultiplier(node, nodes);\n    const columnOffset = spaceWidth / (columns - node.index + 1);\n    const columnWidth = spaceWidth / (columns - node.index + (node.sibling ? 1 : 0)) * columnWidthMultiplier;\n\n    if (parent) {\n      visual.left = node.sibling ? spaceLeft + columnOffset : spaceLeft + offset;\n    }\n\n    visual.width = hasFullWidth(node, nodes, overlapThreshold) ? FULL_WIDTH - visual.left : Math.min(FULL_WIDTH - visual.left, columnWidth * WIDTH_MULTIPLIER);\n  }\n}\n\nfunction getColumnWidthMultiplier(node, nodes) {\n  if (!node.children.length) {\n    return 1;\n  }\n\n  const maxColumn = node.index + nodes.length;\n  const minColumn = node.children.reduce((min, c) => Math.min(min, c.index), maxColumn);\n  return minColumn - node.index;\n}\n\nfunction getOverlappingIndices(node, nodes) {\n  const indices = [];\n\n  for (const other of nodes) {\n    if (hasOverlap(node.start, node.end, other.start, other.end)) {\n      indices.push(other.index);\n    }\n  }\n\n  return indices;\n}\n\nfunction getNextIndex(node, nodes) {\n  const indices = getOverlappingIndices(node, nodes);\n  indices.sort();\n\n  for (let i = 0; i < indices.length; i++) {\n    if (i < indices[i]) {\n      return i;\n    }\n  }\n\n  return false;\n}\n\nfunction getOverlappingRange(node, nodes, indexMin, indexMax, returnFirstColumn = false) {\n  const overlapping = [];\n\n  for (const other of nodes) {\n    if (other.index >= indexMin && other.index <= indexMax && hasOverlap(node.start, node.end, other.start, other.end)) {\n      overlapping.push(other);\n    }\n  }\n\n  if (returnFirstColumn && overlapping.length > 0) {\n    const first = overlapping.reduce((min, n) => Math.min(min, n.index), overlapping[0].index);\n    return overlapping.filter(n => n.index === first);\n  }\n\n  return overlapping;\n}\n\nfunction getParent(node, nodes) {\n  let parent = null;\n\n  for (const other of nodes) {\n    if (hasOverlap(node.start, node.end, other.start, other.end) && (parent === null || other.index > parent.index)) {\n      parent = other;\n    }\n  }\n\n  return parent;\n}\n\nfunction hasFullWidth(node, nodes, overlapThreshold) {\n  for (const other of nodes) {\n    if (other !== node && other.index > node.index && hasOverlap(node.start, addTime(node.start, overlapThreshold), other.start, other.end)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction getGroups(visuals, dayStart) {\n  const groups = [];\n\n  for (const visual of visuals) {\n    const [start, end] = getNormalizedRange(visual.event, dayStart);\n    let added = false;\n\n    for (const group of groups) {\n      if (hasOverlap(start, end, group.start, group.end)) {\n        group.visuals.push(visual);\n        group.end = Math.max(group.end, end);\n        added = true;\n        break;\n      }\n    }\n\n    if (!added) {\n      groups.push({\n        start,\n        end,\n        visuals: [visual]\n      });\n    }\n  }\n\n  return groups;\n}\n\nfunction getNode(visual, dayStart) {\n  const [start, end] = getNormalizedRange(visual.event, dayStart);\n  return {\n    parent: null,\n    sibling: true,\n    index: 0,\n    visual,\n    start,\n    end,\n    children: []\n  };\n}\n\nfunction getMaxChildIndex(node) {\n  let max = node.index;\n\n  for (const child of node.children) {\n    const childMax = getMaxChildIndex(child);\n\n    if (childMax > max) {\n      max = childMax;\n    }\n  }\n\n  return max;\n}\n\nfunction addTime(identifier, minutes) {\n  const removeMinutes = identifier % 100;\n  const totalMinutes = removeMinutes + minutes;\n  const addHours = Math.floor(totalMinutes / 60);\n  const addMinutes = totalMinutes % 60;\n  return identifier - removeMinutes + addHours * 100 + addMinutes;\n}\n//# sourceMappingURL=stack.js.map"]}]}