{"remainingRequest":"/Volumes/Disk1/work/work/mindlogger/mindlogger-applet-library/node_modules/@vue/cli-plugin-babel/node_modules/babel-loader/lib/index.js!/Volumes/Disk1/work/work/mindlogger/mindlogger-applet-library/node_modules/vuetify/lib/components/VSparkline/VSparkline.js","dependencies":[{"path":"/Volumes/Disk1/work/work/mindlogger/mindlogger-applet-library/node_modules/vuetify/lib/components/VSparkline/VSparkline.js","mtime":499162500000},{"path":"/Volumes/Disk1/work/work/mindlogger/mindlogger-applet-library/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Volumes/Disk1/work/work/mindlogger/mindlogger-applet-library/node_modules/@vue/cli-plugin-babel/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es7.object.get-own-property-descriptors\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.object.keys\";\nimport _defineProperty from \"/Volumes/Disk1/work/work/mindlogger/mindlogger-applet-library/node_modules/@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport \"core-js/modules/es6.regexp.to-string\";\nimport \"core-js/modules/es6.array.fill\";\nimport _typeof from \"/Volumes/Disk1/work/work/mindlogger/mindlogger-applet-library/node_modules/@babel/runtime-corejs2/helpers/esm/typeof\";\nimport \"core-js/modules/es7.array.includes\";\nimport \"core-js/modules/es6.string.includes\";\nimport \"core-js/modules/es6.number.constructor\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// Mixins\nimport Colorable from \"../../mixins/colorable\"; // Utilities\n\nimport mixins from \"../../util/mixins\";\nimport { genPoints, genBars as _genBars } from \"./helpers/core\";\nimport { genPath as _genPath } from \"./helpers/path\";\nexport default mixins(Colorable).extend({\n  name: 'VSparkline',\n  inheritAttrs: false,\n  props: {\n    autoDraw: Boolean,\n    autoDrawDuration: {\n      type: Number,\n      default: 2000\n    },\n    autoDrawEasing: {\n      type: String,\n      default: 'ease'\n    },\n    autoLineWidth: {\n      type: Boolean,\n      default: false\n    },\n    color: {\n      type: String,\n      default: 'primary'\n    },\n    fill: {\n      type: Boolean,\n      default: false\n    },\n    gradient: {\n      type: Array,\n      default: function _default() {\n        return [];\n      }\n    },\n    gradientDirection: {\n      type: String,\n      validator: function validator(val) {\n        return ['top', 'bottom', 'left', 'right'].includes(val);\n      },\n      default: 'top'\n    },\n    height: {\n      type: [String, Number],\n      default: 75\n    },\n    labels: {\n      type: Array,\n      default: function _default() {\n        return [];\n      }\n    },\n    labelSize: {\n      type: [Number, String],\n      default: 7\n    },\n    lineWidth: {\n      type: [String, Number],\n      default: 4\n    },\n    padding: {\n      type: [String, Number],\n      default: 8\n    },\n    showLabels: Boolean,\n    smooth: {\n      type: [Boolean, Number, String],\n      default: false\n    },\n    type: {\n      type: String,\n      default: 'trend',\n      validator: function validator(val) {\n        return ['trend', 'bar'].includes(val);\n      }\n    },\n    value: {\n      type: Array,\n      default: function _default() {\n        return [];\n      }\n    },\n    width: {\n      type: [Number, String],\n      default: 300\n    }\n  },\n  data: function data() {\n    return {\n      lastLength: 0\n    };\n  },\n  computed: {\n    parsedPadding: function parsedPadding() {\n      return Number(this.padding);\n    },\n    parsedWidth: function parsedWidth() {\n      return Number(this.width);\n    },\n    parsedHeight: function parsedHeight() {\n      return parseInt(this.height, 10);\n    },\n    parsedLabelSize: function parsedLabelSize() {\n      return parseInt(this.labelSize, 10) || 7;\n    },\n    totalHeight: function totalHeight() {\n      var height = this.parsedHeight;\n      if (this.hasLabels) height += parseInt(this.labelSize, 10) * 1.5;\n      return height;\n    },\n    totalWidth: function totalWidth() {\n      var width = this.parsedWidth;\n      if (this.type === 'bar') width = Math.max(this.value.length * this._lineWidth, width);\n      return width;\n    },\n    totalValues: function totalValues() {\n      return this.value.length;\n    },\n    _lineWidth: function _lineWidth() {\n      if (this.autoLineWidth && this.type !== 'trend') {\n        var totalPadding = this.parsedPadding * (this.totalValues + 1);\n        return (this.parsedWidth - totalPadding) / this.totalValues;\n      } else {\n        return parseFloat(this.lineWidth) || 4;\n      }\n    },\n    boundary: function boundary() {\n      if (this.type === 'bar') return {\n        minX: 0,\n        maxX: this.totalWidth,\n        minY: 0,\n        maxY: this.parsedHeight\n      };\n      var padding = this.parsedPadding;\n      return {\n        minX: padding,\n        maxX: this.totalWidth - padding,\n        minY: padding,\n        maxY: this.parsedHeight - padding\n      };\n    },\n    hasLabels: function hasLabels() {\n      return Boolean(this.showLabels || this.labels.length > 0 || this.$scopedSlots.label);\n    },\n    parsedLabels: function parsedLabels() {\n      var labels = [];\n      var points = this._values;\n      var len = points.length;\n\n      for (var i = 0; labels.length < len; i++) {\n        var item = points[i];\n        var value = this.labels[i];\n\n        if (!value) {\n          value = _typeof(item) === 'object' ? item.value : item;\n        }\n\n        labels.push({\n          x: item.x,\n          value: String(value)\n        });\n      }\n\n      return labels;\n    },\n    normalizedValues: function normalizedValues() {\n      return this.value.map(function (item) {\n        return typeof item === 'number' ? item : item.value;\n      });\n    },\n    _values: function _values() {\n      return this.type === 'trend' ? genPoints(this.normalizedValues, this.boundary) : _genBars(this.normalizedValues, this.boundary);\n    },\n    textY: function textY() {\n      var y = this.parsedHeight;\n      if (this.type === 'trend') y -= 4;\n      return y;\n    },\n    _radius: function _radius() {\n      return this.smooth === true ? 8 : Number(this.smooth);\n    }\n  },\n  watch: {\n    value: {\n      immediate: true,\n      handler: function handler() {\n        var _this = this;\n\n        this.$nextTick(function () {\n          if (!_this.autoDraw || _this.type === 'bar' || !_this.$refs.path) return;\n          var path = _this.$refs.path;\n          var length = path.getTotalLength();\n\n          if (!_this.fill) {\n            path.style.transition = 'none';\n            path.style.strokeDasharray = length + ' ' + length;\n            path.style.strokeDashoffset = Math.abs(length - (_this.lastLength || 0)).toString();\n            path.getBoundingClientRect();\n            path.style.transition = \"stroke-dashoffset \".concat(_this.autoDrawDuration, \"ms \").concat(_this.autoDrawEasing);\n            path.style.strokeDashoffset = '0';\n          } else {\n            path.style.transformOrigin = 'bottom center';\n            path.style.transition = 'none';\n            path.style.transform = \"scaleY(0)\";\n            path.getBoundingClientRect();\n            path.style.transition = \"transform \".concat(_this.autoDrawDuration, \"ms \").concat(_this.autoDrawEasing);\n            path.style.transform = \"scaleY(1)\";\n          }\n\n          _this.lastLength = length;\n        });\n      }\n    }\n  },\n  methods: {\n    genGradient: function genGradient() {\n      var _this2 = this;\n\n      var gradientDirection = this.gradientDirection;\n      var gradient = this.gradient.slice(); // Pushes empty string to force\n      // a fallback to currentColor\n\n      if (!gradient.length) gradient.push('');\n      var len = Math.max(gradient.length - 1, 1);\n      var stops = gradient.reverse().map(function (color, index) {\n        return _this2.$createElement('stop', {\n          attrs: {\n            offset: index / len,\n            'stop-color': color || 'currentColor'\n          }\n        });\n      });\n      return this.$createElement('defs', [this.$createElement('linearGradient', {\n        attrs: {\n          id: this._uid,\n          x1: +(gradientDirection === 'left'),\n          y1: +(gradientDirection === 'top'),\n          x2: +(gradientDirection === 'right'),\n          y2: +(gradientDirection === 'bottom')\n        }\n      }, stops)]);\n    },\n    genG: function genG(children) {\n      return this.$createElement('g', {\n        style: {\n          fontSize: '8',\n          textAnchor: 'middle',\n          dominantBaseline: 'mathematical',\n          fill: 'currentColor'\n        }\n      }, children);\n    },\n    genPath: function genPath() {\n      var points = genPoints(this.normalizedValues, this.boundary);\n      return this.$createElement('path', {\n        attrs: {\n          d: _genPath(points, this._radius, this.fill, this.parsedHeight),\n          fill: this.fill ? \"url(#\".concat(this._uid, \")\") : 'none',\n          stroke: this.fill ? 'none' : \"url(#\".concat(this._uid, \")\")\n        },\n        ref: 'path'\n      });\n    },\n    genLabels: function genLabels(offsetX) {\n      var _this3 = this;\n\n      var children = this.parsedLabels.map(function (item, i) {\n        return _this3.$createElement('text', {\n          attrs: {\n            x: item.x + offsetX + _this3._lineWidth / 2,\n            y: _this3.textY + _this3.parsedLabelSize * 0.75,\n            'font-size': Number(_this3.labelSize) || 7\n          }\n        }, [_this3.genLabel(item, i)]);\n      });\n      return this.genG(children);\n    },\n    genLabel: function genLabel(item, index) {\n      return this.$scopedSlots.label ? this.$scopedSlots.label({\n        index: index,\n        value: item.value\n      }) : item.value;\n    },\n    genBars: function genBars() {\n      if (!this.value || this.totalValues < 2) return undefined;\n\n      var bars = _genBars(this.normalizedValues, this.boundary);\n\n      var offsetX = (Math.abs(bars[0].x - bars[1].x) - this._lineWidth) / 2;\n      return this.$createElement('svg', {\n        attrs: {\n          display: 'block',\n          viewBox: \"0 0 \".concat(this.totalWidth, \" \").concat(this.totalHeight)\n        }\n      }, [this.genGradient(), this.genClipPath(bars, offsetX, this._lineWidth, 'sparkline-bar-' + this._uid), this.hasLabels ? this.genLabels(offsetX) : undefined, this.$createElement('g', {\n        attrs: {\n          'clip-path': \"url(#sparkline-bar-\".concat(this._uid, \"-clip)\"),\n          fill: \"url(#\".concat(this._uid, \")\")\n        }\n      }, [this.$createElement('rect', {\n        attrs: {\n          x: 0,\n          y: 0,\n          width: this.totalWidth,\n          height: this.height\n        }\n      })])]);\n    },\n    genClipPath: function genClipPath(bars, offsetX, lineWidth, id) {\n      var _this4 = this;\n\n      var rounding = typeof this.smooth === 'number' ? this.smooth : this.smooth ? 2 : 0;\n      return this.$createElement('clipPath', {\n        attrs: {\n          id: \"\".concat(id, \"-clip\")\n        }\n      }, bars.map(function (item) {\n        return _this4.$createElement('rect', {\n          attrs: {\n            x: item.x + offsetX,\n            y: item.y,\n            width: lineWidth,\n            height: item.height,\n            rx: rounding,\n            ry: rounding\n          }\n        }, [_this4.autoDraw ? _this4.$createElement('animate', {\n          attrs: {\n            attributeName: 'height',\n            from: 0,\n            to: item.height,\n            dur: \"\".concat(_this4.autoDrawDuration, \"ms\"),\n            fill: 'freeze'\n          }\n        }) : undefined]);\n      }));\n    },\n    genTrend: function genTrend() {\n      return this.$createElement('svg', this.setTextColor(this.color, {\n        attrs: _objectSpread({}, this.$attrs, {\n          display: 'block',\n          'stroke-width': this._lineWidth || 1,\n          viewBox: \"0 0 \".concat(this.width, \" \").concat(this.totalHeight)\n        })\n      }), [this.genGradient(), this.hasLabels && this.genLabels(-(this._lineWidth / 2)), this.genPath()]);\n    }\n  },\n  render: function render(h) {\n    if (this.totalValues < 2) return undefined;\n    return this.type === 'trend' ? this.genTrend() : this.genBars();\n  }\n});",{"version":3,"sources":["/Volumes/Disk1/work/work/mindlogger/mindlogger-applet-library/node_modules/vuetify/lib/components/VSparkline/VSparkline.js"],"names":["Colorable","mixins","genPoints","genBars","genPath","extend","name","inheritAttrs","props","autoDraw","Boolean","autoDrawDuration","type","Number","default","autoDrawEasing","String","autoLineWidth","color","fill","gradient","Array","gradientDirection","validator","val","includes","height","labels","labelSize","lineWidth","padding","showLabels","smooth","value","width","data","lastLength","computed","parsedPadding","parsedWidth","parsedHeight","parseInt","parsedLabelSize","totalHeight","hasLabels","totalWidth","Math","max","length","_lineWidth","totalValues","totalPadding","parseFloat","boundary","minX","maxX","minY","maxY","$scopedSlots","label","parsedLabels","points","_values","len","i","item","push","x","normalizedValues","map","textY","y","_radius","watch","immediate","handler","$nextTick","$refs","path","getTotalLength","style","transition","strokeDasharray","strokeDashoffset","abs","toString","getBoundingClientRect","transformOrigin","transform","methods","genGradient","slice","stops","reverse","index","$createElement","attrs","offset","id","_uid","x1","y1","x2","y2","genG","children","fontSize","textAnchor","dominantBaseline","d","stroke","ref","genLabels","offsetX","genLabel","undefined","bars","display","viewBox","genClipPath","rounding","rx","ry","attributeName","from","to","dur","genTrend","setTextColor","$attrs","render","h"],"mappings":"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","sourcesContent":["// Mixins\nimport Colorable from '../../mixins/colorable'; // Utilities\n\nimport mixins from '../../util/mixins';\nimport { genPoints, genBars } from './helpers/core';\nimport { genPath } from './helpers/path';\nexport default mixins(Colorable).extend({\n  name: 'VSparkline',\n  inheritAttrs: false,\n  props: {\n    autoDraw: Boolean,\n    autoDrawDuration: {\n      type: Number,\n      default: 2000\n    },\n    autoDrawEasing: {\n      type: String,\n      default: 'ease'\n    },\n    autoLineWidth: {\n      type: Boolean,\n      default: false\n    },\n    color: {\n      type: String,\n      default: 'primary'\n    },\n    fill: {\n      type: Boolean,\n      default: false\n    },\n    gradient: {\n      type: Array,\n      default: () => []\n    },\n    gradientDirection: {\n      type: String,\n      validator: val => ['top', 'bottom', 'left', 'right'].includes(val),\n      default: 'top'\n    },\n    height: {\n      type: [String, Number],\n      default: 75\n    },\n    labels: {\n      type: Array,\n      default: () => []\n    },\n    labelSize: {\n      type: [Number, String],\n      default: 7\n    },\n    lineWidth: {\n      type: [String, Number],\n      default: 4\n    },\n    padding: {\n      type: [String, Number],\n      default: 8\n    },\n    showLabels: Boolean,\n    smooth: {\n      type: [Boolean, Number, String],\n      default: false\n    },\n    type: {\n      type: String,\n      default: 'trend',\n      validator: val => ['trend', 'bar'].includes(val)\n    },\n    value: {\n      type: Array,\n      default: () => []\n    },\n    width: {\n      type: [Number, String],\n      default: 300\n    }\n  },\n  data: () => ({\n    lastLength: 0\n  }),\n  computed: {\n    parsedPadding() {\n      return Number(this.padding);\n    },\n\n    parsedWidth() {\n      return Number(this.width);\n    },\n\n    parsedHeight() {\n      return parseInt(this.height, 10);\n    },\n\n    parsedLabelSize() {\n      return parseInt(this.labelSize, 10) || 7;\n    },\n\n    totalHeight() {\n      let height = this.parsedHeight;\n      if (this.hasLabels) height += parseInt(this.labelSize, 10) * 1.5;\n      return height;\n    },\n\n    totalWidth() {\n      let width = this.parsedWidth;\n      if (this.type === 'bar') width = Math.max(this.value.length * this._lineWidth, width);\n      return width;\n    },\n\n    totalValues() {\n      return this.value.length;\n    },\n\n    _lineWidth() {\n      if (this.autoLineWidth && this.type !== 'trend') {\n        const totalPadding = this.parsedPadding * (this.totalValues + 1);\n        return (this.parsedWidth - totalPadding) / this.totalValues;\n      } else {\n        return parseFloat(this.lineWidth) || 4;\n      }\n    },\n\n    boundary() {\n      if (this.type === 'bar') return {\n        minX: 0,\n        maxX: this.totalWidth,\n        minY: 0,\n        maxY: this.parsedHeight\n      };\n      const padding = this.parsedPadding;\n      return {\n        minX: padding,\n        maxX: this.totalWidth - padding,\n        minY: padding,\n        maxY: this.parsedHeight - padding\n      };\n    },\n\n    hasLabels() {\n      return Boolean(this.showLabels || this.labels.length > 0 || this.$scopedSlots.label);\n    },\n\n    parsedLabels() {\n      const labels = [];\n      const points = this._values;\n      const len = points.length;\n\n      for (let i = 0; labels.length < len; i++) {\n        const item = points[i];\n        let value = this.labels[i];\n\n        if (!value) {\n          value = typeof item === 'object' ? item.value : item;\n        }\n\n        labels.push({\n          x: item.x,\n          value: String(value)\n        });\n      }\n\n      return labels;\n    },\n\n    normalizedValues() {\n      return this.value.map(item => typeof item === 'number' ? item : item.value);\n    },\n\n    _values() {\n      return this.type === 'trend' ? genPoints(this.normalizedValues, this.boundary) : genBars(this.normalizedValues, this.boundary);\n    },\n\n    textY() {\n      let y = this.parsedHeight;\n      if (this.type === 'trend') y -= 4;\n      return y;\n    },\n\n    _radius() {\n      return this.smooth === true ? 8 : Number(this.smooth);\n    }\n\n  },\n  watch: {\n    value: {\n      immediate: true,\n\n      handler() {\n        this.$nextTick(() => {\n          if (!this.autoDraw || this.type === 'bar' || !this.$refs.path) return;\n          const path = this.$refs.path;\n          const length = path.getTotalLength();\n\n          if (!this.fill) {\n            path.style.transition = 'none';\n            path.style.strokeDasharray = length + ' ' + length;\n            path.style.strokeDashoffset = Math.abs(length - (this.lastLength || 0)).toString();\n            path.getBoundingClientRect();\n            path.style.transition = `stroke-dashoffset ${this.autoDrawDuration}ms ${this.autoDrawEasing}`;\n            path.style.strokeDashoffset = '0';\n          } else {\n            path.style.transformOrigin = 'bottom center';\n            path.style.transition = 'none';\n            path.style.transform = `scaleY(0)`;\n            path.getBoundingClientRect();\n            path.style.transition = `transform ${this.autoDrawDuration}ms ${this.autoDrawEasing}`;\n            path.style.transform = `scaleY(1)`;\n          }\n\n          this.lastLength = length;\n        });\n      }\n\n    }\n  },\n  methods: {\n    genGradient() {\n      const gradientDirection = this.gradientDirection;\n      const gradient = this.gradient.slice(); // Pushes empty string to force\n      // a fallback to currentColor\n\n      if (!gradient.length) gradient.push('');\n      const len = Math.max(gradient.length - 1, 1);\n      const stops = gradient.reverse().map((color, index) => this.$createElement('stop', {\n        attrs: {\n          offset: index / len,\n          'stop-color': color || 'currentColor'\n        }\n      }));\n      return this.$createElement('defs', [this.$createElement('linearGradient', {\n        attrs: {\n          id: this._uid,\n          x1: +(gradientDirection === 'left'),\n          y1: +(gradientDirection === 'top'),\n          x2: +(gradientDirection === 'right'),\n          y2: +(gradientDirection === 'bottom')\n        }\n      }, stops)]);\n    },\n\n    genG(children) {\n      return this.$createElement('g', {\n        style: {\n          fontSize: '8',\n          textAnchor: 'middle',\n          dominantBaseline: 'mathematical',\n          fill: 'currentColor'\n        }\n      }, children);\n    },\n\n    genPath() {\n      const points = genPoints(this.normalizedValues, this.boundary);\n      return this.$createElement('path', {\n        attrs: {\n          d: genPath(points, this._radius, this.fill, this.parsedHeight),\n          fill: this.fill ? `url(#${this._uid})` : 'none',\n          stroke: this.fill ? 'none' : `url(#${this._uid})`\n        },\n        ref: 'path'\n      });\n    },\n\n    genLabels(offsetX) {\n      const children = this.parsedLabels.map((item, i) => this.$createElement('text', {\n        attrs: {\n          x: item.x + offsetX + this._lineWidth / 2,\n          y: this.textY + this.parsedLabelSize * 0.75,\n          'font-size': Number(this.labelSize) || 7\n        }\n      }, [this.genLabel(item, i)]));\n      return this.genG(children);\n    },\n\n    genLabel(item, index) {\n      return this.$scopedSlots.label ? this.$scopedSlots.label({\n        index,\n        value: item.value\n      }) : item.value;\n    },\n\n    genBars() {\n      if (!this.value || this.totalValues < 2) return undefined;\n      const bars = genBars(this.normalizedValues, this.boundary);\n      const offsetX = (Math.abs(bars[0].x - bars[1].x) - this._lineWidth) / 2;\n      return this.$createElement('svg', {\n        attrs: {\n          display: 'block',\n          viewBox: `0 0 ${this.totalWidth} ${this.totalHeight}`\n        }\n      }, [this.genGradient(), this.genClipPath(bars, offsetX, this._lineWidth, 'sparkline-bar-' + this._uid), this.hasLabels ? this.genLabels(offsetX) : undefined, this.$createElement('g', {\n        attrs: {\n          'clip-path': `url(#sparkline-bar-${this._uid}-clip)`,\n          fill: `url(#${this._uid})`\n        }\n      }, [this.$createElement('rect', {\n        attrs: {\n          x: 0,\n          y: 0,\n          width: this.totalWidth,\n          height: this.height\n        }\n      })])]);\n    },\n\n    genClipPath(bars, offsetX, lineWidth, id) {\n      const rounding = typeof this.smooth === 'number' ? this.smooth : this.smooth ? 2 : 0;\n      return this.$createElement('clipPath', {\n        attrs: {\n          id: `${id}-clip`\n        }\n      }, bars.map(item => {\n        return this.$createElement('rect', {\n          attrs: {\n            x: item.x + offsetX,\n            y: item.y,\n            width: lineWidth,\n            height: item.height,\n            rx: rounding,\n            ry: rounding\n          }\n        }, [this.autoDraw ? this.$createElement('animate', {\n          attrs: {\n            attributeName: 'height',\n            from: 0,\n            to: item.height,\n            dur: `${this.autoDrawDuration}ms`,\n            fill: 'freeze'\n          }\n        }) : undefined]);\n      }));\n    },\n\n    genTrend() {\n      return this.$createElement('svg', this.setTextColor(this.color, {\n        attrs: { ...this.$attrs,\n          display: 'block',\n          'stroke-width': this._lineWidth || 1,\n          viewBox: `0 0 ${this.width} ${this.totalHeight}`\n        }\n      }), [this.genGradient(), this.hasLabels && this.genLabels(-(this._lineWidth / 2)), this.genPath()]);\n    }\n\n  },\n\n  render(h) {\n    if (this.totalValues < 2) return undefined;\n    return this.type === 'trend' ? this.genTrend() : this.genBars();\n  }\n\n});\n//# sourceMappingURL=VSparkline.js.map"]}]}