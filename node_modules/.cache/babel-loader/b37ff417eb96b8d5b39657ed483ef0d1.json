{"remainingRequest":"/Volumes/Disk1/work/work/mindlogger/mindlogger-applet-library/node_modules/@vue/cli-plugin-babel/node_modules/babel-loader/lib/index.js!/Volumes/Disk1/work/work/mindlogger/mindlogger-applet-library/node_modules/vuetify/lib/util/mergeData.js","dependencies":[{"path":"/Volumes/Disk1/work/work/mindlogger/mindlogger-applet-library/node_modules/vuetify/lib/util/mergeData.js","mtime":499162500000},{"path":"/Volumes/Disk1/work/work/mindlogger/mindlogger-applet-library/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Volumes/Disk1/work/work/mindlogger/mindlogger-applet-library/node_modules/@vue/cli-plugin-babel/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es7.object.get-own-property-descriptors\";\nimport _defineProperty from \"/Volumes/Disk1/work/work/mindlogger/mindlogger-applet-library/node_modules/@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport \"core-js/modules/es6.object.keys\";\nimport _slicedToArray from \"/Volumes/Disk1/work/work/mindlogger/mindlogger-applet-library/node_modules/@babel/runtime-corejs2/helpers/esm/slicedToArray\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/es6.regexp.split\";\nimport \"core-js/modules/web.dom.iterable\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { camelize } from \"./helpers\";\nvar pattern = {\n  styleList: /;(?![^(]*\\))/g,\n  styleProp: /:(.*)/\n};\n\nfunction parseStyle(style) {\n  var styleMap = {};\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = style.split(pattern.styleList)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var s = _step.value;\n\n      var _s$split = s.split(pattern.styleProp),\n          _s$split2 = _slicedToArray(_s$split, 2),\n          key = _s$split2[0],\n          val = _s$split2[1];\n\n      key = key.trim();\n\n      if (!key) {\n        continue;\n      } // May be undefined if the `key: value` pair is incomplete.\n\n\n      if (typeof val === 'string') {\n        val = val.trim();\n      }\n\n      styleMap[camelize(key)] = val;\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return styleMap;\n}\n\nexport default function mergeData() {\n  var mergeTarget = {};\n  var i = arguments.length;\n  var prop;\n  var event; // Allow for variadic argument length.\n\n  while (i--) {\n    // Iterate through the data properties and execute merge strategies\n    // Object.keys eliminates need for hasOwnProperty call\n    for (var _i = 0, _Object$keys = Object.keys(arguments[i]); _i < _Object$keys.length; _i++) {\n      prop = _Object$keys[_i];\n\n      switch (prop) {\n        // Array merge strategy (array concatenation)\n        case 'class':\n        case 'style':\n        case 'directives':\n          if (!arguments[i][prop]) {\n            break;\n          }\n\n          if (!Array.isArray(mergeTarget[prop])) {\n            mergeTarget[prop] = [];\n          }\n\n          if (prop === 'style') {\n            var style = void 0;\n\n            if (Array.isArray(arguments[i].style)) {\n              style = arguments[i].style;\n            } else {\n              style = [arguments[i].style];\n            }\n\n            for (var j = 0; j < style.length; j++) {\n              var s = style[j];\n\n              if (typeof s === 'string') {\n                style[j] = parseStyle(s);\n              }\n            }\n\n            arguments[i].style = style;\n          } // Repackaging in an array allows Vue runtime\n          // to merge class/style bindings regardless of type.\n\n\n          mergeTarget[prop] = mergeTarget[prop].concat(arguments[i][prop]);\n          break;\n        // Space delimited string concatenation strategy\n\n        case 'staticClass':\n          if (!arguments[i][prop]) {\n            break;\n          }\n\n          if (mergeTarget[prop] === undefined) {\n            mergeTarget[prop] = '';\n          }\n\n          if (mergeTarget[prop]) {\n            // Not an empty string, so concatenate\n            mergeTarget[prop] += ' ';\n          }\n\n          mergeTarget[prop] += arguments[i][prop].trim();\n          break;\n        // Object, the properties of which to merge via array merge strategy (array concatenation).\n        // Callback merge strategy merges callbacks to the beginning of the array,\n        // so that the last defined callback will be invoked first.\n        // This is done since to mimic how Object.assign merging\n        // uses the last given value to assign.\n\n        case 'on':\n        case 'nativeOn':\n          if (!arguments[i][prop]) {\n            break;\n          }\n\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = {};\n          }\n\n          var listeners = mergeTarget[prop];\n\n          for (var _i2 = 0, _Object$keys2 = Object.keys(arguments[i][prop] || {}); _i2 < _Object$keys2.length; _i2++) {\n            event = _Object$keys2[_i2];\n\n            // Concat function to array of functions if callback present.\n            if (listeners[event]) {\n              // Insert current iteration data in beginning of merged array.\n              listeners[event] = Array().concat( // eslint-disable-line\n              listeners[event], arguments[i][prop][event]);\n            } else {\n              // Straight assign.\n              listeners[event] = arguments[i][prop][event];\n            }\n          }\n\n          break;\n        // Object merge strategy\n\n        case 'attrs':\n        case 'props':\n        case 'domProps':\n        case 'scopedSlots':\n        case 'staticStyle':\n        case 'hook':\n        case 'transition':\n          if (!arguments[i][prop]) {\n            break;\n          }\n\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = {};\n          }\n\n          mergeTarget[prop] = _objectSpread({}, arguments[i][prop], {}, mergeTarget[prop]);\n          break;\n        // Reassignment strategy (no merge)\n\n        case 'slot':\n        case 'key':\n        case 'ref':\n        case 'tag':\n        case 'show':\n        case 'keepAlive':\n        default:\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = arguments[i][prop];\n          }\n\n      }\n    }\n  }\n\n  return mergeTarget;\n}",{"version":3,"sources":["/Volumes/Disk1/work/work/mindlogger/mindlogger-applet-library/node_modules/vuetify/lib/util/mergeData.js"],"names":["camelize","pattern","styleList","styleProp","parseStyle","style","styleMap","split","s","key","val","trim","mergeData","mergeTarget","i","arguments","length","prop","event","Object","keys","Array","isArray","j","concat","undefined","listeners"],"mappings":"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","sourcesContent":["import { camelize } from './helpers';\nconst pattern = {\n  styleList: /;(?![^(]*\\))/g,\n  styleProp: /:(.*)/\n};\n\nfunction parseStyle(style) {\n  const styleMap = {};\n\n  for (const s of style.split(pattern.styleList)) {\n    let [key, val] = s.split(pattern.styleProp);\n    key = key.trim();\n\n    if (!key) {\n      continue;\n    } // May be undefined if the `key: value` pair is incomplete.\n\n\n    if (typeof val === 'string') {\n      val = val.trim();\n    }\n\n    styleMap[camelize(key)] = val;\n  }\n\n  return styleMap;\n}\n\nexport default function mergeData() {\n  const mergeTarget = {};\n  let i = arguments.length;\n  let prop;\n  let event; // Allow for variadic argument length.\n\n  while (i--) {\n    // Iterate through the data properties and execute merge strategies\n    // Object.keys eliminates need for hasOwnProperty call\n    for (prop of Object.keys(arguments[i])) {\n      switch (prop) {\n        // Array merge strategy (array concatenation)\n        case 'class':\n        case 'style':\n        case 'directives':\n          if (!arguments[i][prop]) {\n            break;\n          }\n\n          if (!Array.isArray(mergeTarget[prop])) {\n            mergeTarget[prop] = [];\n          }\n\n          if (prop === 'style') {\n            let style;\n\n            if (Array.isArray(arguments[i].style)) {\n              style = arguments[i].style;\n            } else {\n              style = [arguments[i].style];\n            }\n\n            for (let j = 0; j < style.length; j++) {\n              const s = style[j];\n\n              if (typeof s === 'string') {\n                style[j] = parseStyle(s);\n              }\n            }\n\n            arguments[i].style = style;\n          } // Repackaging in an array allows Vue runtime\n          // to merge class/style bindings regardless of type.\n\n\n          mergeTarget[prop] = mergeTarget[prop].concat(arguments[i][prop]);\n          break;\n        // Space delimited string concatenation strategy\n\n        case 'staticClass':\n          if (!arguments[i][prop]) {\n            break;\n          }\n\n          if (mergeTarget[prop] === undefined) {\n            mergeTarget[prop] = '';\n          }\n\n          if (mergeTarget[prop]) {\n            // Not an empty string, so concatenate\n            mergeTarget[prop] += ' ';\n          }\n\n          mergeTarget[prop] += arguments[i][prop].trim();\n          break;\n        // Object, the properties of which to merge via array merge strategy (array concatenation).\n        // Callback merge strategy merges callbacks to the beginning of the array,\n        // so that the last defined callback will be invoked first.\n        // This is done since to mimic how Object.assign merging\n        // uses the last given value to assign.\n\n        case 'on':\n        case 'nativeOn':\n          if (!arguments[i][prop]) {\n            break;\n          }\n\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = {};\n          }\n\n          const listeners = mergeTarget[prop];\n\n          for (event of Object.keys(arguments[i][prop] || {})) {\n            // Concat function to array of functions if callback present.\n            if (listeners[event]) {\n              // Insert current iteration data in beginning of merged array.\n              listeners[event] = Array().concat( // eslint-disable-line\n              listeners[event], arguments[i][prop][event]);\n            } else {\n              // Straight assign.\n              listeners[event] = arguments[i][prop][event];\n            }\n          }\n\n          break;\n        // Object merge strategy\n\n        case 'attrs':\n        case 'props':\n        case 'domProps':\n        case 'scopedSlots':\n        case 'staticStyle':\n        case 'hook':\n        case 'transition':\n          if (!arguments[i][prop]) {\n            break;\n          }\n\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = {};\n          }\n\n          mergeTarget[prop] = { ...arguments[i][prop],\n            ...mergeTarget[prop]\n          };\n          break;\n        // Reassignment strategy (no merge)\n\n        case 'slot':\n        case 'key':\n        case 'ref':\n        case 'tag':\n        case 'show':\n        case 'keepAlive':\n        default:\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = arguments[i][prop];\n          }\n\n      }\n    }\n  }\n\n  return mergeTarget;\n}\n//# sourceMappingURL=mergeData.js.map"]}]}